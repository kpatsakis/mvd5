static enum doContent(XML_Parser int const ENCODING const char const char const char XML_Bool haveMore) DTD * const dtd = _dtd const char * * eventPP ; if ( enc == encoding )  eventPP = & eventPtr; eventPP = & ( openInternalEntities -> internalEventPtr ); const char * next = s ; int tok = XmlContentTok ( enc , s , end , & next ) ; switch ( tok )  const XML_Char * name ; ENTITY * entity ; XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , s + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ; if ( ch )  name = poolStoreString ( & dtd -> pool , enc , s + enc -> minBytesPerChar , next - enc -> minBytesPerChar ); if ( ! name )  entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 ); static NAMED lookup(HASH_TABLE *table, KEY name, size_t createSize) size_t i ; if ( table -> size == 0 )  size_t tsize ; if ( ! createSize )  return NULL ; table -> power = INIT_POWER; table -> size = ( size_t ) 1 << INIT_POWER; tsize = table -> size * sizeof ( NAMED * ); table -> v = ( NAMED * * ) table -> mem -> malloc_fcn ( tsize ); if ( ! table -> v )  return NULL ; memset ( table -> v , 0 , tsize ); i = hash ( name ) & ( ( unsigned long ) table -> size - 1 ); unsigned long h = hash ( name ) ; unsigned long mask = ( unsigned long ) table -> size - 1 ; unsigned char step = 0 ; i = h & mask; while ( table -> v [ i ] )  if ( keyeq ( name , table -> v [ i ] -> name ) )  return table -> v [ i ] ; if ( ! step )  step = PROBE_STEP ( h , mask , table -> power ); i < step ? ( i += table -> size - step ) : ( i -= step ); if ( ! createSize )  return NULL ; if ( table -> used >> ( table -> power - 1 ) )  unsigned char newPower = table -> power + 1 ; size_t newSize = ( size_t ) 1 << newPower ; unsigned long newMask = ( unsigned long ) newSize - 1 ; size_t tsize = newSize * sizeof ( NAMED * ) ; NAMED * * newV = ( NAMED * * ) table -> mem -> malloc_fcn ( tsize ) ; if ( ! newV )  return NULL ; memset ( newV , 0 , tsize ); for (i = 0; i < table->size; i++) if ( table -> v [ i ] )  unsigned long newHash = hash ( table -> v [ i ] -> name ) ; size_t j = newHash & newMask ; step = 0; while ( newV [ j ] )  if ( ! step )  step = PROBE_STEP ( newHash , newMask , newPower ); j < step ? ( j += newSize - step ) : ( j -= step ); newV [ j ] = table -> v [ i ]; table -> v = newV; table -> power = newPower; table -> size = newSize; i = h & newMask; step = 0; while ( table -> v [ i ] )  if ( ! step )  step = PROBE_STEP ( h , newMask , newPower ); i < step ? ( i += newSize - step ) : ( i -= step ); table -> v [ i ] = ( NAMED * ) table -> mem -> malloc_fcn ( createSize ); if ( ! table -> v [ i ] )  return NULL ; memset ( table -> v [ i ] , 0 , createSize ); table -> v [ i ] -> name = name; ( table -> used ) ++; return table -> v [ i ] ; if ( ! dtd -> hasParamEntityRefs || dtd -> standalone )  if ( ! entity )  if ( ! entity -> is_internal )  if ( ! entity )  if ( entity -> open )  if ( entity -> notation )  if ( entity -> textPtr )  enum XML_Error result ; if ( ! defaultExpandInternalEntities )  result = processInternalEntity ( parser , entity , XML_FALSE ); static enum processInternalEntity(XML_Parser parser, ENTITY XML_Bool betweenDecl) const char * textStart , * textEnd ; const char * next ; enum XML_Error result ; OPEN_INTERNAL_ENTITY * openEntity ; if ( freeInternalEntities )  openEntity = ( OPEN_INTERNAL_ENTITY * ) MALLOC ( sizeof ( OPEN_INTERNAL_ENTITY ) ); if ( ! openEntity )  return XML_ERROR_NO_MEMORY ; entity -> open = XML_TRUE; entity -> processed = 0; textStart = ( char * ) entity -> textPtr; textEnd = ( char * ) ( entity -> textPtr + entity -> textLen ); if ( entity -> is_param )  int tok = XmlPrologTok ( internalEncoding , textStart , textEnd , & next ) ; result = doProlog ( parser , internalEncoding , textStart , textEnd , tok , next , & next , XML_FALSE ); result = doContent ( parser , tagLevel , internalEncoding , textStart , textEnd , & next , XML_FALSE ); return result ; if ( result != XML_ERROR_NONE )  if ( externalEntityRefHandler )  const XML_Char * context ; entity -> open = XML_TRUE; context = getContext ( parser ); static const XML_Char getContext(XML_Parser parser) DTD * const dtd = _dtd XML_Bool needSep = XML_FALSE ; if ( dtd -> defaultPrefix . binding )  int i ; int len ; if ( ! poolAppendChar ( & tempPool , XML_T ( '=' ) ) )  return NULL ; len = dtd -> defaultPrefix . binding -> uriLen; if ( namespaceSeparator )  len --; for (i = 0; i < len; i++) if ( ! poolAppendChar ( & tempPool , dtd -> defaultPrefix . binding -> uri [ i ] ) )  return NULL ; needSep = XML_TRUE; int i ; int len ; const XML_Char * s ; PREFIX * prefix = ( PREFIX * ) hashTableIterNext ( & iter ) ; static NAMED * hashTableIterNext(HASH_TABLE_ITER *iter) while ( iter -> p != iter -> end )  NAMED * tem = * ( iter -> p ) ++ ; if ( tem )  return tem ; return NULL ; if ( ! prefix )  if ( ! prefix -> binding )  if ( needSep && ! poolAppendChar ( & tempPool , CONTEXT_SEP ) )  return NULL ; for (s = prefix->name; *s; s++) if ( ! poolAppendChar ( & tempPool , * s ) )  return NULL ; if ( ! poolAppendChar ( & tempPool , XML_T ( '=' ) ) )  return NULL ; len = prefix -> binding -> uriLen; if ( namespaceSeparator )  len --; for (i = 0; i < len; i++) if ( ! poolAppendChar ( & tempPool , prefix -> binding -> uri [ i ] ) )  return NULL ; needSep = XML_TRUE; const XML_Char * s ; ENTITY * e = ( ENTITY * ) hashTableIterNext ( & iter ) ; static NAMED * hashTableIterNext(HASH_TABLE_ITER *iter) while ( iter -> p != iter -> end )  NAMED * tem = * ( iter -> p ) ++ ; if ( tem )  return tem ; return NULL ; if ( ! e )  if ( ! e -> open )  if ( needSep && ! poolAppendChar ( & tempPool , CONTEXT_SEP ) )  return NULL ; for (s = e->name; *s; s++) if ( ! poolAppendChar ( & tempPool , * s ) )  return 0 ; needSep = XML_TRUE; if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )  return NULL ; return tempPool . start ; entity -> open = XML_FALSE; if ( ! context )  if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , context , entity -> base , entity -> systemId , entity -> publicId ) )  TAG * tag ; enum XML_Error result ; XML_Char * toPtr ; if ( freeTagList )  tag = freeTagList; freeTagList = freeTagList -> parent; tag = ( TAG * ) MALLOC ( sizeof ( TAG ) ); if ( ! tag )  tag -> buf = ( char * ) MALLOC ( INIT_TAG_BUF_SIZE ); if ( ! tag -> buf )  tag -> bufEnd = tag -> buf + INIT_TAG_BUF_SIZE; tag -> bindings = NULL; tag -> parent = tagStack; tagStack = tag; tag -> name . localPart = NULL; tag -> name . prefix = NULL; tag -> rawName = s + enc -> minBytesPerChar; tag -> rawNameLength = XmlNameLength ( enc , tag -> rawName ); const char * rawNameEnd = tag -> rawName + tag -> rawNameLength ; const char * fromPtr = tag -> rawName ; toPtr = ( XML_Char * ) tag -> buf; int bufSize ; int convLen ; convLen = ( int ) ( toPtr - ( XML_Char * ) tag -> buf ); if ( fromPtr == rawNameEnd )  tag -> name . strLen = convLen; bufSize = ( int ) ( tag -> bufEnd - tag -> buf ) << 1; char * temp = ( char * ) REALLOC ( tag -> buf , bufSize ) ; if ( temp == NULL )  tag -> buf = temp; tag -> bufEnd = temp + bufSize; toPtr = ( XML_Char * ) temp + convLen; tag -> name . str = ( XML_Char * ) tag -> buf; result = storeAtts ( parser , enc , s , & ( tag -> name ) , & ( tag -> bindings ) ); if ( result )  const char * rawName = s + enc -> minBytesPerChar ; enum XML_Error result ; TAG_NAME name ; name . str = poolStoreString ( & tempPool , enc , rawName , rawName + XmlNameLength ( enc , rawName ) ); if ( ! name . str )  result = storeAtts ( parser , enc , s , & name , & bindings ); if ( result )  if ( tagLevel == 0 )  if ( tagLevel == startTagLevel )  int len ; const char * rawName ; TAG * tag = tagStack ; tagStack = tag -> parent; tag -> parent = freeTagList; freeTagList = tag; rawName = s + enc -> minBytesPerChar * 2; len = XmlNameLength ( enc , rawName ); if ( len != tag -> rawNameLength || memcmp ( tag -> rawName , rawName , len ) != 0 )  while ( tag -> bindings )  tag -> bindings = tag -> bindings -> nextTagBinding; if ( tagLevel == 0 )  int n = XmlCharRefNumber ( enc , s ) ; if ( n < 0 )  enum XML_Error result ; result = doCdataSection ( parser , enc , & next , end , nextPtr , haveMore ); static enum doCdataSection(XML_Parser const ENCODING const char const char const char XML_Bool haveMore) const char * s = * startPtr ; const char * * eventPP ; if ( enc == encoding )  eventPP = & eventPtr; * eventPP = s; eventPP = & ( openInternalEntities -> internalEventPtr ); * eventPP = s; const char * next ; int tok = XmlCdataSectionTok ( enc , s , end , & next ) ; switch ( tok )  if ( ps_parsing == XML_FINISHED )  return XML_ERROR_ABORTED ; return XML_ERROR_NONE ; if ( characterDataHandler )  if ( MUST_CONVERT ( enc , s ) )  if ( s == next )  * eventPP = s; * eventPP = next; return XML_ERROR_INVALID_TOKEN ; if ( haveMore )  return XML_ERROR_NONE ; return XML_ERROR_PARTIAL_CHAR ; if ( haveMore )  return XML_ERROR_NONE ; return XML_ERROR_UNCLOSED_CDATA_SECTION ; * eventPP = next; return XML_ERROR_UNEXPECTED_STATE ; * eventPP = s = next; switch ( ps_parsing )  return XML_ERROR_NONE ; return XML_ERROR_ABORTED ; if ( result != XML_ERROR_NONE )  if ( ! next )  if ( characterDataHandler )  if ( MUST_CONVERT ( enc , s ) )  if ( s == next )  * eventPP = s; if ( ! reportProcessingInstruction ( parser , enc , s , next ) )  if ( ! reportComment ( parser , enc , s , next ) )  * eventPP = s = next; switch ( ps_parsing )  static XML_Char poolStoreString(STRING_POOL *pool, const ENCODING const char *ptr, const char *end) if ( ! poolAppend ( pool , enc , ptr , end ) )  static XML_Char poolAppend(STRING_POOL *pool, const ENCODING const char *ptr, const char *end) if ( ! pool -> ptr && ! poolGrow ( pool ) )  static XML_Bool poolGrow(STRING_POOL *pool) if ( pool -> freeBlocks )  if ( pool -> start == 0 )  if ( pool -> end - pool -> start < pool -> freeBlocks -> size )  BLOCK * tem = pool -> freeBlocks -> next ; pool -> freeBlocks -> next = pool -> blocks; pool -> blocks = pool -> freeBlocks; pool -> freeBlocks = tem; memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) ); pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ); pool -> start = pool -> blocks -> s; pool -> end = pool -> start + pool -> blocks -> size; 