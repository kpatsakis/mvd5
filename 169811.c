static int gif_encode_frame(AVCodecContext *avctx, AVPacket const AVFrame *pict, int *got_packet) GIFContext * s = avctx -> priv_data ; uint8_t * outbuf_ptr , * end ; const uint32_t * palette = NULL ; int ret ; if ( ( ret = ff_alloc_packet2 ( avctx , pkt , avctx -> width * avctx -> height * 7 / 5 + AV_INPUT_BUFFER_MIN_SIZE , 0 ) ) < 0 )  outbuf_ptr = pkt -> data; end = pkt -> data + pkt -> size; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 )  uint8_t * pal_exdata = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ) ; if ( ! pal_exdata )  memcpy ( pal_exdata , pict -> data [ 1 ] , AVPALETTE_SIZE ); palette = ( uint32_t * ) pict -> data [ 1 ]; s -> pal_exdata = pal_exdata; if ( ! s -> palette_loaded )  palette = NULL; if ( ! memcmp ( s -> palette , palette , AVPALETTE_SIZE ) )  palette = NULL; gif_image_write_image ( avctx , & outbuf_ptr , end , palette , pict -> data [ 0 ] , pict -> linesize [ 0 ] , pkt ); static int gif_image_write_image(AVCodecContext uint8_t **bytestream, uint8_t const uint32_t const uint8_t *buf, const int AVPacket *pkt) GIFContext * s = avctx -> priv_data ; int len = 0 , height = avctx -> height , width = avctx -> width , x , y ; int x_start = 0 , y_start = 0 , trans = s -> transparent_index ; int honor_transparency = ( s -> flags & GF_TRANSDIFF ) && s -> last_frame ; if ( ( s -> flags & GF_OFFSETTING ) && s -> last_frame && ! palette )  const uint8_t * ref = s -> last_frame -> data [ 0 ] ; const int ref_linesize = s -> last_frame -> linesize [ 0 ] ; int x_end = avctx -> width - 1 , y_end = avctx -> height - 1 ; while ( y_start < y_end )  if ( memcmp ( ref + y_start * ref_linesize , buf + y_start * linesize , width ) )  y_start ++; while ( y_end > y_start )  if ( memcmp ( ref + y_end * ref_linesize , buf + y_end * linesize , width ) )  y_end --; height = y_end + 1 - y_start; while ( x_start < x_end )  int same_column = 1 ; for (y = y_start; y <= y_end; y++) if ( ref [ y * ref_linesize + x_start ] != buf [ y * linesize + x_start ] )  same_column = 0; if ( ! same_column )  x_start ++; while ( x_end > x_start )  int same_column = 1 ; for (y = y_start; y <= y_end; y++) if ( ref [ y * ref_linesize + x_end ] != buf [ y * linesize + x_end ] )  same_column = 0; if ( ! same_column )  x_end --; width = x_end + 1 - x_start; if ( honor_transparency && trans < 0 )  trans = pick_palette_entry ( buf + y_start * linesize + x_start , linesize , width , height ); static int pick_palette_entry(const uint8_t *buf, int linesize, int w, int h) int histogram [ AVPALETTE_COUNT ] = { 0 } ; int x , y , i ; for (y = 0; y < h; y++) for (x = 0; x < w; x++) histogram [ buf [ x ] ] ++; buf += linesize; for (i = 0; i < FF_ARRAY_ELEMS(histogram); i++) if ( ! histogram [ i ] )  return i ; return - 1 ; if ( trans < 0 )  uint8_t * pal_exdata = s -> pal_exdata ; if ( ! pal_exdata )  pal_exdata = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ); if ( ! pal_exdata )  memcpy ( pal_exdata , s -> palette , AVPALETTE_SIZE ); pal_exdata [ trans * 4 + 3 * ! HAVE_BIGENDIAN ] = 0x00; if ( trans < 0 )  if ( ref [ x ] == ptr [ x ] )  s -> tmpl [ x ] = trans; len += ff_lzw_encode ( s -> lzw , s -> tmpl , width ); len += ff_lzw_encode_flush ( s -> lzw , flush_put_bits ); ptr = s -> buf; while ( len > 0 )  int size = FFMIN ( 255 , len ) ; bytestream_put_byte ( bytestream , size ); if ( end - * bytestream < size )  bytestream_put_buffer ( bytestream , ptr , size ); ptr += size; len -= size; 