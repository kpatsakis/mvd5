status_t MediaBuffer **out, const ReadOptions *options) if ( mFirstMoofOffset > 0 )  int64_t seekTimeUs ; ReadOptions :: SeekMode mode ; if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) )  uint32_t findFlags = 0 ; switch ( mode )  findFlags = SampleTable :: kFlagBefore; findFlags = SampleTable :: kFlagAfter; findFlags = SampleTable :: kFlagClosest; uint32_t sampleIndex ; status_t err = mSampleTable -> findSampleAtTime ( seekTimeUs * mTimescale / 1000000 , & sampleIndex , findFlags ) ; if ( mode == ReadOptions :: SEEK_CLOSEST )  findFlags = SampleTable :: kFlagBefore; uint32_t syncSampleIndex ; if ( err == OK )  err = mSampleTable -> findSyncSampleNear ( sampleIndex , & syncSampleIndex , findFlags ); if ( err == OK )  err = mSampleTable -> getMetaDataForSample ( sampleIndex , NULL , NULL , & sampleTime ); if ( err != OK )  if ( mode == ReadOptions :: SEEK_CLOSEST )  if ( ! mTimescale )  mCurrentSampleIndex = syncSampleIndex; if ( mBuffer != NULL )  mBuffer = NULL; if ( mBuffer == NULL )  status_t err = mSampleTable -> getMetaDataForSample ( mCurrentSampleIndex , & offset , & size , & cts , & duration , & isSyncSample , & dts ) ; if ( err != OK )  int32_t max_size ; if ( ! ValidInputSize ( max_size ) )  static bool ValidInputSize(int32_t size) return ( size > 0 && size < 4 * ( 1920 * 1080 ) * 3 / 2 ) ; mBuffer = new MediaBuffer ( max_size ); assert ( mBuffer ); 