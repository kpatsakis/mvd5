static brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device struct cfg80211_ap_settings *settings) s32 ie_offset ; struct brcmf_if * ifp = netdev_priv ( ndev ) ; const struct brcmf_tlv * ssid_ie ; const struct brcmf_tlv * rsn_ie ; const struct brcmf_vs_tlv * wpa_ie ; if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); if ( ! ssid_ie )  rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN ); wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len ); if ( wpa_ie != NULL || rsn_ie != NULL )  if ( wpa_ie != NULL )  err = brcmf_configure_wpaie ( ifp , wpa_ie , false ); if ( err < 0 )  struct brcmf_vs_tlv * tmp_ie ; tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie; err = brcmf_configure_wpaie ( ifp , tmp_ie , true ); if ( err < 0 )  brcmf_config_ap_mgmt_ie ( ifp -> vif , & settings -> beacon ); static brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif struct cfg80211_beacon_data *beacon) s32 err ; err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_BEACON_FLAG , beacon -> tail , beacon -> tail_len ); if ( err )  err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_PRBRSP_FLAG , beacon -> proberesp_ies , beacon -> proberesp_ies_len ); s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 const u8 *vndr_ie_buf, u32 vndr_ie_len) struct vif_saved_ie * saved_ie ; u8 * iovar_ie_buf ; u8 * curr_ie_buf ; int mgmt_ie_buf_len ; struct parsed_vndr_ies new_vndr_ies ; if ( ! vif )  saved_ie = & vif -> saved_ie; iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL ); if ( ! iovar_ie_buf )  curr_ie_buf = iovar_ie_buf; switch ( pktflag )  mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie ); mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie ); mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie ); mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie ); if ( vndr_ie_len > mgmt_ie_buf_len )  if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )  brcmf_parse_vndr_ies ( vndr_ie_buf , vndr_ie_len , & new_vndr_ies ); static brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32 struct parsed_vndr_ies *vndr_ies) struct brcmf_vs_tlv * vndrie ; struct brcmf_tlv * ie ; s32 remaining_len ; remaining_len = ( s32 ) vndr_ie_len; memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) ); ie = ( struct brcmf_tlv * ) vndr_ie_buf; while ( ie )  if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )  vndrie = ( struct brcmf_vs_tlv * ) ie; if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )  if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )  vndr_ies -> count ++; if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )  remaining_len -= ( ie -> len + TLV_HDR_LEN ); if ( remaining_len <= TLV_HDR_LEN )  ie = NULL; ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN ); 