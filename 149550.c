 CVE_2009_1439_PATCHED_CIFSTCon(unsigned int xid, struct cifsSesInfo const char *tree, struct cifsTconInfo const struct nls_table *nls_codepage) struct smb_hdr * smb_buffer ; struct smb_hdr * smb_buffer_response ; TCONX_REQ * pSMB ; unsigned char * bcc_ptr ; int length ; if ( ses == NULL )  smb_buffer = cifs_buf_get ( ); if ( smb_buffer == NULL )  smb_buffer_response = smb_buffer; smb_buffer -> Mid = GetNextMid ( ses -> server ); smb_buffer -> Uid = ses -> Suid; pSMB = ( TCONX_REQ * ) smb_buffer; pSMB -> AndXCommand = 0xFF; pSMB -> Flags = cpu_to_le16 ( TCON_EXTENDED_SECINFO ); bcc_ptr = & pSMB -> Password [ 0 ]; if ( ( ses -> server -> secMode ) & SECMODE_USER )  * bcc_ptr = 0; bcc_ptr ++; bcc_ptr += CIFS_SESS_KEY_SIZE; if ( ses -> capabilities & CAP_UNICODE )  * bcc_ptr = 0; bcc_ptr ++; if ( ses -> server -> secMode & ( SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED ) )  smb_buffer -> Flags2 |= SMBFLG2_SECURITY_SIGNATURE; if ( ses -> capabilities & CAP_STATUS32 )  smb_buffer -> Flags2 |= SMBFLG2_ERR_STATUS; if ( ses -> capabilities & CAP_DFS )  smb_buffer -> Flags2 |= SMBFLG2_DFS; if ( ses -> capabilities & CAP_UNICODE )  smb_buffer -> Flags2 |= SMBFLG2_UNICODE; length = cifs_strtoUCS ( ( __le16 * ) bcc_ptr , tree , 6 * ( + 256 ) , nls_codepage ); bcc_ptr += 2 * length; bcc_ptr += 2; strcpy ( bcc_ptr , tree ); bcc_ptr += strlen ( tree ) + 1; strcpy ( bcc_ptr , "?????" ); bcc_ptr += strlen ( "?????" ); bcc_ptr += 1; rc = SendReceive ( xid , ses , smb_buffer , smb_buffer_response , & length , CIFS_STD_OP ); if ( ( rc == 0 ) && ( tcon != NULL ) )  bcc_ptr = pByteArea ( smb_buffer_response ); length = strnlen ( bcc_ptr , BCC ( smb_buffer_response ) - 2 ); bcc_ptr += length + 1; if ( smb_buffer -> Flags2 & SMBFLG2_UNICODE )  length = strnlen ( bcc_ptr , 1024 ); if ( ( bcc_ptr + length ) - pByteArea ( smb_buffer_response ) <= BCC ( smb_buffer_response ) )  tcon -> nativeFileSystem = kzalloc ( length + 1 , GFP_KERNEL ); if ( tcon -> nativeFileSystem )  strncpy ( tcon -> nativeFileSystem , bcc_ptr , length ); tcon -> Flags = le16_to_cpu ( pSMBr -> OptionalSupport ); cFYI ( 1 , ( "Tcon flags: 0x%x " , tcon -> Flags ) ); 