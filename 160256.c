int avio_read(AVIOContext *s,unsigned char *buf,int size) int len ; while ( size > 0 )  len = ( s -> buf_end - s -> buf_ptr ); if ( len > size )  len = size; if ( len == 0 || s -> write_flag )  if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )  if ( s -> read_packet )  len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) ); if ( len <= 0 )  if ( len < 0 )  s -> error = len; s -> pos += len; s -> bytes_read += len; size -= len; buf += len; s -> buf_ptr = s -> buffer; s -> buf_end = s -> buffer; len = ( s -> buf_end - s -> buf_ptr ); if ( len == 0 )  memcpy ( buf , ( s -> buf_ptr ) , len ); buf += len; s -> buf_ptr += len; size -= len; if ( size1 == size )  if ( s -> error )  return s -> error ; if ( url_feof ( s ) )  int url_feof(AVIOContext *s) if ( ! s )  if ( s -> eof_reached )  s -> eof_reached = 0; fill_buffer ( s ); static void fill_buffer(AVIOContext *s) uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ; if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )  s -> eof_reached = 1; if ( s -> eof_reached )  if ( s -> update_checksum && dst == s -> buffer )  if ( s -> buf_end > s -> checksum_ptr )  s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ); s -> checksum_ptr = s -> buffer; if ( s -> read_packet && s -> buffer_size > max_buffer_size )  ffio_set_buf_size ( s , max_buffer_size ); int ffio_set_buf_size(AVIOContext *s,int buf_size) buffer = ( av_malloc ( buf_size ) ); if ( ! buffer )  av_free ( ( s -> buffer ) ); s -> buffer = buffer; s -> buffer_size = buf_size; s -> buf_ptr = buffer; url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) ); static int url_resetbuf(AVIOContext *s,int flags) if ( flags & 2 )  s -> buf_end = s -> buffer + s -> buffer_size; s -> write_flag = 1; s -> buf_end = s -> buffer; s -> write_flag = 0; s -> checksum_ptr = dst = s -> buffer; len = s -> buffer_size; if ( s -> read_packet )  len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) ); if ( len <= 0 )  s -> eof_reached = 1; if ( len < 0 )  s -> error = len; s -> pos += len; s -> buf_ptr = dst; s -> buf_end = dst + len; s -> bytes_read += len; return s -> eof_reached ; return size1 - size ; 