 IMFYCbCrImage::GetD3D9TextureClient(CompositableClient* aClient) IDirect3DDevice9 * device = gfxWindowsPlatform :: GetPlatform ( ) -> GetD3D9Device ( ) ; RefPtr < IDirect3DTexture9 > textureY ; HANDLE shareHandleY = 0 ; if ( ! UploadData ( device , textureY , shareHandleY , mData . mYChannel , mData . mYSize , mData . mYStride ) )  RefPtr < IDirect3DTexture9 > textureCb ; HANDLE shareHandleCb = 0 ; if ( ! UploadData ( device , textureCb , shareHandleCb , mData . mCbChannel , mData . mCbCrSize , mData . mCbCrStride ) )  static bool UploadData(IDirect3DDevice9* RefPtr<IDirect3DTexture9>& HANDLE& uint8_t* const gfx::IntSize& int32_t aSrcStride) RefPtr < IDirect3DSurface9 > surf ; D3DLOCKED_RECT rect ; aTexture = InitTextures ( aDevice , aSrcSize , D3DFMT_A8 , surf , aHandle , rect ); static InitTextures(IDirect3DDevice9* const IntSize _D3DFORMAT RefPtr<IDirect3DSurface9>& HANDLE& D3DLOCKED_RECT& aLockedRect) if ( ! aDevice )  return nullptr ; RefPtr < IDirect3DTexture9 > result ; if ( FAILED ( aDevice -> CreateTexture ( aSize . width , aSize . height , 1 , 0 , aFormat , D3DPOOL_DEFAULT , byRef ( result ) , & aHandle ) ) )  return nullptr ; if ( ! result )  return nullptr ; RefPtr < IDirect3DTexture9 > tmpTexture ; if ( FAILED ( aDevice -> CreateTexture ( aSize . width , aSize . height , 1 , 0 , aFormat , D3DPOOL_SYSTEMMEM , byRef ( tmpTexture ) , nullptr ) ) )  return nullptr ; if ( ! tmpTexture )  return nullptr ; if ( ! aLockedRect . pBits )  return nullptr ; return result . forget ( ) ; if ( ! aTexture )  if ( aSrcStride == rect . Pitch )  memcpy ( rect . pBits , aSrc , rect . Pitch * aSrcSize . height ); 