static dissect_http(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) http_conv_t * conv_data ; int offset = 0 ; int len ; conv_data = get_http_conversation_data ( pinfo ); static http_conv_t get_http_conversation_data(packet_info *pinfo) conversation_t * conversation ; http_conv_t * conv_data ; conversation = find_or_create_conversation ( pinfo ); conv_data = conversation_get_proto_data ( conversation , proto_http ); if ( ! conv_data )  conv_data = se_alloc0 ( sizeof ( http_conv_t ) ); return conv_data ; if ( pinfo -> fd -> num >= conv_data -> startframe && conv_data -> response_code == 200 && conv_data -> request_method && strncmp ( conv_data -> request_method , "CONNECT" , 7 ) == 0 && conv_data -> request_uri )  while ( tvb_reported_length_remaining ( tvb , offset ) != 0 )  len = dissect_http_message ( tvb , offset , pinfo , tree , conv_data ); if ( len == - 1 )  offset += len; static dissect_http_message(tvbuff_t *tvb, int offset, packet_info proto_tree *tree, http_conv_t *conv_data) proto_tree * http_tree = NULL ; const guchar * line ; gint next_offset ; const guchar * linep , * lineend ; int first_linelen , linelen ; gboolean is_request_or_reply ; guchar c ; http_type_t http_type ; ReqRespDissector reqresp_dissector ; int colon_offset ; headers_t headers ; first_linelen = tvb_find_line_end ( tvb , offset , tvb_ensure_length_remaining ( tvb , offset ) , & next_offset , FALSE ); line = tvb_get_ptr ( tvb , offset , first_linelen ); http_type = HTTP_OTHERS; is_request_or_reply = is_http_request_or_reply ( ( const gchar * ) line , first_linelen , & http_type , NULL , conv_data ); static is_http_request_or_reply(const gchar *data, int linelen, http_type_t ReqRespDissector http_conv_t *conv_data) int isHttpRequestOrReply = FALSE ; if ( linelen >= 2 && strncmp ( data , "M-" , 2 ) == 0 )  data += 2; linelen -= 2; if ( linelen >= 5 && strncmp ( data , "HTTP/" , 5 ) == 0 )  isHttpRequestOrReply = TRUE; const guchar * ptr = ( const guchar * ) data ; int indx = 0 ; while ( indx < linelen )  if ( * ptr == ' ' )  ptr ++; indx ++; switch ( indx )  if ( strncmp ( data , "GET" , indx ) == 0 || strncmp ( data , "PUT" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "ICY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "COPY" , indx ) == 0 || strncmp ( data , "HEAD" , indx ) == 0 || strncmp ( data , "LOCK" , indx ) == 0 || strncmp ( data , "MOVE" , indx ) == 0 || strncmp ( data , "POLL" , indx ) == 0 || strncmp ( data , "POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BCOPY" , indx ) == 0 || strncmp ( data , "BMOVE" , indx ) == 0 || strncmp ( data , "MKCOL" , indx ) == 0 || strncmp ( data , "TRACE" , indx ) == 0 || strncmp ( data , "LABEL" , indx ) == 0 || strncmp ( data , "MERGE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "DELETE" , indx ) == 0 || strncmp ( data , "SEARCH" , indx ) == 0 || strncmp ( data , "UNLOCK" , indx ) == 0 || strncmp ( data , "REPORT" , indx ) == 0 || strncmp ( data , "UPDATE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "NOTIFY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BDELETE" , indx ) == 0 || strncmp ( data , "CONNECT" , indx ) == 0 || strncmp ( data , "OPTIONS" , indx ) == 0 || strncmp ( data , "CHECKIN" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPFIND" , indx ) == 0 || strncmp ( data , "CHECKOUT" , indx ) == 0 || strncmp ( data , "CCM_POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "SUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPPATCH" , indx ) == 0 || strncmp ( data , "BPROPFIND" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BPROPPATCH" , indx ) == 0 || strncmp ( data , "UNCHECKOUT" , indx ) == 0 || strncmp ( data , "MKACTIVITY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "MKWORKSPACE" , indx ) == 0 || strncmp ( data , "RPC_CONNECT" , indx ) == 0 || strncmp ( data , "RPC_IN_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "UNSUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "RPC_OUT_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "VERSION-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BASELINE-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; return isHttpRequestOrReply ; if ( is_request_or_reply )  if ( ! req_resp_hdrs_do_reassembly ( tvb , offset , pinfo , http_desegment_headers , http_desegment_body ) )  if ( check_col ( pinfo -> cinfo , COL_INFO ) )  if ( is_request_or_reply )  line = tvb_get_ptr ( tvb , offset , first_linelen ); if ( tree )  ti = proto_tree_add_item ( tree , proto_http , tvb , offset , - 1 , ENC_NA ); http_tree = proto_item_add_subtree ( ti , ett_http ); http_type = HTTP_OTHERS; headers . content_type = NULL; headers . content_type_parameters = NULL; headers . have_content_length = FALSE; headers . content_length = 0; headers . content_encoding = NULL; headers . transfer_encoding = NULL; while ( tvb_reported_length_remaining ( tvb , offset ) != 0 )  linelen = tvb_find_line_end ( tvb , offset , tvb_ensure_length_remaining ( tvb , offset ) , & next_offset , FALSE ); if ( linelen < 0 )  line = tvb_get_ptr ( tvb , offset , linelen ); lineend = line + linelen; colon_offset = - 1; reqresp_dissector = NULL; is_request_or_reply = is_http_request_or_reply ( ( const gchar * ) line , linelen , & http_type , & reqresp_dissector , conv_data ); static is_http_request_or_reply(const gchar *data, int linelen, http_type_t ReqRespDissector http_conv_t *conv_data) int isHttpRequestOrReply = FALSE ; if ( linelen >= 2 && strncmp ( data , "M-" , 2 ) == 0 )  data += 2; linelen -= 2; if ( linelen >= 5 && strncmp ( data , "HTTP/" , 5 ) == 0 )  isHttpRequestOrReply = TRUE; const guchar * ptr = ( const guchar * ) data ; int indx = 0 ; while ( indx < linelen )  if ( * ptr == ' ' )  ptr ++; indx ++; switch ( indx )  if ( strncmp ( data , "GET" , indx ) == 0 || strncmp ( data , "PUT" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "ICY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "COPY" , indx ) == 0 || strncmp ( data , "HEAD" , indx ) == 0 || strncmp ( data , "LOCK" , indx ) == 0 || strncmp ( data , "MOVE" , indx ) == 0 || strncmp ( data , "POLL" , indx ) == 0 || strncmp ( data , "POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BCOPY" , indx ) == 0 || strncmp ( data , "BMOVE" , indx ) == 0 || strncmp ( data , "MKCOL" , indx ) == 0 || strncmp ( data , "TRACE" , indx ) == 0 || strncmp ( data , "LABEL" , indx ) == 0 || strncmp ( data , "MERGE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "DELETE" , indx ) == 0 || strncmp ( data , "SEARCH" , indx ) == 0 || strncmp ( data , "UNLOCK" , indx ) == 0 || strncmp ( data , "REPORT" , indx ) == 0 || strncmp ( data , "UPDATE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "NOTIFY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BDELETE" , indx ) == 0 || strncmp ( data , "CONNECT" , indx ) == 0 || strncmp ( data , "OPTIONS" , indx ) == 0 || strncmp ( data , "CHECKIN" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPFIND" , indx ) == 0 || strncmp ( data , "CHECKOUT" , indx ) == 0 || strncmp ( data , "CCM_POST" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "SUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "PROPPATCH" , indx ) == 0 || strncmp ( data , "BPROPFIND" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BPROPPATCH" , indx ) == 0 || strncmp ( data , "UNCHECKOUT" , indx ) == 0 || strncmp ( data , "MKACTIVITY" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "MKWORKSPACE" , indx ) == 0 || strncmp ( data , "RPC_CONNECT" , indx ) == 0 || strncmp ( data , "RPC_IN_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "UNSUBSCRIBE" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "RPC_OUT_DATA" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "VERSION-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; if ( strncmp ( data , "BASELINE-CONTROL" , indx ) == 0 )  isHttpRequestOrReply = TRUE; return isHttpRequestOrReply ; if ( is_request_or_reply )  if ( linelen == 0 )  linep = line; colon_offset = offset; while ( linep < lineend )  c = * linep ++; if ( ! isascii ( c ) )  if ( iscntrl ( c ) )  switch ( c )  colon_offset ++; if ( linelen == 0 )  if ( is_request_or_reply )  process_header ( tvb , offset , next_offset , line , linelen , colon_offset , pinfo , http_tree , & headers , conv_data ); offset = next_offset; static process_header(tvbuff_t *tvb, int offset, int const guchar *line, int linelen, int packet_info *pinfo, proto_tree *tree, headers_t http_conv_t *conv_data) int len ; int line_end_offset ; int header_len ; gint hf_index ; guchar c ; int value_offset ; int value_len ; char * value ; proto_item * hdr_item ; len = next_offset - offset; line_end_offset = offset + linelen; header_len = colon_offset - offset; hf_index = find_header_hf_value ( tvb , offset , header_len ); static find_header_hf_value(tvbuff_t *tvb, int offset, guint header_len) guint i ; for (i = 0; i < array_length(headers); i++) if ( header_len == strlen ( headers [ i ] . name ) && tvb_strncaseeql ( tvb , offset , headers [ i ] . name , header_len ) == 0 )  return i ; return - 1 ; value_offset = colon_offset + 1; while ( value_offset < line_end_offset && ( ( c = line [ value_offset - offset ] ) == ' ' || c == '\t' ) )  value_offset ++; value_len = line_end_offset - value_offset; value = ep_strndup ( & line [ value_offset - offset ] , value_len ); if ( hf_index == - 1 )  if ( tree )  header_field_info * hfinfo ; guint32 tmp ; hfinfo = proto_registrar_get_nth ( * headers [ hf_index ] . hf ); switch ( hfinfo -> type )  tmp = strtol ( value , NULL , 10 ); hdr_item = proto_tree_add_uint ( tree , * headers [ hf_index ] . hf , tvb , offset , len , tmp ); hdr_item = proto_tree_add_string_format ( tree , * headers [ hf_index ] . hf , tvb , offset , len , value , "%s" , format_text ( line , len ) ); hdr_item = NULL; switch ( headers [ hf_index ] . special )  if ( check_auth_ntlmssp ( hdr_item , tvb , pinfo , value ) )  static check_auth_ntlmssp(proto_item *hdr_item, tvbuff_t *tvb, packet_info gchar *value) static const char * ntlm_headers [ ] = { "NTLM " , "Negotiate " , NULL } ; const char * * header ; size_t hdrlen ; for (header = &ntlm_headers[0]; *header != NULL; header++) hdrlen = strlen ( * header ); if ( strncmp ( value , * header , hdrlen ) == 0 )  value += hdrlen; dissect_http_ntlmssp ( tvb , pinfo , hdr_tree , value ); static dissect_http_ntlmssp(tvbuff_t *tvb, packet_info *pinfo, proto_tree const char *line) ntlmssp_tvb = base64_to_tvb ( tvb , line ); add_new_data_source ( pinfo , ntlmssp_tvb , "NTLMSSP / GSSAPI Data" );  add_new_data_source(packet_info *pinfo, tvbuff_t *tvb, const char *name) src -> tvb = tvb; src -> name_initialized = FALSE; src -> name = name; pinfo -> data_src = g_slist_append ( pinfo -> data_src , src ); if ( tvb_strneql ( ntlmssp_tvb , 0 , "NTLMSSP" , 7 ) == 0 )  call_dissector ( ntlmssp_handle , ntlmssp_tvb , pinfo , tree );  call_dissector(dissector_handle_t handle, tvbuff_t packet_info *pinfo, proto_tree *tree) ret = call_dissector_only ( handle , tvb , pinfo , tree );  call_dissector_only(dissector_handle_t handle, tvbuff_t packet_info *pinfo, proto_tree *tree) g_assert ( handle != NULL ); ret = call_dissector_work ( handle , tvb , pinfo , tree , TRUE ); static call_dissector_work(dissector_handle_t handle, tvbuff_t packet_info *pinfo_arg, proto_tree *tree, gboolean add_proto_name) packet_info * pinfo = pinfo_arg ; if ( handle -> protocol != NULL && ! proto_is_protocol_enabled ( handle -> protocol ) )  saved_proto = pinfo -> current_proto; saved_can_desegment = pinfo -> can_desegment; if ( pinfo -> layer_names != NULL )  saved_layer_names_len = ( gint ) pinfo -> layer_names -> len; pinfo -> saved_can_desegment = saved_can_desegment; pinfo -> can_desegment = saved_can_desegment - ( saved_can_desegment > 0 ); if ( handle -> protocol != NULL )  pinfo -> current_proto = proto_get_protocol_short_name ( handle -> protocol ); if ( ( pinfo -> layer_names ) && ( add_proto_name ) )  if ( pinfo -> layer_names -> len > 0 )  g_string_append ( pinfo -> layer_names , ":" ); g_string_append ( pinfo -> layer_names , proto_get_protocol_filter_name ( proto_get_id ( handle -> protocol ) ) ); if ( pinfo -> flags . in_error_pkt )  ret = call_dissector_work_error ( handle , tvb , pinfo , tree ); static call_dissector_work_error(dissector_handle_t handle, tvbuff_t packet_info *pinfo_arg, proto_tree *tree) packet_info * pinfo = pinfo_arg ; saved_proto = pinfo -> current_proto; saved_can_desegment = pinfo -> can_desegment; save_writable = col_get_writable ( pinfo -> cinfo ); col_set_writable ( pinfo -> cinfo , FALSE ); save_dl_src = pinfo -> dl_src; save_dl_dst = pinfo -> dl_dst; save_net_src = pinfo -> net_src; save_net_dst = pinfo -> net_dst; save_src = pinfo -> src; save_dst = pinfo -> dst; ret = call_dissector_through_handle ( handle , tvb , pinfo , tree ); static call_dissector_through_handle(dissector_handle_t handle, tvbuff_t packet_info *pinfo, proto_tree *tree) saved_proto = pinfo -> current_proto; if ( handle -> protocol != NULL )  pinfo -> current_proto = proto_get_protocol_short_name ( handle -> protocol ); if ( handle -> is_new )  EP_CHECK_CANARY ( ( "before calling handle->dissector.new for %s" , handle -> name ) ); ret = ( * handle -> dissector . new ) tvb , pinfo , tree EP_CHECK_CANARY ( ( "after calling handle->dissector.new for %s" , handle -> name ) ); EP_CHECK_CANARY ( ( "before calling handle->dissector.old for %s" , handle -> name ) ); ( * handle -> dissector . old ) ( tvb , pinfo , tree ); EP_CHECK_CANARY ( ( "after calling handle->dissector.old for %s" , handle -> name ) ); ret = tvb_length ( tvb ); if ( ret == 0 )  pinfo -> current_proto = saved_proto; return ret ; col_set_writable ( pinfo -> cinfo , save_writable ); pinfo -> dl_src = save_dl_src; pinfo -> dl_dst = save_dl_dst; pinfo -> net_src = save_net_src; pinfo -> net_dst = save_net_dst; pinfo -> src = save_src; pinfo -> dst = save_dst; pinfo -> current_proto = saved_proto; pinfo -> can_desegment = saved_can_desegment; ret = tvb_length ( tvb ); col_set_writable ( pinfo -> cinfo , save_writable ); pinfo -> dl_src = save_dl_src; pinfo -> dl_dst = save_dl_dst; pinfo -> net_src = save_net_src; pinfo -> net_dst = save_net_dst; pinfo -> src = save_src; pinfo -> dst = save_dst; pinfo -> want_pdu_tracking = 0; return ret ; ret = call_dissector_through_handle ( handle , tvb , pinfo , tree ); static call_dissector_through_handle(dissector_handle_t handle, tvbuff_t packet_info *pinfo, proto_tree *tree) saved_proto = pinfo -> current_proto; if ( handle -> protocol != NULL )  pinfo -> current_proto = proto_get_protocol_short_name ( handle -> protocol ); if ( handle -> is_new )  EP_CHECK_CANARY ( ( "before calling handle->dissector.new for %s" , handle -> name ) ); ret = ( * handle -> dissector . new ) tvb , pinfo , tree EP_CHECK_CANARY ( ( "after calling handle->dissector.new for %s" , handle -> name ) ); EP_CHECK_CANARY ( ( "before calling handle->dissector.old for %s" , handle -> name ) ); ( * handle -> dissector . old ) ( tvb , pinfo , tree ); EP_CHECK_CANARY ( ( "after calling handle->dissector.old for %s" , handle -> name ) ); ret = tvb_length ( tvb ); if ( ret == 0 )  pinfo -> current_proto = saved_proto; return ret ; if ( ret == 0 )  if ( ( pinfo -> layer_names != NULL ) && ( add_proto_name ) )  g_string_truncate ( pinfo -> layer_names , saved_layer_names_len ); pinfo -> current_proto = saved_proto; pinfo -> can_desegment = saved_can_desegment; return ret ; return ret ; if ( ret == 0 )  call_dissector_work ( data_handle , tvb , pinfo , tree , TRUE ); static call_dissector_work(dissector_handle_t handle, tvbuff_t packet_info *pinfo_arg, proto_tree *tree, gboolean add_proto_name) packet_info * pinfo = pinfo_arg ; if ( handle -> protocol != NULL && ! proto_is_protocol_enabled ( handle -> protocol ) )  saved_proto = pinfo -> current_proto; saved_can_desegment = pinfo -> can_desegment; if ( pinfo -> layer_names != NULL )  saved_layer_names_len = ( gint ) pinfo -> layer_names -> len; pinfo -> saved_can_desegment = saved_can_desegment; pinfo -> can_desegment = saved_can_desegment - ( saved_can_desegment > 0 ); if ( handle -> protocol != NULL )  pinfo -> current_proto = proto_get_protocol_short_name ( handle -> protocol ); if ( ( pinfo -> layer_names ) && ( add_proto_name ) )  if ( pinfo -> layer_names -> len > 0 )  g_string_append ( pinfo -> layer_names , ":" ); g_string_append ( pinfo -> layer_names , proto_get_protocol_filter_name ( proto_get_id ( handle -> protocol ) ) ); if ( pinfo -> flags . in_error_pkt )  ret = call_dissector_work_error ( handle , tvb , pinfo , tree ); ret = call_dissector_through_handle ( handle , tvb , pinfo , tree ); if ( ret == 0 )  if ( ( pinfo -> layer_names != NULL ) && ( add_proto_name ) )  g_string_truncate ( pinfo -> layer_names , saved_layer_names_len ); pinfo -> current_proto = saved_proto; pinfo -> can_desegment = saved_can_desegment; return ret ; return tvb_length ( tvb ) ; return ret ; call_dissector ( gssapi_handle , ntlmssp_tvb , pinfo , tree );  call_dissector(dissector_handle_t handle, tvbuff_t packet_info *pinfo, proto_tree *tree) ret = call_dissector_only ( handle , tvb , pinfo , tree ); if ( ret == 0 )  call_dissector_work ( data_handle , tvb , pinfo , tree , TRUE ); return tvb_length ( tvb ) ; return ret ; 