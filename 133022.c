static void mmio_ide_write (void *opaque, target_phys_addr_t uint32_t val) MMIOState * s = ( MMIOState * ) opaque ; IDEState * ide = ( IDEState * ) s -> dev ; addr >>= s -> shift; if ( addr & 7 )  ide_ioport_write ( ide , addr , val ); static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val) IDEState * ide_if = opaque ; IDEState * s ; int unit , n ; addr &= 7; if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )  switch ( addr )  ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature; ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature; ide_if [ 0 ] . feature = val; ide_if [ 1 ] . feature = val; ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector; ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector; ide_if [ 0 ] . nsector = val; ide_if [ 1 ] . nsector = val; ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector; ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector; ide_if [ 0 ] . sector = val; ide_if [ 1 ] . sector = val; ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl; ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl; ide_if [ 0 ] . lcyl = val; ide_if [ 1 ] . lcyl = val; ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl; ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl; ide_if [ 0 ] . hcyl = val; ide_if [ 1 ] . hcyl = val; ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0; ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0; unit = ( val >> 4 ) & 1; s = ide_if + unit; ide_if -> cur_drive = s; s = ide_if -> cur_drive; if ( ! s -> bs )  if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )  switch ( val )  if ( s -> bs && ! s -> is_cdrom )  if ( ! s -> is_cf )  ide_cfata_identify ( s ); static void ide_cfata_identify(IDEState *s) uint16_t * p ; p = ( uint16_t * ) s -> identify_data; if ( s -> identify_set )  memset ( p , 0 , sizeof ( s -> identify_data ) ); put_le16 ( p + 0 , 0x848a ); put_le16 ( p + 1 , s -> cylinders ); put_le16 ( p + 3 , s -> heads ); put_le16 ( p + 6 , s -> sectors ); put_le16 ( p + 7 , s -> nb_sectors >> 16 ); put_le16 ( p + 8 , s -> nb_sectors ); padstr ( ( char * ) ( p + 10 ) , s -> drive_serial_str , 20 ); put_le16 ( p + 22 , 0x0004 ); padstr ( ( char * ) ( p + 23 ) , QEMU_VERSION , 8 ); padstr ( ( char * ) ( p + 27 ) , "QEMU MICRODRIVE" , 40 ); put_le16 ( p + 47 , 0x8000 | MAX_MULT_SECTORS ); put_le16 ( p + 49 , 0x0f00 ); put_le16 ( p + 51 , 0x0002 ); put_le16 ( p + 52 , 0x0001 ); put_le16 ( p + 53 , 0x0003 ); put_le16 ( p + 54 , s -> cylinders ); put_le16 ( p + 55 , s -> heads ); put_le16 ( p + 56 , s -> sectors ); put_le16 ( p + 57 , cur_sec ); put_le16 ( p + 58 , cur_sec >> 16 ); put_le16 ( p + 59 , 0x100 | s -> mult_sectors ); put_le16 ( p + 60 , s -> nb_sectors ); put_le16 ( p + 61 , s -> nb_sectors >> 16 ); put_le16 ( p + 63 , 0x0203 ); put_le16 ( p + 64 , 0x0001 ); put_le16 ( p + 65 , 0x0096 ); put_le16 ( p + 66 , 0x0096 ); put_le16 ( p + 68 , 0x00b4 ); put_le16 ( p + 82 , 0x400c ); put_le16 ( p + 83 , 0x7068 ); put_le16 ( p + 84 , 0x4000 ); put_le16 ( p + 85 , 0x000c ); put_le16 ( p + 86 , 0x7044 ); put_le16 ( p + 87 , 0x4000 ); put_le16 ( p + 91 , 0x4060 ); put_le16 ( p + 129 , 0x0002 ); put_le16 ( p + 130 , 0x0005 ); put_le16 ( p + 131 , 0x0001 ); put_le16 ( p + 132 , 0x0000 ); put_le16 ( p + 160 , 0x8100 ); put_le16 ( p + 161 , 0x8001 ); memcpy ( s -> io_buffer , p , sizeof ( s -> identify_data ) ); 