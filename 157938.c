static void mem_add(MemoryListener *listener, MemoryRegionSection *section) AddressSpace * as = container_of ( listener , AddressSpace , dispatch_listener ) ; AddressSpaceDispatch * d = as -> next_dispatch ; MemoryRegionSection now = * section , remain = * section ; Int128 page_size = int128_make64 ( TARGET_PAGE_SIZE ) ; if ( now . offset_within_address_space & ~TARGET_PAGE_MASK )  uint64_t left = TARGET_PAGE_ALIGN ( now . offset_within_address_space ) - now . offset_within_address_space ; now . size = int128_min ( int128_make64 ( left ) , now . size ); now . size = int128_zero ( ); while ( int128_ne ( remain . size , now . size ) )  remain . size = int128_sub ( remain . size , now . size ); remain . offset_within_address_space += int128_get64 ( now . size ); remain . offset_within_region += int128_get64 ( now . size ); now = remain; if ( int128_lt ( remain . size , page_size ) )  if ( remain . offset_within_region & ~TARGET_PAGE_MASK )  now . size = page_size; register_subpage ( d , & now ); now . size = int128_and ( now . size , int128_neg ( page_size ) ); static void register_subpage(AddressSpaceDispatch *d, MemoryRegionSection *section) hwaddr base = section -> offset_within_address_space & TARGET_PAGE_MASK ; MemoryRegionSection * existing = phys_page_find ( d -> phys_map , base >> TARGET_PAGE_BITS , next_map . nodes , next_map . sections ) ; static MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr Node *nodes, MemoryRegionSection *sections) PhysPageEntry * p ; int i ; for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--) if ( lp . ptr == PHYS_MAP_NODE_NIL )  return & sections [ PHYS_SECTION_UNASSIGNED ] ; p = nodes [ lp . ptr ]; lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ]; return & sections [ lp . ptr ] ; assert ( existing -> mr -> subpage || existing -> mr == & io_mem_unassigned ); 