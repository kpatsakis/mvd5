struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub struct device bool p2pdev_forced) struct net_device * ndev = brcmf_get_ifp ( drvr , 0 ) -> ndev ; struct brcmf_cfg80211_info * cfg ; struct wiphy * wiphy ; struct cfg80211_ops * ops ; struct brcmf_cfg80211_vif * vif ; struct brcmf_if * ifp ; if ( ! ndev )  ops = kzalloc ( sizeof ( * ops ) , GFP_KERNEL ); if ( ! ops )  memcpy ( ops , & brcmf_cfg80211_ops , sizeof ( * ops ) ); ifp = netdev_priv ( ndev ); if ( brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_WOWL_GTK ) )  ops -> set_rekey_data = brcmf_cfg80211_set_rekey_data; wiphy = wiphy_new ( ops , sizeof ( struct brcmf_cfg80211_info ) ); if ( ! wiphy )  memcpy ( wiphy -> perm_addr , drvr -> mac , ETH_ALEN ); cfg = wiphy_priv ( wiphy ); cfg -> wiphy = wiphy; cfg -> ops = ops; cfg -> pub = drvr; vif = brcmf_alloc_vif ( cfg , NL80211_IFTYPE_STATION , false ); struct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info enum nl80211_iftype bool pm_block) struct brcmf_cfg80211_vif * vif ; bool mbss ; vif = kzalloc ( sizeof ( * vif ) , GFP_KERNEL ); if ( ! vif )  return ERR_PTR ( - ENOMEM ) ; vif -> wdev . wiphy = cfg -> wiphy; vif -> wdev . iftype = type; vif -> pm_block = pm_block; if ( type == NL80211_IFTYPE_AP )  mbss = false; vif -> mbss = mbss; return vif ; if ( IS_ERR ( vif ) )  vif -> ifp = ifp; vif -> wdev . netdev = ndev; err = wl_init_priv ( cfg ); static s32 wl_init_priv(struct brcmf_cfg80211_info *cfg) cfg -> scan_request = NULL; cfg -> pwr_save = true; cfg -> active_scan = true; cfg -> dongle_up = false; err = brcmf_init_priv_mem ( cfg ); static s32 brcmf_init_priv_mem(struct brcmf_cfg80211_info *cfg) cfg -> conf = kzalloc ( sizeof ( * cfg -> conf ) , GFP_KERNEL ); if ( ! cfg -> conf )  cfg -> extra_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL ); if ( ! cfg -> extra_buf )  cfg -> wowl . nd = kzalloc ( sizeof ( * cfg -> wowl . nd ) + sizeof ( u32 ) , GFP_KERNEL ); if ( ! cfg -> wowl . nd )  cfg -> wowl . nd_info = kzalloc ( sizeof ( * cfg -> wowl . nd_info ) + sizeof ( struct cfg80211_wowlan_nd_match * ) , GFP_KERNEL ); if ( ! cfg -> wowl . nd_info )  cfg -> escan_info . escan_buf = kzalloc ( BRCMF_ESCAN_BUF_SIZE , GFP_KERNEL ); if ( ! cfg -> escan_info . escan_buf )  return 0 ; return - ENOMEM ; if ( err )  return err ; return err ; if ( err )  ifp -> vif = vif; err = brcmf_fil_cmd_int_get ( ifp , BRCMF_C_GET_VERSION , & io_type ); if ( err )  err = brcmf_setup_wiphy ( wiphy , ifp ); static int brcmf_setup_wiphy(struct wiphy *wiphy, struct brcmf_if *ifp) struct brcmf_pub * drvr = ifp -> drvr ; const struct ieee80211_iface_combination * combo ; u16 max_interfaces = 0 ; int err , i ; wiphy -> max_scan_ssids = WL_NUM_SCAN_MAX; wiphy -> max_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX; wiphy -> max_num_pmkids = BRCMF_MAXPMKID; err = brcmf_setup_ifmodes ( wiphy , ifp ); static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp) struct ieee80211_iface_combination * combo = NULL ; struct ieee80211_iface_limit * c0_limits = NULL ; struct ieee80211_iface_limit * p2p_limits = NULL ; struct ieee80211_iface_limit * mbss_limits = NULL ; bool mbss , p2p ; int i , c , n_combos ; mbss = brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_MBSS ); p2p = brcmf_feat_is_enabled ( ifp , BRCMF_FEAT_P2P ); n_combos = 1 + ! ! p2p + ! ! mbss; combo = kcalloc ( n_combos , sizeof ( * combo ) , GFP_KERNEL ); if ( ! combo )  c0_limits = kcalloc ( p2p ? 3 : 2 , sizeof ( * c0_limits ) , GFP_KERNEL ); if ( ! c0_limits )  if ( p2p )  p2p_limits = kcalloc ( 4 , sizeof ( * p2p_limits ) , GFP_KERNEL ); if ( ! p2p_limits )  if ( mbss )  mbss_limits = kcalloc ( 1 , sizeof ( * mbss_limits ) , GFP_KERNEL ); if ( ! mbss_limits )  return 0 ; return - ENOMEM ; if ( err )  if ( i < wiphy -> n_iface_combinations )  i ++ , combo ++ max_interfaces = max ( max_interfaces , combo -> max_interfaces ); for (i = 0; i < max_interfaces && i < i++) u8 * addr = drvr -> addresses [ i ] . addr ; memcpy ( addr , drvr -> mac , ETH_ALEN ); addr [ 0 ] |= BIT ( 1 ); addr [ ETH_ALEN - 1 ] ^= i; 