 nestegg_read_packet(nestegg * ctx, nestegg_packet ** pkt) uint64_t id , size ; * pkt = NULL; r = ne_peek_element ( ctx , & id , & size ); if ( r != 1 )  if ( ne_is_suspend_element ( id ) )  r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  r = ne_read_block ( ctx , id , size , pkt ); if ( r != 1 )  if ( id != ID_SIMPLE_BLOCK )  r = ne_read_block_duration ( ctx , * pkt ); if ( r < 0 )  r = ne_read_discard_padding ( ctx , * pkt ); if ( r < 0 )  r = ne_read_block_additions ( ctx , * pkt ); r = ne_parse ( ctx , NULL , - 1 ); if ( r != 1 )  static ne_read_block_additions(nestegg * ctx, nestegg_packet * pkt) int r ; uint64_t id , size , data_size ; int64_t block_additions_end , block_more_end ; void * data ; int has_data ; uint64_t add_id ; r = ne_peek_element ( ctx , & id , & size ); if ( r != 1 )  if ( id != ID_BLOCK_ADDITIONS )  ctx -> last_valid = 0; block_additions_end = ne_io_tell ( ctx -> io ) + size; while ( ne_io_tell ( ctx -> io ) < block_additions_end )  add_id = 1; data = NULL; has_data = 0; r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  if ( id != ID_BLOCK_MORE )  block_more_end = ne_io_tell ( ctx -> io ) + size; while ( ne_io_tell ( ctx -> io ) < block_more_end )  r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  if ( id == ID_BLOCK_ADD_ID )  r = ne_read_uint ( ctx -> io , & add_id , size ); if ( r != 1 )  if ( add_id == 0 )  if ( id == ID_BLOCK_ADDITIONAL )  if ( has_data )  has_data = 1; if ( size != 0 )  data = ne_alloc ( size ); r = ne_io_read ( ctx -> io , data , size ); if ( r != 1 )  if ( has_data == 0 )  static void ne_alloc(size_t size) return calloc ( 1 , size ) ; 