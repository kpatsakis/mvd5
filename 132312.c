static struct dentry ffs_fs_mount(struct file_system_type *t, int const char *dev_name, void *opts) struct ffs_sb_fill_data data . perms . mode = S_IFREG | 0600 . uid = GLOBAL_ROOT_UID . gid = GLOBAL_ROOT_GID  . root_mode = S_IFDIR | 0500 . no_disconnect = false , int ret ; ret = ffs_fs_parse_opts ( & data , opts ); static int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts) if ( ! opts || ! * opts )  unsigned long value ; char * eq , * comma ; comma = strchr ( opts , ',' ); if ( comma )  * comma = 0; eq = strchr ( opts , '=' ); if ( unlikely ( ! eq ) )  pr_err ( "'=' missing in %s\n" , opts ); * eq = 0; if ( kstrtoul ( eq + 1 , 0 , & value ) )  pr_err ( "%s: invalid value: %s\n" , opts , eq + 1 ); switch ( eq - opts )  if ( ! memcmp ( opts , "no_disconnect" , 13 ) )  data -> no_disconnect = ! ! value; if ( ! memcmp ( opts , "rmode" , 5 ) )  data -> root_mode = ( value & 0555 ) | S_IFDIR; if ( ! memcmp ( opts , "fmode" , 5 ) )  data -> perms . mode = ( value & 0666 ) | S_IFREG; if ( ! memcmp ( opts , "mode" , 4 ) )  data -> root_mode = ( value & 0555 ) | S_IFDIR; data -> perms . mode = ( value & 0666 ) | S_IFREG; if ( ! memcmp ( opts , "uid" , 3 ) )  data -> perms . uid = make_kuid ( current_user_ns ( ) , value ); if ( ! uid_valid ( data -> perms . uid ) )  pr_err ( "%s: unmapped value: %lu\n" , opts , value ); if ( ! memcmp ( opts , "gid" , 3 ) )  data -> perms . gid = make_kgid ( current_user_ns ( ) , value ); if ( ! gid_valid ( data -> perms . gid ) )  pr_err ( "%s: unmapped value: %lu\n" , opts , value ); pr_err ( "%s: invalid option\n" , opts ); if ( ! comma )  opts = comma + 1; 