 CClosure::Create(JSContext* HandleObject HandleObject HandleObject jsval PRFuncPtr* fnptr) RootedValue errVal ( cx , errVal_ ) ; RootedObject result ( cx , JS_NewObject ( cx , & sCClosureClass ) ) ; if ( ! result )  FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ; RootedObject proto ( cx ) ; if ( ! JS_GetPrototype ( cx , typeObj , & proto ) )  mozilla :: UniquePtr < uint8_t [ ] , JS :: FreePolicy > errResult ; if ( ! errVal . isUndefined ( ) )  if ( CType :: GetTypeCode ( fninfo -> mReturnType ) == TYPE_void_t )  size_t rvSize = CType :: GetSize ( fninfo -> mReturnType ) ; errResult = result -> zone ( ) -> make_pod_array < uint8_t > ( rvSize ); if ( ! errResult )  if ( ! ImplicitConvert ( cx , errVal , fninfo -> mReturnType , errResult . get ( ) , false , nullptr ) )  static ImplicitConvert(JSContext* HandleValue JSObject* void* bool bool* freePointer) RootedObject targetType ( cx , targetType_ ) ; JSObject * sourceData = nullptr ; JSObject * sourceType = nullptr ; RootedObject valObj ( cx , nullptr ) ; if ( val . isObject ( ) )  valObj = & val . toObject ( ); if ( CData :: IsCData ( valObj ) )  sourceData = valObj; sourceType = CData :: GetCType ( sourceData ); if ( CType :: TypesEqual ( sourceType , targetType ) )  if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  sourceData = valObj; sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; if ( ! p )  if ( CType :: TypesEqual ( sourceType , targetType ) )  TypeCode targetCode = CType :: GetTypeCode ( targetType ) ; switch ( targetCode )  bool result ; if ( ! jsvalToBool ( cx , val , & result ) )  static jsvalToBool(JSContext* cx, jsval val, bool* result) if ( val . isBoolean ( ) )  return true ; if ( val . isInt32 ( ) )  int32_t i = val . toInt32 ( ) ; return i == 0 || i == 1 ; if ( val . isDouble ( ) )  double d = val . toDouble ( ) ; return d == 1 || d == 0 ; return false ; * static_cast < bool * > ( buffer ) = result type result ; type result ; type result ; if ( ! jsvalToFloat ( cx , val , & result ) )  template<class static jsvalToFloat(JSContext* cx, jsval val, FloatType* result) if ( val . isInt32 ( ) )  return true ; if ( val . isDouble ( ) )  return true ; if ( val . isObject ( ) )  JSObject * obj = & val . toObject ( ) ; if ( CData :: IsCData ( obj ) )   CData::IsCData(JSObject* obj) return JS_GetClass ( obj ) == & sCDataClass ; JSObject * typeObj = CData :: GetCType ( obj ) ;  CData::GetCType(JSObject* dataObj) jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ; JSObject * typeObj = slot . toObjectOrNull ( ) ; return typeObj ; switch ( CType :: GetTypeCode ( typeObj ) )   CType::GetTypeCode(JSObject* typeObj) jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ; return TypeCode ( result . toInt32 ( ) ) ; return false ; return false ; return false ; * static_cast < type * > ( buffer ) = result if ( val . isNull ( ) )  * static_cast < void * * > ( buffer ) = nullptr JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ; if ( sourceData )  TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;  CType::GetTypeCode(JSObject* typeObj) jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ; return TypeCode ( result . toInt32 ( ) ) ; bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;  CType::GetTypeCode(JSObject* typeObj) jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ; return TypeCode ( result . toInt32 ( ) ) ; if ( sourceCode == TYPE_pointer && voidptrTarget )  if ( sourceCode == TYPE_array )  JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;  ArrayType::GetBaseType(JSObject* obj) jsval type = JS_GetReservedSlot ( obj , SLOT_ELEMENT_T ) ; return & type . toObject ( ) ; if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )   CType::TypesEqual(JSObject* t1, JSObject* t2) if ( t1 == t2 )  return true ; TypeCode c1 = GetTypeCode ( t1 ) ; TypeCode c2 = GetTypeCode ( t2 ) ; if ( c1 != c2 )  return false ; switch ( c1 )  JSObject * b1 = PointerType :: GetBaseType ( t1 ) ; JSObject * b2 = PointerType :: GetBaseType ( t2 ) ; return TypesEqual ( b1 , b2 ) ; FunctionInfo * f1 = FunctionType :: GetFunctionInfo ( t1 ) ; FunctionInfo * f2 = FunctionType :: GetFunctionInfo ( t2 ) ; if ( f1 -> mABI != f2 -> mABI )  return false ; if ( ! TypesEqual ( f1 -> mReturnType , f2 -> mReturnType ) )  return false ; if ( f1 -> mArgTypes . length ( ) != f2 -> mArgTypes . length ( ) )  return false ; if ( f1 -> mIsVariadic != f2 -> mIsVariadic )  return false ; for (size_t i = 0; i < f1->mArgTypes.length(); ++i) if ( ! TypesEqual ( f1 -> mArgTypes [ i ] , f2 -> mArgTypes [ i ] ) )  return false ; return true ; size_t s1 = 0 , s2 = 0 ; bool d1 = ArrayType :: GetSafeLength ( t1 , & s1 ) ; bool d2 = ArrayType :: GetSafeLength ( t2 , & s2 ) ; if ( d1 != d2 || ( d1 && s1 != s2 ) )  return false ; JSObject * b1 = ArrayType :: GetBaseType ( t1 ) ; JSObject * b2 = ArrayType :: GetBaseType ( t2 ) ; return TypesEqual ( b1 , b2 ) ; return false ; return true ; * static_cast < void * * > ( buffer ) = sourceBuffer if ( isArgument && val . isString ( ) )  if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )  if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )  if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )  bool CanConvertTypedArrayItemTo(JSObject* baseType, JSObject* valObj, JSContext* cx) TypeCode baseTypeCode = CType :: GetTypeCode ( baseType ) ; if ( baseTypeCode == TYPE_void_t || baseTypeCode == TYPE_char )  return true ; TypeCode elementTypeCode ; switch ( JS_GetArrayBufferViewType ( valObj ) )  elementTypeCode = TYPE_int8_t; elementTypeCode = TYPE_uint8_t; elementTypeCode = TYPE_int16_t; elementTypeCode = TYPE_uint16_t; elementTypeCode = TYPE_int32_t; elementTypeCode = TYPE_uint32_t; elementTypeCode = TYPE_float32_t; elementTypeCode = TYPE_float64_t; return false ; return elementTypeCode == baseTypeCode ; if ( ! isArgument )  void * ptr ; JS :: AutoCheckCannotGC nogc ; ptr = JS_GetArrayBufferViewData ( valObj , nogc ); if ( ! ptr )  * static_cast < void * * > ( buffer ) = ptr RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ; size_t targetLength = ArrayType :: GetLength ( targetType ) ; if ( val . isString ( ) )  JSString * sourceString = val . toString ( ) ; JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ; if ( ! sourceLinear )  switch ( CType :: GetTypeCode ( baseType ) )   CType::GetTypeCode(JSObject* typeObj) jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ; return TypeCode ( result . toInt32 ( ) ) ; size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ; template <typename  GetDeflatedUTF8StringLength(JSContext* maybecx, const CharT* size_t nchars) size_t nbytes ; const CharT * end ; unsigned c , c2 ; nbytes = nchars; for (end = chars + nchars; chars != end; chars++) c = * chars; if ( c < 0x80 )  if ( 0xD800 <= c && c <= 0xDFFF )  chars ++; nbytes --; if ( c >= 0xDC00 || chars == end )  c2 = * chars; if ( c2 < 0xDC00 || c2 > 0xDFFF )  c = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000; c >>= 11; nbytes ++; while ( c )  c >>= 5; nbytes ++; return nbytes ; return ( size_t ) - 1 ; if ( nbytes == ( size_t ) - 1 )  if ( targetLength < nbytes )  char * charBuffer = static_cast < char * > buffer if ( val . isObject ( ) && ! sourceData )  AutoIdArray props ( cx , JS_Enumerate ( cx , valObj ) ) ; if ( ! props )  auto intermediate = cx -> make_pod_array < char > ( structSize ) if ( ! intermediate )  const FieldInfoHash * fields = StructType :: GetFieldInfo ( targetType ) ; if ( props . length ( ) != fields -> count ( ) )  RootedId id ( cx ) ; for (size_t i = 0; i < props.length(); ++i) id = props [ i ]; if ( ! JSID_IS_STRING ( id ) )  JSFlatString * name = JSID_TO_FLAT_STRING ( id ) ; const FieldInfo * field = StructType :: LookupField ( cx , targetType , name ) ; const StructType::LookupField(JSContext* cx, JSObject* obj, JSFlatString* name) FieldInfoHash :: Ptr ptr = GetFieldInfo ( obj ) -> lookup ( name ) ; if ( ptr )  return & ptr -> value ( ) ; JSAutoByteString bytes ( cx , name ) ; if ( ! bytes )  return nullptr ; return nullptr ; if ( ! field )  RootedValue prop ( cx ) ; if ( ! JS_GetPropertyById ( cx , valObj , id , & prop ) )  char * fieldData = intermediate . get ( ) + field -> mOffset ; if ( ! ImplicitConvert ( cx , prop , field -> mType , fieldData , false , nullptr ) )  static ImplicitConvert(JSContext* HandleValue JSObject* void* bool bool* freePointer) RootedObject targetType ( cx , targetType_ ) ; RootedObject valObj ( cx , nullptr ) ; if ( val . isObject ( ) )  valObj = & val . toObject ( ); if ( CData :: IsCData ( valObj ) )  sourceData = valObj; sourceType = CData :: GetCType ( sourceData ); if ( CType :: TypesEqual ( sourceType , targetType ) )  if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  sourceData = valObj; sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; if ( ! p )  if ( CType :: TypesEqual ( sourceType , targetType ) )  TypeCode targetCode = CType :: GetTypeCode ( targetType ) ; switch ( targetCode )  if ( val . isNull ( ) )  JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ; RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ; size_t targetLength = ArrayType :: GetLength ( targetType ) ; if ( val . isString ( ) )  if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )  if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )  if ( val . isObject ( ) && JS_IsTypedArrayObject ( valObj ) )  if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )  uint32_t sourceLength = JS_GetTypedArrayByteLength ( valObj ) ; size_t elementSize = CType :: GetSize ( baseType ) ; size_t arraySize = elementSize * targetLength ; if ( arraySize != size_t ( sourceLength ) )  JS :: AutoCheckCannotGC nogc ; memcpy ( buffer , JS_GetArrayBufferViewData ( valObj , nogc ) , sourceLength ); 