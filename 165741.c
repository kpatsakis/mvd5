static unsigned int __user *signal_frame_32_regs(unsigned int unsigned int next_sp, unsigned int next_ip) if ( next_sp - sp >= sizeof ( struct signal_frame_32 ) && is_sigreturn_32_address ( next_ip , sp ) && sane_signal_32_frame ( sp ) )  static int sane_signal_32_frame(unsigned int sp) struct signal_frame_32 __user * sf ; unsigned int regs ; sf = ( struct signal_frame_32 __user * ) ( unsigned long ) sp; if ( read_user_stack_32 ( ( unsigned int __user * ) & sf -> sctx . regs , & regs ) )  static int read_user_stack_32(unsigned int __user *ptr, unsigned int *ret) if ( ( unsigned long ) ptr > TASK_SIZE - sizeof ( unsigned int ) || ( ( unsigned long ) ptr & 3 ) )  if ( ! __get_user_inatomic ( * ret , ptr ) )  return read_user_stack_slow ( ptr , ret , 4 ) ; static int read_user_stack_slow(void __user *ptr, void *ret, int nb) pgd_t * pgdir ; pte_t * ptep , pte ; unsigned shift ; unsigned long addr = ( unsigned long ) ptr ; unsigned long offset ; unsigned long pfn ; void * kaddr ; pgdir = current -> mm -> pgd; if ( ! pgdir )  ptep = find_linux_pte_or_hugepte ( pgdir , addr , & shift ); if ( ! shift )  shift = PAGE_SHIFT; offset = addr & ( ( 1UL << shift ) - 1 ); if ( ptep == NULL )  pte = * ptep; if ( ! pte_present ( pte ) || ! ( pte_val ( pte ) & _PAGE_USER ) )  pfn = pte_pfn ( pte ); if ( ! page_is_ram ( pfn ) )  kaddr = pfn_to_kaddr ( pfn ); memcpy ( ret , kaddr + offset , nb ); 