HTAB *hash_create(const char *tabname,long nelem,HASHCTL *info,int flags) HTAB * hashp ; if ( flags & 0x040 )  CurrentDynaHashCxt = TopMemoryContext; if ( flags & 0x200 )  CurrentDynaHashCxt = info -> hcxt; CurrentDynaHashCxt = TopMemoryContext; CurrentDynaHashCxt = AllocSetContextCreate ( CurrentDynaHashCxt , tabname , 0 , ( 8 * 1024 ) , ( 8 * 1024 * 1024 ) ); hashp = ( ( HTAB * ) ( DynaHashAlloc ( sizeof ( HTAB ) + strlen ( tabname ) + 1 ) ) ); static void *DynaHashAlloc(Size size) return MemoryContextAlloc ( CurrentDynaHashCxt , size ) ; hashp -> tabname = ( ( char * ) ( hashp + 1 ) ); strcpy ( hashp -> tabname , tabname ); if ( flags & 0x010 )  hashp -> hash = info -> hash; hashp -> hash = string_hash; if ( flags & 0x400 )  hashp -> match = info -> match; if ( hashp -> hash == string_hash )  hashp -> match = ( ( HashCompareFunc ) string_compare ); hashp -> match = memcmp; if ( flags & 0x800 )  if ( hashp -> hash == string_hash )  hashp -> keycopy = memcpy; if ( flags & 0x100 )  hashp -> alloc = info -> alloc; hashp -> alloc = DynaHashAlloc; if ( flags & 0x040 )  hashp -> hctl = info -> hctl; hashp -> dir = ( ( HASHSEGMENT * ) ( ( ( char * ) ( info -> hctl ) ) + sizeof ( HASHHDR ) ) ); hashp -> hcxt = ( ( void * ) 0 ); hashp -> isshared = ( ( bool ) 1 ); if ( flags & 0x080 )  hashp -> hctl = ( ( void * ) 0 ); hashp -> dir = ( ( void * ) 0 ); hashp -> hcxt = CurrentDynaHashCxt; hashp -> isshared = ( ( bool ) 0 ); if ( ! hashp -> hctl )  hashp -> hctl = ( ( HASHHDR * ) ( ( hashp -> alloc ) ( sizeof ( HASHHDR ) ) ) ); hashp -> frozen = ( ( bool ) 0 ); hdefault ( hashp ); static void hdefault(HTAB *hashp) HASHHDR * hctl = hashp -> hctl ; void * _vstart = ( void * ) hctl ; int _val = 0 ; Size _len = sizeof ( HASHHDR ) ; if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  memset ( _vstart , _val , _len ); while ( 0 )  