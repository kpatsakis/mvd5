static void tcp_chr_read(void *opaque) CharDriverState * chr = opaque ; TCPCharDriver * s = chr -> opaque ; uint8_t buf [ 1024 ] ; int len , size ; if ( ! s -> connected || s -> max_size <= 0 )  len = sizeof ( buf ); if ( len > s -> max_size )  len = s -> max_size; size = tcp_chr_recv ( chr , ( void * ) buf , len ); static ssize_t tcp_chr_recv(CharDriverState *chr, char *buf, size_t len) TCPCharDriver * s = chr -> opaque ; struct msghdr msg = NULL , struct iovec iov [ 1 ] ; union { struct cmsghdr cmsg ; char control [ CMSG_SPACE ( sizeof ( int ) ) ] ; } msg_control ; ssize_t ret ; iov [ 0 ] . iov_base = buf; iov [ 0 ] . iov_len = len; msg . msg_iov = iov; msg . msg_iovlen = 1; msg . msg_control = & msg_control; msg . msg_controllen = sizeof ( msg_control ); ret = recvmsg ( s -> fd , & msg , 0 ); return ret ; if ( size == 0 )  s -> connected = 0; s -> fd = - 1; if ( size > 0 )  if ( s -> msgfd != - 1 )  close ( s -> msgfd ); 