CharDriverState *qemu_chr_open(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) const char * p ; CharDriverState * chr ; if ( ! strcmp ( filename , "vc" ) )  if ( strstart ( filename , "vc:" , & p ) )  if ( ! strcmp ( filename , "null" ) )  if ( strstart ( filename , "tcp:" , & p ) )  if ( strstart ( filename , "telnet:" , & p ) )  if ( strstart ( filename , "udp:" , & p ) )  if ( strstart ( filename , "mon:" , & p ) )  chr = qemu_chr_open ( label , p , NULL ); CharDriverState *qemu_chr_open(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) const char * p ; CharDriverState * chr ; if ( ! strcmp ( filename , "vc" ) )  if ( strstart ( filename , "vc:" , & p ) )  if ( ! strcmp ( filename , "null" ) )  if ( strstart ( filename , "tcp:" , & p ) )  if ( strstart ( filename , "telnet:" , & p ) )  if ( strstart ( filename , "udp:" , & p ) )  if ( strstart ( filename , "mon:" , & p ) )  chr = qemu_chr_open ( label , p , NULL ); CharDriverState *qemu_chr_open(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) const char * p ; CharDriverState * chr ; if ( ! strcmp ( filename , "vc" ) )  if ( strstart ( filename , "vc:" , & p ) )  if ( ! strcmp ( filename , "null" ) )  if ( strstart ( filename , "tcp:" , & p ) )  if ( strstart ( filename , "telnet:" , & p ) )  if ( strstart ( filename , "udp:" , & p ) )  if ( strstart ( filename , "mon:" , & p ) )  if ( ! strcmp ( filename , "msmouse" ) )  if ( strstart ( filename , "unix:" , & p ) )  chr = qemu_chr_open_tcp ( p , 0 , 1 ); static CharDriverState *qemu_chr_open_tcp(const char int int is_unix) int is_listen = 0 ; const char * ptr ; ptr = host_str; while ( ptr = strchr ( ptr , ',' ) )  ptr ++; if ( ! strncmp ( ptr , "server" , 6 ) )  is_listen = 1; if ( ! strncmp ( ptr , "nowait" , 6 ) )  if ( ! strncmp ( ptr , "nodelay" , 6 ) )  if ( ! strncmp ( ptr , "to=" , 3 ) )  if ( ! strncmp ( ptr , "ipv4" , 4 ) )  if ( ! strncmp ( ptr , "ipv6" , 4 ) )  chr = qemu_mallocz ( sizeof ( CharDriverState ) ); if ( is_listen )  chr -> filename = qemu_malloc ( 256 ); offset = strlen ( chr -> filename ); fd = unix_listen ( host_str , chr -> filename + offset , 256 - offset ); fd = inet_listen ( host_str , chr -> filename + offset , 256 - offset , SOCK_STREAM , 0 ); if ( fd < 0 )  socket_set_nonblock ( fd ); s -> listen_fd = fd; qemu_set_fd_handler ( s -> listen_fd , tcp_chr_accept , NULL , chr ); s -> do_telnetopt = 1; s -> fd = fd; socket_set_nodelay ( fd ); socket_set_nonblock ( s -> listen_fd ); if ( fd >= 0 )  closesocket ( fd ); 