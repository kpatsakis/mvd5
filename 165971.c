static uint16_t md_common_read(void *opaque, uint32_t at) struct md_s * s = ( struct md_s * ) opaque ; at -= s -> io_base; switch ( s -> opt & OPT_MODE )  if ( ( at & ~0x3ff ) == 0x400 )  at = 0; at &= 0xf; if ( ( at & ~0xf ) == 0x3f0 )  at -= 0x3e8; if ( ( at & ~0xf ) == 0x1f0 )  at -= 0x1f0; if ( ( at & ~0xf ) == 0x370 )  at -= 0x368; if ( ( at & ~0xf ) == 0x170 )  at -= 0x170; switch ( at )  return ide_data_readw ( s -> ide , 0 ) ; static uint32_t ide_data_readw(void *opaque, uint32_t addr) IDEState * s = ( ( IDEState * ) opaque ) -> cur_drive ; if ( ! ( s -> status & DRQ_STAT ) )  buffered_pio_read ( s , addr , 2 ); static inline buffered_pio_read(IDEState *s, uint32_t addr, int size) struct pio_buffer * piobuf = piobuf_by_addr ( addr ) ; static inline struct pio_buffer piobuf_by_addr(uint32_t addr) if ( addr == 0x1F0 )  return & buffered_pio_page -> pio [ PIO_BUFFER_IDE_PRIMARY ] ; if ( addr == 0x170 )  return & buffered_pio_page -> pio [ PIO_BUFFER_IDE_SECONDARY ] ; return NULL ; int data_end ; if ( ! piobuf )  s -> data_ptr += piobuf -> pointer; data_end = s -> data_end - s -> data_ptr - size; if ( data_end <= 0 )  uint8_t * buf = ( uint8_t * ) buffered_pio_page + piobuf -> page_offset ; if ( data_end > piobuf -> buf_size )  data_end = piobuf -> buf_size; memcpy ( buf , s -> data_ptr + size , data_end ); 