unsigned int arpt_do_table(struct sk_buff const struct nf_hook_state struct xt_table *table) unsigned int hook = state -> hook ; const struct arphdr * arp ; struct arpt_entry * e , * * jumpstack ; const char * indev , * outdev ; const void * table_base ; unsigned int cpu , stackidx = 0 ; const struct xt_table_info * private ; struct xt_action_param acpar ; if ( ! pskb_may_pull ( skb , arp_hdr_len ( skb -> dev ) ) )  indev = state -> in ? state -> in -> name : nulldevname; outdev = state -> out ? state -> out -> name : nulldevname; private = table -> private; cpu = smp_processor_id ( ); table_base = private -> entries; jumpstack = ( struct arpt_entry * * ) private -> jumpstack [ cpu ]; e = get_entry ( table_base , private -> hook_entry [ hook ] ); static inline struct arpt_entry get_entry(const void *base, unsigned int offset) return ( struct arpt_entry * ) ( base + offset ) ; acpar . net = state -> net; acpar . in = state -> in; acpar . out = state -> out; acpar . hooknum = hook; acpar . family = NFPROTO_ARP; acpar . hotdrop = false; arp = arp_hdr ( skb ); const struct xt_entry_target * t ; if ( ! arp_packet_match ( arp , skb -> dev , indev , outdev , & e -> arp ) )  e = arpt_next_entry ( e ); static struct arpt_entry *arpt_next_entry(const struct arpt_entry *entry) return ( void * ) entry + entry -> next_offset ; t = arpt_get_target_c ( e ); static inline const struct xt_entry_target arpt_get_target_c(const struct arpt_entry *e) return arpt_get_target ( ( struct arpt_entry * ) e ) ; if ( ! t -> u . kernel . target -> target )  int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict; if ( v < 0 )  if ( v != XT_RETURN )  if ( stackidx == 0 )  e = get_entry ( table_base , private -> underflow [ hook ] ); static inline struct arpt_entry get_entry(const void *base, unsigned int offset) return ( struct arpt_entry * ) ( base + offset ) ; e = jumpstack [ -- stackidx ]; e = arpt_next_entry ( e ); static struct arpt_entry *arpt_next_entry(const struct arpt_entry *entry) return ( void * ) entry + entry -> next_offset ; if ( table_base + v != arpt_next_entry ( e ) )  static struct arpt_entry *arpt_next_entry(const struct arpt_entry *entry) return ( void * ) entry + entry -> next_offset ; jumpstack [ stackidx ++ ] = e; e = get_entry ( table_base , v ); static inline struct arpt_entry get_entry(const void *base, unsigned int offset) return ( struct arpt_entry * ) ( base + offset ) ; acpar . target = t -> u . kernel . target; acpar . targinfo = t -> data; verdict = t -> u . kernel . target -> target ( skb , & acpar ); arp = arp_hdr ( skb ); if ( verdict == XT_CONTINUE )  e = arpt_next_entry ( e ); static struct arpt_entry *arpt_next_entry(const struct arpt_entry *entry) return ( void * ) entry + entry -> next_offset ; while ( ! acpar . hotdrop )  static inline int arp_packet_match(const struct arphdr struct net_device const char const char const struct arpt_arp *arpinfo) const char * arpptr = ( char * ) ( arphdr + 1 ) ; __be32 src_ipaddr , tgt_ipaddr ; if ( FWINV ( ( arphdr -> ar_op & arpinfo -> arpop_mask ) != arpinfo -> arpop , ARPT_INV_ARPOP ) )  if ( FWINV ( ( arphdr -> ar_hrd & arpinfo -> arhrd_mask ) != arpinfo -> arhrd , ARPT_INV_ARPHRD ) )  if ( FWINV ( ( arphdr -> ar_pro & arpinfo -> arpro_mask ) != arpinfo -> arpro , ARPT_INV_ARPPRO ) )  if ( FWINV ( ( arphdr -> ar_hln & arpinfo -> arhln_mask ) != arpinfo -> arhln , ARPT_INV_ARPHLN ) )  arpptr += dev -> addr_len; arpptr += sizeof ( u32 ); arpptr += dev -> addr_len; memcpy ( & tgt_ipaddr , arpptr , sizeof ( u32 ) ); if ( FWINV ( ( src_ipaddr & arpinfo -> smsk . s_addr ) != arpinfo -> src . s_addr , ARPT_INV_SRCIP ) || FWINV ( ( ( tgt_ipaddr & arpinfo -> tmsk . s_addr ) != arpinfo -> tgt . s_addr ) , ARPT_INV_TGTIP ) )  dprintf ( "TGT: %pI4 Mask: %pI4 Target: %pI4.%s\n" , & tgt_ipaddr , & arpinfo -> tmsk . s_addr , & arpinfo -> tgt . s_addr , arpinfo -> invflags & ARPT_INV_TGTIP ? " (INV)" : "" ); 