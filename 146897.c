static dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms) const XML_Char * name ; const PREFIX * oldP = ( PREFIX * ) hashTableIterNext ( & iter ) ; if ( ! oldP )  name = poolCopyString ( & ( newDtd -> pool ) , oldP -> name ); if ( ! name )  if ( ! lookup ( & ( newDtd -> prefixes ) , name , sizeof ( PREFIX ) ) )  ATTRIBUTE_ID * newA ; const XML_Char * name ; const ATTRIBUTE_ID * oldA = ( ATTRIBUTE_ID * ) hashTableIterNext ( & iter ) ; if ( ! oldA )  if ( ! poolAppendChar ( & ( newDtd -> pool ) , XML_T ( '\0' ) ) )  name = poolCopyString ( & ( newDtd -> pool ) , oldA -> name ); if ( ! name )  newA = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , name , sizeof ( ATTRIBUTE_ID ) ); if ( ! newA )  int i ; ELEMENT_TYPE * newE ; const XML_Char * name ; const ELEMENT_TYPE * oldE = ( ELEMENT_TYPE * ) hashTableIterNext ( & iter ) ; if ( ! oldE )  name = poolCopyString ( & ( newDtd -> pool ) , oldE -> name ); if ( ! name )  newE = ( ELEMENT_TYPE * ) lookup ( & ( newDtd -> elementTypes ) , name , sizeof ( ELEMENT_TYPE ) ); if ( ! newE )  if ( oldE -> nDefaultAtts )  newE -> defaultAtts = ( DEFAULT_ATTRIBUTE * ) ms -> malloc_fcn ( oldE -> nDefaultAtts * sizeof ( DEFAULT_ATTRIBUTE ) ); if ( ! newE -> defaultAtts )  if ( oldE -> idAtt )  newE -> idAtt = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> idAtt -> name , 0 ); newE -> allocDefaultAtts = newE -> nDefaultAtts = oldE -> nDefaultAtts; if ( oldE -> prefix )  newE -> prefix = ( PREFIX * ) lookup ( & ( newDtd -> prefixes ) , oldE -> prefix -> name , 0 ); for (i = 0; i < newE->nDefaultAtts; i++) newE -> defaultAtts [ i ] . id = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> defaultAtts [ i ] . id -> name , 0 ); newE -> defaultAtts [ i ] . isCdata = oldE -> defaultAtts [ i ] . isCdata; if ( oldE -> defaultAtts [ i ] . value )  newE -> defaultAtts [ i ] . value = poolCopyString ( & ( newDtd -> pool ) , oldE -> defaultAtts [ i ] . value ); if ( ! newE -> defaultAtts [ i ] . value )  newE -> defaultAtts [ i ] . value = NULL; if ( ! copyEntityTable ( & ( newDtd -> generalEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> generalEntities ) ) )  if ( ! copyEntityTable ( & ( newDtd -> paramEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> paramEntities ) ) )  static copyEntityTable(HASH_TABLE STRING_POOL const HASH_TABLE *oldTable) const XML_Char * cachedOldBase = NULL ; ENTITY * newE ; const XML_Char * name ; const ENTITY * oldE = ( ENTITY * ) hashTableIterNext ( & iter ) ; if ( ! oldE )  name = poolCopyString ( newPool , oldE -> name ); if ( ! name )  newE = ( ENTITY * ) lookup ( newTable , name , sizeof ( ENTITY ) ); if ( ! newE )  if ( oldE -> systemId )  const XML_Char * tem = poolCopyString ( newPool , oldE -> systemId ) ; if ( ! tem )  if ( oldE -> base )  if ( oldE -> base == cachedOldBase )  cachedOldBase = oldE -> base; tem = poolCopyString ( newPool , cachedOldBase ); if ( ! tem )  if ( oldE -> publicId )  tem = poolCopyString ( newPool , oldE -> publicId ); if ( ! tem )  const XML_Char * tem = poolCopyStringN ( newPool , oldE -> textPtr , oldE -> textLen ) ; if ( ! tem )  if ( oldE -> notation )  const XML_Char * tem = poolCopyString ( newPool , oldE -> notation ) ; if ( ! tem )  static const XML_Char poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n) if ( ! pool -> ptr && ! poolGrow ( pool ) )  static XML_Bool poolGrow(STRING_POOL *pool) if ( pool -> freeBlocks )  if ( pool -> start == 0 )  if ( pool -> end - pool -> start < pool -> freeBlocks -> size )  if ( pool -> blocks && pool -> start == pool -> blocks -> s )  BLOCK * tem ; int blockSize = ( int ) ( pool -> end - pool -> start ) ; if ( blockSize < INIT_BLOCK_SIZE )  blockSize = INIT_BLOCK_SIZE; blockSize *= 2; tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ); if ( ! tem )  tem -> size = blockSize; tem -> next = pool -> blocks; pool -> blocks = tem; if ( pool -> ptr != pool -> start )  memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) ); pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ); pool -> start = tem -> s; pool -> end = tem -> s + blockSize; 