int CVE_2014_8541_PATCHED_ff_mjpeg_decode_sof(MJpegDecodeContext *s) int len , nb_components , i , width , height , bits , pix_fmt_id , ret ; int h_count [ MAX_COMPONENTS ] ; int v_count [ MAX_COMPONENTS ] ; s -> cur_scan = 0; s -> upscale_h = s -> upscale_v = 0; s -> avctx -> bits_per_raw_sample = bits = get_bits ( & s -> gb , 8 ); if ( s -> pegasus_rct )  bits = 9; if ( bits == 9 && ! s -> pegasus_rct )  s -> rct = 1; if ( s -> lossless && s -> avctx -> lowres )  height = get_bits ( & s -> gb , 16 ); width = get_bits ( & s -> gb , 16 ); if ( s -> interlaced && s -> width == width && s -> height == height + 1 )  height = s -> height; if ( av_image_check_size ( width , height , 0 , s -> avctx ) )  nb_components = get_bits ( & s -> gb , 8 ); if ( nb_components <= 0 || nb_components > MAX_COMPONENTS )  if ( s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  if ( nb_components != s -> nb_components )  if ( s -> ls && ! ( bits <= 8 || nb_components == 1 ) )  s -> nb_components = nb_components; s -> h_max = 1; s -> v_max = 1; memset ( h_count , 0 , sizeof ( h_count ) ); memset ( v_count , 0 , sizeof ( v_count ) ); for (i = 0; i < nb_components; i++) s -> component_id [ i ] = get_bits ( & s -> gb , 8 ) - 1; h_count [ i ] = get_bits ( & s -> gb , 4 ); v_count [ i ] = get_bits ( & s -> gb , 4 ); if ( h_count [ i ] > s -> h_max )  s -> h_max = h_count [ i ]; if ( v_count [ i ] > s -> v_max )  s -> v_max = v_count [ i ]; s -> quant_index [ i ] = get_bits ( & s -> gb , 8 ); if ( s -> quant_index [ i ] >= 4 )  if ( ! h_count [ i ] || ! v_count [ i ] )  if ( s -> ls && ( s -> h_max > 1 || s -> v_max > 1 ) )  if ( width != s -> width || height != s -> height || bits != s -> bits || memcmp ( s -> h_count , h_count , sizeof ( h_count ) ) || memcmp ( s -> v_count , v_count , sizeof ( v_count ) ) )  s -> width = width; s -> height = height; s -> bits = bits; memcpy ( s -> h_count , h_count , sizeof ( h_count ) ); memcpy ( s -> v_count , v_count , sizeof ( v_count ) ); s -> interlaced = 0; s -> got_picture = 0; if ( s -> first_picture && s -> org_height != 0 && s -> height < ( ( s -> org_height * 3 ) / 4 ) )  s -> interlaced = 1; s -> bottom_field = s -> interlace_polarity; s -> picture_ptr -> interlaced_frame = 1; s -> picture_ptr -> top_field_first = ! s -> interlace_polarity; ret = ff_set_dimensions ( s -> avctx , width , height ); if ( ret < 0 )  return ret ; if ( s -> got_picture && s -> interlaced && ( s -> bottom_field == ! s -> interlace_polarity ) )  pix_fmt_id = ( s -> h_count [ 0 ] << 28 ) | ( s -> v_count [ 0 ] << 24 ) | ( s -> h_count [ 1 ] << 20 ) | ( s -> v_count [ 1 ] << 16 ) | ( s -> h_count [ 2 ] << 12 ) | ( s -> v_count [ 2 ] << 8 ) | ( s -> h_count [ 3 ] << 4 ) | s -> v_count [ 3 ]; av_log ( s -> avctx , AV_LOG_DEBUG , "pix fmt id %x\n" , pix_fmt_id ); if ( ! ( pix_fmt_id & 0xD0D0D0D0 ) )  pix_fmt_id -= ( pix_fmt_id & 0xF0F0F0F0 ) >> 1; if ( ! ( pix_fmt_id & 0x0D0D0D0D ) )  pix_fmt_id -= ( pix_fmt_id & 0x0F0F0F0F ) >> 1; int is = ( pix_fmt_id >> ( 4 * i ) ) & 0xF ; int js = ( pix_fmt_id >> ( 4 * j ) ) & 0xF ; if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  js = ( pix_fmt_id >> ( 8 + 4 * ( i & 1 ) ) ) & 0xF; if ( is == 1 && js != 2 && ( i < 2 || i > 5 ) )  js = ( pix_fmt_id >> ( 16 + 4 * ( i & 1 ) ) ) & 0xF; if ( is == 1 && js == 2 )  switch ( pix_fmt_id )  if ( s -> component_id [ 0 ] == 'Q' && s -> component_id [ 1 ] == 'F' && s -> component_id [ 2 ] == 'A' )  if ( pix_fmt_id == 0x42111100 )  av_log ( s -> avctx , AV_LOG_ERROR , "Unhandled pixel format 0x%x\n" , pix_fmt_id ); s -> linesize [ i ] = s -> picture_ptr -> linesize [ i ] << s -> interlaced; av_dlog ( s -> avctx , "%d %d %d %d %d %d\n" , s -> width , s -> height , s -> linesize [ 0 ] , s -> linesize [ 1 ] , s -> interlaced , s -> avctx -> height ); av_log ( s -> avctx , AV_LOG_DEBUG , "decode_sof0: error, len(%d) mismatch\n" , len ); if ( s -> rgb && ! s -> lossless && ! s -> ls )  av_log ( s -> avctx , AV_LOG_ERROR , "Unsupported coding and pixel format combination\n" ); if ( s -> progressive )  int bw = ( width + s -> h_max * 8 - 1 ) / ( s -> h_max * 8 ) ; int bh = ( height + s -> v_max * 8 - 1 ) / ( s -> v_max * 8 ) ; for (i = 0; i < s->nb_components; i++) int size = bw * bh * s -> h_count [ i ] * s -> v_count [ i ] ; av_freep ( & s -> blocks [ i ] ); av_freep ( & s -> last_nnz [ i ] ); s -> blocks [ i ] = av_mallocz_array ( size , sizeof ( * * s -> blocks ) ); s -> last_nnz [ i ] = av_mallocz_array ( size , sizeof ( * * s -> last_nnz ) ); if ( ! s -> blocks [ i ] || ! s -> last_nnz [ i ] )  s -> block_stride [ i ] = bw * s -> h_count [ i ]; memset ( s -> coefs_finished , 0 , sizeof ( s -> coefs_finished ) ); 