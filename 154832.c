CharDriverState *qemu_chr_open(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) const char * p ; CharDriverState * chr ; if ( ! strcmp ( filename , "vc" ) )  if ( strstart ( filename , "vc:" , & p ) )  if ( ! strcmp ( filename , "null" ) )  if ( strstart ( filename , "tcp:" , & p ) )  if ( strstart ( filename , "telnet:" , & p ) )  if ( strstart ( filename , "udp:" , & p ) )  if ( strstart ( filename , "mon:" , & p ) )  chr = qemu_chr_open ( label , p , NULL ); CharDriverState *qemu_chr_open(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) const char * p ; CharDriverState * chr ; if ( ! strcmp ( filename , "vc" ) )  if ( strstart ( filename , "vc:" , & p ) )  if ( ! strcmp ( filename , "null" ) )  if ( strstart ( filename , "tcp:" , & p ) )  if ( strstart ( filename , "telnet:" , & p ) )  if ( strstart ( filename , "udp:" , & p ) )  if ( strstart ( filename , "mon:" , & p ) )  chr = qemu_chr_open ( label , p , NULL ); CharDriverState *qemu_chr_open(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) const char * p ; CharDriverState * chr ; if ( ! strcmp ( filename , "vc" ) )  if ( strstart ( filename , "vc:" , & p ) )  if ( ! strcmp ( filename , "null" ) )  if ( strstart ( filename , "tcp:" , & p ) )  if ( strstart ( filename , "telnet:" , & p ) )  if ( strstart ( filename , "udp:" , & p ) )  if ( strstart ( filename , "mon:" , & p ) )  if ( ! strcmp ( filename , "msmouse" ) )  if ( strstart ( filename , "unix:" , & p ) )  if ( strstart ( filename , "file:" , & p ) )  chr = qemu_chr_open_file_out ( p ); static CharDriverState *qemu_chr_open_file_out(const char *file_out) int fd_out ; TFR ( fd_out = open ( file_out , O_WRONLY | O_TRUNC | O_CREAT | O_BINARY , 0666 ) ); if ( fd_out < 0 )  return qemu_chr_open_fd ( - 1 , fd_out ) ; static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out) s -> fd_in = fd_in; s -> fd_out = fd_out; chr -> opaque = s; chr -> chr_write = fd_chr_write; chr -> chr_update_read_handler = fd_chr_update_read_handler; chr -> chr_close = fd_chr_close; qemu_chr_reset ( chr ); void qemu_chr_reset(CharDriverState *s) if ( s -> bh == NULL && initial_reset_issued )  s -> bh = qemu_bh_new ( qemu_chr_reset_bh , s ); qemu_bh_schedule ( s -> bh ); return chr ; 