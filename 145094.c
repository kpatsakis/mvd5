unsigned ipt_do_table(struct sk_buff const struct nf_hook_state struct xt_table *table) unsigned int hook = state -> hook ; const struct iphdr * ip ; const char * indev , * outdev ; const void * table_base ; struct ipt_entry * e , * * jumpstack ; unsigned int stackidx , cpu ; const struct xt_table_info * private ; struct xt_action_param acpar ; stackidx = 0; ip = ip_hdr ( skb ); indev = state -> in ? state -> in -> name : nulldevname; outdev = state -> out ? state -> out -> name : nulldevname; acpar . fragoff = ntohs ( ip -> frag_off ) & IP_OFFSET; acpar . thoff = ip_hdrlen ( skb ); acpar . hotdrop = false; acpar . net = state -> net; acpar . in = state -> in; acpar . out = state -> out; acpar . family = NFPROTO_IPV4; acpar . hooknum = hook; private = table -> private; cpu = smp_processor_id ( ); table_base = private -> entries; jumpstack = ( struct ipt_entry * * ) private -> jumpstack [ cpu ]; if ( static_key_false ( & xt_tee_enabled ) )  jumpstack += private -> stacksize * __this_cpu_read ( nf_skb_duplicated ); e = get_entry ( table_base , private -> hook_entry [ hook ] ); static inline struct ipt_entry get_entry(const void *base, unsigned int offset) return ( struct ipt_entry * ) ( base + offset ) ; const struct xt_entry_target * t ; const struct xt_entry_match * ematch ; if ( ! ip_packet_match ( ip , indev , outdev , & e -> ip , acpar . fragoff ) )  static inline ip_packet_match(const struct iphdr const char const char const struct ipt_ip int isfrag) unsigned long ret ; if ( FWINV ( ( ip -> saddr & ipinfo -> smsk . s_addr ) != ipinfo -> src . s_addr , IPT_INV_SRCIP ) || FWINV ( ( ip -> daddr & ipinfo -> dmsk . s_addr ) != ipinfo -> dst . s_addr , IPT_INV_DSTIP ) )  return false ; ret = ifname_compare_aligned ( indev , ipinfo -> iniface , ipinfo -> iniface_mask ); if ( FWINV ( ret != 0 , IPT_INV_VIA_IN ) )  return false ; ret = ifname_compare_aligned ( outdev , ipinfo -> outiface , ipinfo -> outiface_mask ); if ( FWINV ( ret != 0 , IPT_INV_VIA_OUT ) )  return false ; if ( ipinfo -> proto && FWINV ( ip -> protocol != ipinfo -> proto , IPT_INV_PROTO ) )  return false ; if ( FWINV ( ( ipinfo -> flags & IPT_F_FRAG ) && ! isfrag , IPT_INV_FRAG ) )  return false ; return true ; e = ipt_next_entry ( e ); static struct ipt_entry *ipt_next_entry(const struct ipt_entry *entry) return ( void * ) entry + entry -> next_offset ; acpar . match = ematch -> u . kernel . match; acpar . matchinfo = ematch -> data; if ( ! acpar . match -> match ( skb , & acpar ) )  t = ipt_get_target ( e ); if ( unlikely ( skb -> nf_trace ) )  trace_packet ( state -> net , skb , hook , state -> in , state -> out , table -> name , private , e ); if ( ! t -> u . kernel . target -> target )  int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict; if ( v < 0 )  if ( v != XT_RETURN )  if ( stackidx == 0 )  e = get_entry ( table_base , private -> underflow [ hook ] ); static inline struct ipt_entry get_entry(const void *base, unsigned int offset) return ( struct ipt_entry * ) ( base + offset ) ; e = jumpstack [ -- stackidx ]; e = ipt_next_entry ( e ); static struct ipt_entry *ipt_next_entry(const struct ipt_entry *entry) return ( void * ) entry + entry -> next_offset ; if ( table_base + v != ipt_next_entry ( e ) && ! ( e -> ip . flags & IPT_F_GOTO ) )  static struct ipt_entry *ipt_next_entry(const struct ipt_entry *entry) return ( void * ) entry + entry -> next_offset ; jumpstack [ stackidx ++ ] = e; e = get_entry ( table_base , v ); static inline struct ipt_entry get_entry(const void *base, unsigned int offset) return ( struct ipt_entry * ) ( base + offset ) ; acpar . target = t -> u . kernel . target; acpar . targinfo = t -> data; verdict = t -> u . kernel . target -> target ( skb , & acpar ); ip = ip_hdr ( skb ); if ( verdict == XT_CONTINUE )  e = ipt_next_entry ( e ); static struct ipt_entry *ipt_next_entry(const struct ipt_entry *entry) return ( void * ) entry + entry -> next_offset ; while ( ! acpar . hotdrop )  static void trace_packet(struct net const struct sk_buff unsigned int const struct net_device const struct net_device const char const struct xt_table_info const struct ipt_entry *e) const char * hookname , * chainname , * comment ; const struct ipt_entry * iter ; hookname = chainname = hooknames [ hook ]; comment = comments [ NF_IP_TRACE_COMMENT_RULE ]; if ( get_chainname_rulenum ( iter , e , hookname , & chainname , & comment , & rulenum ) != 0 )  static inline get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry const char *hookname, const char const char **comment, unsigned int *rulenum) const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( s ) ; static inline const struct xt_entry_target ipt_get_target_c(const struct ipt_entry *e) return ipt_get_target ( ( struct ipt_entry * ) e ) ; if ( strcmp ( t -> target . u . kernel . target -> name , XT_ERROR_TARGET ) == 0 )  if ( s == e )  if ( s -> target_offset == sizeof ( struct ipt_entry ) && strcmp ( t -> target . u . kernel . target -> name , XT_STANDARD_TARGET ) == 0 && t -> verdict < 0 && unconditional ( & s -> ip ) )  static inline bool unconditional(const struct ipt_ip *ip) static const struct ipt_ip uncond ; return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ; 