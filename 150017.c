static void flush_encoders() int i ; for (i = 0; i < nb_output_streams; i++) OutputStream * ost = output_streams [ i ] ; AVCodecContext * enc = ost -> st -> codec ; AVFormatContext * os = output_files [ ost -> file_index ] -> ctx ; int stop_encoding = 0 ; if ( ! ost -> encoding_needed )  if ( ( ost -> st -> codec -> codec_type ) == AVMEDIA_TYPE_AUDIO && enc -> frame_size <= 1 )  if ( ( ost -> st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO && os -> oformat -> flags & 0x20 && ( enc -> codec -> id ) == AV_CODEC_ID_RAWVIDEO )  int ( * encode ) ( AVCodecContext * , AVPacket * , const AVFrame * , int * ) = ( void * ) 0 switch ( ost -> st -> codec -> codec_type )  encode = avcodec_encode_audio2; encode = avcodec_encode_video2; stop_encoding = 1; if ( encode )  int got_packet ; if ( ost -> logfile && enc -> stats_out )  fprintf ( ost -> logfile , "%s" , enc -> stats_out ); if ( ! got_packet )  stop_encoding = 1; if ( pkt . pts != ( ( int64_t ) 0x8000000000000000UL ) )  pkt . pts = av_rescale_q ( pkt . pts , enc -> time_base , ost -> st -> time_base ); if ( pkt . dts != ( ( int64_t ) 0x8000000000000000UL ) )  pkt . dts = av_rescale_q ( pkt . dts , enc -> time_base , ost -> st -> time_base ); if ( pkt . duration > 0 )  pkt . duration = ( av_rescale_q ( pkt . duration , enc -> time_base , ost -> st -> time_base ) ); write_frame ( os , & pkt , ost ); static void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost) AVBitStreamFilterContext * bsfc = ost -> bitstream_filters ; AVCodecContext * avctx = ost -> st -> codec ; if ( ( avctx -> codec_type ) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || ( avctx -> codec_type ) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0 )  pkt -> pts = pkt -> dts = ( ( int64_t ) 0x8000000000000000UL ); if ( ( ( avctx -> codec_type ) == AVMEDIA_TYPE_AUDIO || ( avctx -> codec_type ) == AVMEDIA_TYPE_VIDEO ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) )  int64_t max = ost -> st -> cur_dts + ( ! ( s -> oformat -> flags & 0x8020000 ) ) ; if ( ost -> st -> cur_dts && ost -> st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && max > pkt -> dts )  av_log ( s , ( max - pkt -> dts > 2 || ( avctx -> codec_type ) == AVMEDIA_TYPE_VIDEO ? 24 : 48 ) , "st:%d PTS: %ld DTS: %ld < %ld invalid, clipping\n" , pkt -> stream_index , pkt -> pts , pkt -> dts , max ); if ( pkt -> pts >= pkt -> dts )  pkt -> pts = ( pkt -> pts > max ? pkt -> pts : max ); pkt -> dts = max; if ( ! ( ( avctx -> codec_type ) == AVMEDIA_TYPE_VIDEO && avctx -> codec ) )  if ( ( ost -> frame_number ) >= ost -> max_frames )  av_free_packet ( pkt ); ost -> frame_number ++; while ( bsfc )  AVPacket new_pkt = * pkt ; int a = av_bitstream_filter_filter ( bsfc , avctx , ( ( void * ) 0 ) , & new_pkt . data , & new_pkt . size , ( pkt -> data ) , pkt -> size , pkt -> flags & 0000001 ) ; if ( a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct )  uint8_t * t = ( av_malloc ( ( new_pkt . size + 16 ) ) ) ; if ( t )  memcpy ( t , new_pkt . data , new_pkt . size ); memset ( ( t + new_pkt . size ) , 0 , 16 ); new_pkt . data = t; if ( a > 0 )  av_free_packet ( pkt ); new_pkt . destruct = av_destruct_packet; if ( a < 0 )  av_log ( ( ( void * ) 0 ) , 16 , "Failed to open bitstream filter %s for stream %d with codec %s" , bsfc -> filter -> name , pkt -> stream_index , ( avctx -> codec ? avctx -> codec -> name : "copy" ) ); print_error ( "" , a ); * pkt = new_pkt; bsfc = bsfc -> next; pkt -> stream_index = ost -> index; av_log ( ( ( void * ) 0 ) , 32 , "muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\n" , av_get_media_type_string ( ost -> st -> codec -> codec_type ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts ) , av_ts_make_time_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts , & ost -> st -> time_base ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) , av_ts_make_time_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts , & ost -> st -> time_base ) , pkt -> size ) ret = av_interleaved_write_frame ( s , pkt ); if ( ret < 0 )  print_error ( "av_interleaved_write_frame()" , ret ); if ( ( ost -> st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO && vstats_filename )  do_video_stats ( ost , pkt . size ); static void do_video_stats(OutputStream *ost,int frame_size) enc = ost -> st -> codec; if ( ( enc -> codec_type ) == AVMEDIA_TYPE_VIDEO )  frame_number = ( ost -> st -> nb_frames ); fprintf ( vstats_file , "frame= %5d q= %2.1f " , frame_number , ( ( enc -> coded_frame -> quality ) / ( ( float ) 'v' ) ) ); if ( enc -> flags & 0x8000 )  fprintf ( vstats_file , "PSNR= %6.2f " , psnr ( enc -> coded_frame -> error [ 0 ] / ( ( enc -> width * enc -> height ) * 255.0 * 255.0 ) ) ); static double psnr(double d) return - 10.0 * log ( d ) / log ( 10.0 ) ; fprintf ( vstats_file , "f_size= %6d " , frame_size ); ti1 = ost -> st -> pts . val * av_q2d ( enc -> time_base ); if ( ti1 < 0.01 )  bitrate = ( frame_size * 8 ) / av_q2d ( enc -> time_base ) / 1000.0; avg_bitrate = ( ( double ) ( video_size * 8 ) ) / ti1 / 1000.0; fprintf ( vstats_file , "s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s " , ( ( double ) video_size ) / 1024 , ti1 , bitrate , avg_bitrate ); fprintf ( vstats_file , "type= %c\n" , ( av_get_picture_type_char ( enc -> coded_frame -> pict_type ) ) ); if ( stop_encoding )  