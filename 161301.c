nsresult MediaPipeline::TransportReady_s(TransportInfo &info) if ( info . state_ != MP_CONNECTING )  nsresult res ; TransportLayerDtls * dtls = static_cast < TransportLayerDtls * > info . transport_ -> GetLayer ( TransportLayerDtls :: ID ( ) ) res = dtls -> GetSrtpCipher ( & cipher_suite ); if ( NS_FAILED ( res ) )  unsigned char srtp_block [ SRTP_TOTAL_KEY_LENGTH * 2 ] ; res = dtls -> ExportKeyingMaterial ( kDTLSExporterLabel , false , "" , srtp_block , sizeof ( srtp_block ) ); if ( NS_FAILED ( res ) )  unsigned char client_write_key [ SRTP_TOTAL_KEY_LENGTH ] ; int offset = 0 ; memcpy ( client_write_key , srtp_block + offset , SRTP_MASTER_KEY_LENGTH ); offset += SRTP_MASTER_KEY_LENGTH; offset += SRTP_MASTER_KEY_LENGTH; memcpy ( client_write_key + SRTP_MASTER_KEY_LENGTH , srtp_block + offset , SRTP_MASTER_SALT_LENGTH ); write_key = client_write_key; read_key = client_write_key; info . send_srtp_ = SrtpFlow :: Create ( cipher_suite , false , write_key , SRTP_TOTAL_KEY_LENGTH ); info . recv_srtp_ = SrtpFlow :: Create ( cipher_suite , true , read_key , SRTP_TOTAL_KEY_LENGTH ); if ( ! info . send_srtp_ || ! info . recv_srtp_ )  MOZ_MTLOG ( ML_ERROR , "Couldn't create SRTP flow for " << ToString ( info . type_ ) ); static const char* ToString(MediaPipeline::RtpType type) return array [ type ] ; info . state_ = MP_CLOSED; UpdateRtcpMuxState ( info ); MOZ_MTLOG ( ML_INFO , "Listening for " << ToString ( info . type_ << " packets received on " static_cast < void * > ( dtls -> downward ( ) ) ) static const char* ToString(MediaPipeline::RtpType type) return array [ type ] ; switch ( info . type_ )  info . state_ = MP_OPEN; UpdateRtcpMuxState ( info ); 