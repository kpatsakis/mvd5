int main() u_char * msg = ( u_char * ) malloc ( 1000 * sizeof ( u_char ) ) ; msglen = create_msg ( msg ); int create_msg(u_char *buf) p = buf; while ( * temp != '\0' )  * p ++ = * temp ++; * p ++ = * comp_dn ++; PUTSHORT ( 30 , p ); p += 2; PUTSHORT ( 255 , p ); p += 2; PUTLONG ( 255 , p ); p += 4; PUTSHORT ( 16 , p ); p += 2; * p ++ = * comp_dn2 ++; PUTLONG ( 1 << 24 , p ); p += 4; PUTLONG ( 0 , p ); p += 4; PUTLONG ( 0 , p ); p += 4; PUTLONG ( 0 , p ); p += 4; printf ( "msglen = %d\n" , msglen ); dp = msg + sizeof ( HEADER ); ret = rrextract ( msg , msglen , dp , name , 100 ); static rrextract(u_char *msg, int msglen, u_char *rrp, u_char *dname, int namelen) HEADER * hp = ( HEADER * ) msg ; cp = rrp; eom = msg + msglen; printf ( "msg = %s, msglen = %d, rrp = %s, namelen = %d\n" , ( char * ) msg , msglen , ( char * ) rrp , namelen ); if ( ( n = dn_expand ( msg , eom , cp , ( char * ) dname , namelen ) ) < 0 )  printf ( "dn_expand returned %d\n" , n ); hp -> rcode = FORMERR; printf ( "First dn_expand returned n = %d\n" , n ); cp += n; len += n; len += sizeof ( HEADER ); BOUNDS_CHECK ( cp , 2 * INT16SZ + INT32SZ + INT16SZ ); GETSHORT ( type , cp ); cp += 2; len += 2; GETSHORT ( class , cp ) cp += 2; len += 2; hp -> rcode = FORMERR; cp += 4; len += 4; printf ( "%s: converted TTL > %u to 0" , dname , MAXIMUM_TTL ); GETSHORT ( dlen , cp ); cp += 2; len += 2; printf ( "msglen - len - 12 = %d, dlen = %d\n" , msglen - len - 12 , dlen ); BOUNDS_CHECK ( cp , dlen ); rdatap = cp; hp -> rcode = FORMERR; n = dn_expand ( msg , eom , cp , ( char * ) data , sizeof data ); printf ( "dn_expand returned n = %d\n" , n ); printf ( "Compressed name = %s, Expanded name = %s\n" , cp , data ); if ( n < 0 || n >= dlen )  printf ( "n=%d >= dlen = %d\n" , n , dlen ); if ( ! ns_nameok ( ( char * ) data , class , NULL , response_trans , domain_ctx , ( char * ) dname ) ) cp += n; n2 = dlen - n; printf ( "n2 = %d\n" , n2 ); printf ( "*cp = %d\n" , * cp ); if ( ( * cp & 0x01 ) == 0 )  if ( n2 < 4 || n2 > 16 )  if ( n2 > sizeof data - n1 )  printf ( "Want to copy %d bytes, but can only fit %d\n" , n2 , sizeof data - n1 ); printf ( "Copying %d bytes from cp to cp1\n" , n2 ); memcpy ( cp1 , cp , n2 ); cp += n2; n = cp1 - ( u_char * ) data; return ( ( cp - rrp ) + dlen ) ; if ( cp > eom )  if ( ( u_int ) ( cp - rdatap ) != dlen )  printf ( "encoded rdata length is %u, but actual length was %u" , dlen , ( u_int ) ( cp - rdatap ) ); if ( n > MAXDATA )  printf ( "update type %d: %d bytes is too much data" , type , n ); return ( cp - rrp ) ; printf ( "rrextract returned %d\n" , ret ); 