static int CVE_2011_1833_VULN_ecryptfs_parse_options(struct ecryptfs_sb_info *sbi, char *options) char * p ; int sig_set = 0 ; int cipher_name_set = 0 ; int cipher_key_bytes ; int fn_cipher_key_bytes ; struct ecryptfs_mount_crypt_stat * mount_crypt_stat = & sbi -> mount_crypt_stat ; substring_t args [ MAX_OPT_ARGS ] ; int token ; char * sig_src ; char * cipher_name_dst ; char * cipher_name_src ; char * cipher_key_bytes_src ; char * fn_cipher_key_bytes_src ; if ( ! options )  while ( ( p = strsep ( & options , "," ) ) != NULL )  if ( ! * p )  token = match_token ( p , tokens , args ); switch ( token )  sig_src = args [ 0 ] . from; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , sig_src , 0 ); if ( rc )  printk ( KERN_ERR "Error attempting to register "global sig; rc = [%d]\n" , rc ) sig_set = 1; cipher_name_src = args [ 0 ] . from; cipher_name_dst = mount_crypt_stat -> global_default_cipher_name; strncpy ( cipher_name_dst , cipher_name_src , ECRYPTFS_MAX_CIPHER_NAME_SIZE ); cipher_name_dst [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; cipher_name_set = 1; cipher_key_bytes_src = args [ 0 ] . from; cipher_key_bytes = ( int ) simple_strtol ( cipher_key_bytes_src , & cipher_key_bytes_src , 0 ); mount_crypt_stat -> global_default_cipher_key_size = cipher_key_bytes; mount_crypt_stat -> flags |= ECRYPTFS_PLAINTEXT_PASSTHROUGH_ENABLED; mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; mount_crypt_stat -> flags |= ECRYPTFS_XATTR_METADATA_ENABLED; mount_crypt_stat -> flags |= ECRYPTFS_ENCRYPTED_VIEW_ENABLED; mount_crypt_stat -> global_default_fnek_sig [ ECRYPTFS_SIG_SIZE_HEX ] = '\0'; rc = ecryptfs_add_global_auth_tok ( mount_crypt_stat , mount_crypt_stat -> global_default_fnek_sig , ECRYPTFS_AUTH_TOK_FNEK ); if ( rc )  mount_crypt_stat -> flags |= ( ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES | ECRYPTFS_GLOBAL_ENCFN_USE_MOUNT_FNEK ); mount_crypt_stat -> global_default_fn_cipher_name [ ECRYPTFS_MAX_CIPHER_NAME_SIZE ] = '\0'; fn_cipher_key_bytes_src = args [ 0 ] . from; fn_cipher_key_bytes = ( int ) simple_strtol ( fn_cipher_key_bytes_src , & fn_cipher_key_bytes_src , 0 ); mount_crypt_stat -> global_default_fn_cipher_key_bytes = fn_cipher_key_bytes; mount_crypt_stat -> flags |= ECRYPTFS_UNLINK_SIGS; mount_crypt_stat -> flags |= ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY; if ( ! sig_set )  if ( ! cipher_name_set )  strcpy ( mount_crypt_stat -> global_default_cipher_name , ECRYPTFS_DEFAULT_CIPHER ); if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_name_set )  strcpy ( mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_cipher_name ); mount_crypt_stat -> global_default_cipher_key_size = 0; if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! fn_cipher_key_bytes_set )  mount_crypt_stat -> global_default_fn_cipher_key_bytes = mount_crypt_stat -> global_default_cipher_key_size; if ( ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_cipher_name , NULL ) )  rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_cipher_name , mount_crypt_stat -> global_default_cipher_key_size ); if ( rc )  if ( ( mount_crypt_stat -> flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES ) && ! ecryptfs_tfm_exists ( mount_crypt_stat -> global_default_fn_cipher_name , NULL ) )  rc = ecryptfs_add_new_key_tfm ( NULL , mount_crypt_stat -> global_default_fn_cipher_name , mount_crypt_stat -> global_default_fn_cipher_key_bytes ); if ( rc )  rc = ecryptfs_init_global_auth_toks ( mount_crypt_stat ); if ( rc )  printk ( KERN_WARNING "One or more global auth toks could not "properly register; rc = [%d]\n" , rc ) return rc ; 