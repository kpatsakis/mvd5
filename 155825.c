static void register_mibs() SmiModule * smiModule ; SmiNode * smiNode ; char * smi_load_error = ( ( void * ) 0 ) ; if ( smi_load_error )  if ( smi_load_error )  if ( ! prefs . load_smi_modules )  if ( oids_init_done )  for (smiModule = smiGetFirstModule(); smiModule; smiModule = smiGetNextModule(smiModule)) if ( smiModule -> conformance == 1 )  for (smiNode = smiGetFirstNode(smiModule,0xffff); smiNode; smiNode = smiGetNextNode(smiNode,0xffff)) SmiType * smiType = smiGetNodeType ( smiNode ) ; const oid_value_type_t * typedata = get_typedata ( smiType ) ; static const oid_value_type_t *get_typedata(SmiType *smiType) static const struct _type_mapping_t { const char * name ; SmiBasetype base ; const oid_value_type_t * type ; } types [ ] = { { ( "IpAddress" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & ipv4_type ) } , { ( "InetAddressIPv4" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & ipv4_type ) } , { ( "InetAddressIPv6" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & ipv6_type ) } , { ( "NetworkAddress" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & ipv4_type ) } , { ( "MacAddress" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & ether_type ) } , { ( "TimeTicks" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & timeticks_type ) } , { ( "Ipv6Address" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & ipv6_type ) } , { ( "TimeStamp" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & timeticks_type ) } , { ( "DisplayString" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & string_type ) } , { ( "SnmpAdminString" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & string_type ) } , { ( "DateAndTime" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & string_type ) } , { ( "Counter" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & counter32_type ) } , { ( "Counter32" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & counter32_type ) } , { ( "Unsigned32" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & unsigned32_type ) } , { ( "Gauge" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & unsigned32_type ) } , { ( "Gauge32" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & unsigned32_type ) } , { ( "NsapAddress" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & nsap_type ) } , { ( "i32" ) , ( SMI_BASETYPE_INTEGER32 ) , ( & integer_type ) } , { ( "octets" ) , ( SMI_BASETYPE_OCTETSTRING ) , ( & bytes_type ) } , { ( "oid" ) , ( SMI_BASETYPE_OBJECTIDENTIFIER ) , ( & oid_type ) } , { ( "u32" ) , ( SMI_BASETYPE_UNSIGNED32 ) , ( & unsigned32_type ) } , { ( "u64" ) , ( SMI_BASETYPE_UNSIGNED64 ) , ( & counter64_type ) } , { ( "f32" ) , ( SMI_BASETYPE_FLOAT32 ) , ( & float_type ) } , { ( "f64" ) , ( SMI_BASETYPE_FLOAT64 ) , ( & double_type ) } , { ( "f128" ) , ( SMI_BASETYPE_FLOAT128 ) , ( & bytes_type ) } , { ( "enum" ) , ( SMI_BASETYPE_ENUM ) , ( & integer_type ) } , { ( "bits" ) , ( SMI_BASETYPE_BITS ) , ( & bytes_type ) } , { ( "unk" ) , ( SMI_BASETYPE_UNKNOWN ) , ( & unknown_type ) } , { ( ( ( void * ) 0 ) ) , ( SMI_BASETYPE_UNKNOWN ) , ( ( ( void * ) 0 ) ) } } ; const struct _type_mapping_t * t ; SmiType * sT = smiType ; if ( ! smiType )  return ( ( void * ) 0 ) ; for (t = types; t -> type; t++) char * name = smiRenderType ( sT , 0x02 ) ; if ( name && t -> name && g_str_equal ( name , ( t -> name ) ) )  return t -> type ; while ( sT = smiGetParentType ( sT ) )  for (t = types; t -> type; t++) if ( ( smiType -> basetype ) == ( t -> base ) )  return t -> type ; return & unknown_type ; oid_key_t * key ; oid_kind_t kind = smikind ( smiNode , & key ) ; inline static oid_kind_t smikind(SmiNode *sN,oid_key_t **key_p) switch ( sN -> nodekind )  switch ( sN -> indexkind )  return OID_KIND_UNKNOWN ; return OID_KIND_ROW ; return OID_KIND_NODE ; return OID_KIND_SCALAR ; return OID_KIND_TABLE ; return OID_KIND_COLUMN ; return OID_KIND_NOTIFICATION ; return OID_KIND_GROUP ; return OID_KIND_COMPLIANCE ; return OID_KIND_CAPABILITIES ; return OID_KIND_UNKNOWN ; char * oid = smiRenderOID ( smiNode -> oidlen , smiNode -> oid , 0x04 ) ; oid_info_t * oid_data = add_oid ( oid , kind , typedata , key , smiNode -> oidlen , smiNode -> oid ) ; static oid_info_t *add_oid(const char *name,oid_kind_t kind,const oid_value_type_t *type,oid_key_t *key,guint oid_len,guint32 *subids) guint i = 0 ; oid_info_t * c = & oid_root ; oid_len --; oid_info_t * n = ( emem_tree_lookup32 ( ( c -> children ) , subids [ i ] ) ) ; if ( n )  if ( i == oid_len )  return n ; n = ( g_malloc ( sizeof ( oid_info_t ) ) ); if ( i == oid_len )  return n ; n -> name = ( ( void * ) 0 ); n -> value_type = ( ( void * ) 0 ); n -> kind = OID_KIND_UNKNOWN; c = n; while ( ++ i )  return ( ( void * ) 0 ) ; if ( typedata && oid_data -> value_hfid == - 2 )  SmiNamedNumber * smiEnum ; hf_register_info hf = { & oid_data -> value_hfid , { ( oid_data -> name ) , ( alnumerize ( ( oid_data -> name ) ) ) , typedata -> ft_type , typedata -> display , ( ( ( void * ) 0 ) ) , ( 0 ) , ( smiRenderOID ( smiNode -> oidlen , smiNode -> oid , 0xff ) ) , ( 0 ) , ( 0 ) , ( HF_REF_TYPE_NONE ) , ( 0 ) , ( ( ( void * ) 0 ) ) , ( ( ( void * ) 0 ) ) } } ; static char *alnumerize(const char *name) char * s = g_strdup ( name ) ; return s ; if ( strcmp ( hf . hfinfo . blurb , hf . hfinfo . name ) == 0 )  hf . hfinfo . blurb = ( ( void * ) 0 ); oid_data -> value_hfid = - 1; if ( ( hf . hfinfo . type == FT_UINT8 || hf . hfinfo . type == FT_UINT16 || hf . hfinfo . type == FT_UINT24 || hf . hfinfo . type == FT_UINT32 || hf . hfinfo . type == FT_INT8 || hf . hfinfo . type == FT_INT16 || hf . hfinfo . type == FT_INT24 || hf . hfinfo . type == FT_INT32 || hf . hfinfo . type == FT_UINT64 || hf . hfinfo . type == FT_INT64 ) && ( smiEnum = smiGetFirstNamedNumber ( smiType ) ) )  GArray * vals = g_array_new ( ! 0 , ! 0 , ( sizeof ( value_string ) ) ) ; hf . hfinfo . strings = ( vals -> data ); 