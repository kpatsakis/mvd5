HTAB *hash_create(const char *tabname,long nelem,HASHCTL *info,int flags) HTAB * hashp ; hashp = ( ( HTAB * ) ( DynaHashAlloc ( sizeof ( HTAB ) + strlen ( tabname ) + 1 ) ) ); static void *DynaHashAlloc(Size size) return MemoryContextAlloc ( CurrentDynaHashCxt , size ) ; void * _vstart = ( void * ) hashp ; if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  long * _start = ( long * ) _vstart ; long * _stop = ( long * ) ( ( ( char * ) _start ) + _len ) ; while ( _start < _stop )  * ( _start ++ ) = 0; memset ( _vstart , _val , _len ); hashp -> tabname = ( ( char * ) ( hashp + 1 ) ); strcpy ( hashp -> tabname , tabname ); hashp -> hash = info -> hash; hashp -> hash = string_hash; hashp -> match = info -> match; if ( hashp -> hash == string_hash )  hashp -> match = ( ( HashCompareFunc ) string_compare ); hashp -> match = memcmp; hashp -> keycopy = info -> keycopy; if ( hashp -> hash == string_hash )  hashp -> keycopy = ( ( HashCopyFunc ) strlcpy ); hashp -> keycopy = memcpy; hashp -> alloc = info -> alloc; hashp -> alloc = DynaHashAlloc; hashp -> hctl = info -> hctl; hashp -> dir = ( ( HASHSEGMENT * ) ( ( ( char * ) ( info -> hctl ) ) + sizeof ( HASHHDR ) ) ); hashp -> hcxt = ( ( void * ) 0 ); hashp -> isshared = ( ( bool ) 1 ); hctl = hashp -> hctl; hashp -> keysize = hctl -> keysize; hashp -> ssize = hctl -> ssize; hashp -> sshift = hctl -> sshift; return hashp ; hashp -> hctl = ( ( void * ) 0 ); hashp -> dir = ( ( void * ) 0 ); hashp -> hcxt = CurrentDynaHashCxt; hashp -> isshared = ( ( bool ) 0 ); if ( ! hashp -> hctl )  hashp -> hctl = ( ( HASHHDR * ) ( ( hashp -> alloc ) ( sizeof ( HASHHDR ) ) ) ); if ( ! hashp -> hctl )  hashp -> frozen = ( ( bool ) 0 ); hdefault ( hashp ); static void hdefault(HTAB *hashp) HASHHDR * hctl = hashp -> hctl ; void * _vstart = ( void * ) hctl ; if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  long * _start = ( long * ) _vstart ; long * _stop = ( long * ) ( ( ( char * ) _start ) + _len ) ; while ( _start < _stop )  * ( _start ++ ) = 0; memset ( _vstart , _val , _len ); hctl -> nentries = 0; hctl -> freeList = ( ( void * ) 0 ); hctl -> dsize = 256; hctl -> nsegs = 0; hctl -> keysize = sizeof ( char * ); hctl -> entrysize = 2 * sizeof ( char * ); hctl -> num_partitions = 0; hctl -> ffactor = 1; hctl -> max_dsize = ( - 1 ); hctl -> ssize = 256; hctl -> sshift = 8; hctl = hashp -> hctl; hctl -> num_partitions = info -> num_partitions; hctl -> ssize = info -> ssize; hctl -> sshift = my_log2 ( info -> ssize ); int my_log2(long num) if ( num > 9223372036854775807L / 2 )  num = 9223372036854775807L / 2; for ((i = 0 , limit = 1); limit < num; (i++ , limit <<= 1)) hctl -> ffactor = info -> ffactor; hctl -> max_dsize = info -> max_dsize; hctl -> dsize = info -> dsize; hctl -> keysize = info -> keysize; hctl -> entrysize = info -> entrysize; hashp -> keysize = hctl -> keysize; hashp -> ssize = hctl -> ssize; hashp -> sshift = hctl -> sshift; if ( ! init_htab ( hashp , nelem ) )  static bool init_htab(HTAB *hashp,long nelem) HASHHDR * hctl = hashp -> hctl ; if ( hctl -> num_partitions != 0 )  * ( ( volatile slock_t * ) ( & hctl -> mutex ) ) = 0; nbuckets = next_pow2_int ( ( nelem - 1 ) / hctl -> ffactor + 1 ); static int next_pow2_int(long num) if ( num > ( 2147483647 / 2 ) )  num = ( 2147483647 / 2 ); return 1 << my_log2 ( num ) ; int my_log2(long num) if ( num > 9223372036854775807L / 2 )  num = 9223372036854775807L / 2; while ( nbuckets < hctl -> num_partitions )  nbuckets <<= 1; hctl -> max_bucket = hctl -> low_mask = ( nbuckets - 1 ); hctl -> high_mask = ( ( nbuckets << 1 ) - 1 ); nsegs = ( ( nbuckets - 1 ) / hctl -> ssize + 1 ); nsegs = next_pow2_int ( nsegs ); static int next_pow2_int(long num) if ( num > ( 2147483647 / 2 ) )  num = ( 2147483647 / 2 ); return 1 << my_log2 ( num ) ; if ( nsegs > hctl -> dsize )  if ( ! hashp -> dir )  hctl -> dsize = nsegs; if ( ! hashp -> dir )  CurrentDynaHashCxt = hashp -> hcxt; hashp -> dir = ( ( HASHSEGMENT * ) ( ( hashp -> alloc ) ( ( hctl -> dsize ) * sizeof ( HASHSEGMENT ) ) ) ); if ( ! hashp -> dir )  for (segp = hashp -> dir; hctl -> nsegs < nsegs; (hctl -> nsegs++ , segp++)) * segp = seg_alloc ( hashp ); static HASHSEGMENT seg_alloc(HTAB *hashp) CurrentDynaHashCxt = hashp -> hcxt; segp = ( ( HASHSEGMENT ) ( ( hashp -> alloc ) ( sizeof ( HASHBUCKET ) * ( hashp -> ssize ) ) ) ); if ( ! segp )  void * _vstart = ( void * ) segp ; Size _len = sizeof ( HASHBUCKET ) * ( hashp -> ssize ) ; if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  long * _start = ( long * ) _vstart ; long * _stop = ( long * ) ( ( ( char * ) _start ) + _len ) ; while ( _start < _stop )  * ( _start ++ ) = 0; memset ( _vstart , _val , _len ); return segp ; if ( * segp == ( ( void * ) 0 ) )  hctl -> nelem_alloc = choose_nelem_alloc ( hctl -> entrysize ); static int choose_nelem_alloc(Size entrysize) elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) entrysize ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ); nelem_alloc = ( allocSize / elementSize ); while ( nelem_alloc < 32 )  return nelem_alloc ; elog_start ( "dynahash.c" , 434 , __func__ ) , elog_finish ( 20 , "failed to initialize hash table \"%s\"" , hashp -> tabname ); if ( flags & 0x040 || nelem < ( hctl -> nelem_alloc ) )  if ( ! element_alloc ( hashp , ( ( int ) nelem ) ) )  static bool element_alloc(HTAB *hashp,int nelem) volatile HASHHDR * hctlv = ( hashp -> hctl ) ; if ( hashp -> isfixed )  elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ); CurrentDynaHashCxt = hashp -> hcxt; firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ); if ( ! firstElement )  tmpElement = firstElement; for (i = 0; i < nelem; i++) tmpElement -> link = prevElement; prevElement = tmpElement; tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) ); if ( hctlv -> num_partitions != 0 )  if ( tas ( & hctlv -> mutex ) )  s_lock ( & hctlv -> mutex , "dynahash.c" , 1384 ); firstElement -> link = hctlv -> freeList; hctlv -> freeList = prevElement; if ( hctlv -> num_partitions != 0 )  * ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0; hashp -> isfixed = ( ( bool ) 1 ); return hashp ; 