static void eepro100_write(void *opaque, hwaddr uint64_t data, unsigned size) EEPRO100State * s = opaque ; switch ( size )  eepro100_write4 ( s , addr , data ); static void eepro100_write4(EEPRO100State * s, uint32_t addr, uint32_t val) switch ( addr )  eepro100_write_mdi ( s ); static void eepro100_write_mdi(EEPRO100State *s) uint32_t val = e100_read_reg4 ( s , SCBCtrlMDI ) ; uint8_t opcode = ( val & BITS ( 27 , 26 ) ) >> 26 ; uint8_t phy = ( val & BITS ( 25 , 21 ) ) >> 21 ; uint8_t reg = ( val & BITS ( 20 , 16 ) ) >> 16 ; uint16_t data = ( val & BITS ( 15 , 0 ) ) ; if ( phy != 1 )  data = 0; if ( opcode != 1 && opcode != 2 )  data = 0; if ( reg > 6 )  data = 0; if ( opcode == 1 )  switch ( reg )  if ( data & 0x8000 )  s -> mdimem [ 0 ] = eepro100_mdi_default [ 0 ]; s -> mdimem [ 1 ] = eepro100_mdi_default [ 1 ]; data = s -> mdimem [ reg ]; data &= ~0x0200; s -> mdimem [ reg ] &= eepro100_mdi_mask [ reg ]; s -> mdimem [ reg ] |= data & ~eepro100_mdi_mask [ reg ]; if ( opcode == 2 )  switch ( reg )  if ( data & 0x8000 )  s -> mdimem [ 0 ] = eepro100_mdi_default [ 0 ]; s -> mdimem [ 1 ] = eepro100_mdi_default [ 1 ]; s -> mdimem [ reg ] |= 0x0020; s -> mdimem [ reg ] = 0x41fe; s -> mdimem [ reg ] = 0x0001; data = s -> mdimem [ reg ]; s -> mem [ SCBAck ] |= 0x08; val |= BIT ( 28 ); val = ( val & 0xffff0000 ) + data; e100_write_reg4 ( s , SCBCtrlMDI , val ); static void e100_write_reg4(EEPRO100State *s, E100RegisterOffset uint32_t val) assert ( ! ( ( uintptr_t ) & s -> mem [ addr ] & 3 ) ); 