void emem_tree_insert_string(emem_tree_t *se_tree,const gchar *k,void *v,guint32 flags) guint32 len = ( guint32 ) ( strlen ( k ) ) ; guint32 divx = ( len + 3 ) / 4 + 1 ; aligned = ( g_malloc ( divx * sizeof ( guint32 ) ) ); for (i = 0; i < len; i++) ch = ( ( unsigned char ) k [ i ] ); if ( ( * __ctype_b_loc ( ) ) [ ( int ) ch ] & ( ( unsigned short ) _ISupper ) )  ch = ( tolower ( ch ) ); tmp <<= 8; tmp |= ch; aligned [ i / 4 ] = tmp; if ( i % 4 != 0 )  while ( i % 4 != 0 )  i ++; tmp <<= 8; aligned [ i / 4 - 1 ] = tmp; aligned [ divx - 1 ] = 0x1; key [ 0 ] . length = divx; key [ 0 ] . key = aligned; key [ 1 ] . length = 0; key [ 1 ] . key = ( ( void * ) 0 ); emem_tree_insert32_array ( se_tree , key , v ); void emem_tree_insert32_array(emem_tree_t *se_tree,emem_tree_key_t *key,void *data) if ( ! se_tree || ! key )  for (cur_key = key; cur_key -> length > 0; cur_key++) if ( cur_key -> length > 100 )  for (i = 0; i < cur_key -> length; i++) if ( ! insert_tree )  insert_tree = se_tree; insert_tree = ( lookup_or_insert32 ( insert_tree , insert_key32 , create_sub_tree , se_tree , 1 ) ); static void *lookup_or_insert32(emem_tree_t *se_tree,guint32 key,void *(*func)(void *),void *ud,int is_subtree) node = se_tree -> tree; if ( ! node )  node = ( ( se_tree -> malloc ) ( sizeof ( emem_tree_node_t ) ) ); switch ( se_tree -> type )  node -> u . rb_color = 1; node -> parent = ( ( void * ) 0 ); node -> left = ( ( void * ) 0 ); node -> right = ( ( void * ) 0 ); node -> key32 = key; node -> data = func ( ud ); node -> u . is_subtree = is_subtree; se_tree -> tree = node; return node -> data ; if ( key == node -> key32 )  return node -> data ; if ( key < node -> key32 )  if ( ! node -> left )  new_node = ( ( se_tree -> malloc ) ( sizeof ( emem_tree_node_t ) ) ); node -> left = new_node; new_node -> parent = node; new_node -> left = ( ( void * ) 0 ); new_node -> right = ( ( void * ) 0 ); new_node -> key32 = key; new_node -> data = func ( ud ); new_node -> u . is_subtree = is_subtree; node = new_node; node = node -> left; if ( key > node -> key32 )  if ( ! node -> right )  new_node = ( ( se_tree -> malloc ) ( sizeof ( emem_tree_node_t ) ) ); node -> right = new_node; new_node -> parent = node; new_node -> left = ( ( void * ) 0 ); new_node -> right = ( ( void * ) 0 ); new_node -> key32 = key; new_node -> data = func ( ud ); new_node -> u . is_subtree = is_subtree; node = new_node; node = node -> right; switch ( se_tree -> type )  node -> u . rb_color = 0; rb_insert_case1 ( se_tree , node ); inline static void rb_insert_case1(emem_tree_t *se_tree,emem_tree_node_t *node) parent = emem_tree_parent ( node ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; if ( ! parent )  node -> u . rb_color = 1; rb_insert_case2 ( se_tree , node ); inline static void rb_insert_case2(emem_tree_t *se_tree,emem_tree_node_t *node) parent = emem_tree_parent ( node ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; if ( parent -> u . rb_color == 1 )  rb_insert_case3 ( se_tree , node ); inline static void rb_insert_case3(emem_tree_t *se_tree,emem_tree_node_t *node) uncle = emem_tree_uncle ( node ); inline static emem_tree_node_t *emem_tree_uncle(emem_tree_node_t *node) parent = emem_tree_parent ( node ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; if ( ! parent )  grandparent = emem_tree_parent ( parent ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; if ( ! grandparent )  if ( parent == grandparent -> left )  return grandparent -> right ; return grandparent -> left ; if ( uncle && uncle -> u . rb_color == 0 )  parent = emem_tree_parent ( node ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; parent -> u . rb_color = 1; uncle -> u . rb_color = 1; grandparent = emem_tree_grandparent ( node ); inline static emem_tree_node_t *emem_tree_grandparent(emem_tree_node_t *node) parent = emem_tree_parent ( node ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; if ( parent )  return parent -> parent ; grandparent -> u . rb_color = 0; rb_insert_case1 ( se_tree , grandparent ); inline static void rb_insert_case1(emem_tree_t *se_tree,emem_tree_node_t *node) parent = emem_tree_parent ( node ); if ( ! parent )  node -> u . rb_color = 1; rb_insert_case2 ( se_tree , node ); rb_insert_case4 ( se_tree , node ); inline static void rb_insert_case4(emem_tree_t *se_tree,emem_tree_node_t *node) parent = emem_tree_parent ( node ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; grandparent = emem_tree_parent ( parent ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; if ( ! grandparent )  if ( node == parent -> right && parent == grandparent -> left )  rotate_left ( se_tree , parent ); inline static void rotate_left(emem_tree_t *se_tree,emem_tree_node_t *node) if ( node -> parent )  if ( node -> parent -> left == node )  node -> parent -> left = node -> right; node -> parent -> right = node -> right; se_tree -> tree = node -> right; node -> right -> parent = node -> parent; node -> parent = node -> right; node -> right = node -> right -> left; if ( node -> right )  node -> right -> parent = node; node -> parent -> left = node; node = node -> left; if ( node == parent -> left && parent == grandparent -> right )  rotate_right ( se_tree , parent ); inline static void rotate_right(emem_tree_t *se_tree,emem_tree_node_t *node) if ( node -> parent )  if ( node -> parent -> left == node )  node -> parent -> left = node -> left; node -> parent -> right = node -> left; se_tree -> tree = node -> left; node -> left -> parent = node -> parent; node -> parent = node -> left; node -> left = node -> left -> right; if ( node -> left )  node -> left -> parent = node; node -> parent -> right = node; node = node -> right; rb_insert_case5 ( se_tree , node ); inline static void rb_insert_case5(emem_tree_t *se_tree,emem_tree_node_t *node) parent = emem_tree_parent ( node ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; grandparent = emem_tree_parent ( parent ); inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node) return node -> parent ; parent -> u . rb_color = 1; grandparent -> u . rb_color = 0; if ( node == parent -> left && parent == grandparent -> left )  rotate_right ( se_tree , grandparent ); inline static void rotate_right(emem_tree_t *se_tree,emem_tree_node_t *node) if ( node -> parent )  if ( node -> parent -> left == node )  node -> parent -> left = node -> left; node -> parent -> right = node -> left; se_tree -> tree = node -> left; node -> left -> parent = node -> parent; node -> parent = node -> left; node -> left = node -> left -> right; if ( node -> left )  node -> left -> parent = node; node -> parent -> right = node; rotate_left ( se_tree , grandparent ); inline static void rotate_left(emem_tree_t *se_tree,emem_tree_node_t *node) if ( node -> parent )  if ( node -> parent -> left == node )  node -> parent -> left = node -> right; node -> parent -> right = node -> right; se_tree -> tree = node -> right; node -> right -> parent = node -> parent; node -> parent = node -> right; node -> right = node -> right -> left; if ( node -> right )  node -> right -> parent = node; node -> parent -> left = node; return node -> data ; insert_key32 = cur_key -> key [ i ]; if ( ! insert_tree )  emem_tree_insert32 ( insert_tree , insert_key32 , data ); void emem_tree_insert32(emem_tree_t *se_tree,guint32 key,void *data) node = se_tree -> tree; if ( ! node )  node = ( ( se_tree -> malloc ) ( sizeof ( emem_tree_node_t ) ) ); switch ( se_tree -> type )  node -> u . rb_color = 1; node -> parent = ( ( void * ) 0 ); node -> left = ( ( void * ) 0 ); node -> right = ( ( void * ) 0 ); node -> key32 = key; node -> data = data; node -> u . is_subtree = 0; se_tree -> tree = node; if ( key == node -> key32 )  node -> data = data; if ( key < node -> key32 )  if ( ! node -> left )  new_node = ( ( se_tree -> malloc ) ( sizeof ( emem_tree_node_t ) ) ); node -> left = new_node; new_node -> parent = node; new_node -> left = ( ( void * ) 0 ); new_node -> right = ( ( void * ) 0 ); new_node -> key32 = key; new_node -> data = data; new_node -> u . is_subtree = 0; node = new_node; node = node -> left; if ( key > node -> key32 )  if ( ! node -> right )  new_node = ( ( se_tree -> malloc ) ( sizeof ( emem_tree_node_t ) ) ); node -> right = new_node; new_node -> parent = node; new_node -> left = ( ( void * ) 0 ); new_node -> right = ( ( void * ) 0 ); new_node -> key32 = key; new_node -> data = data; new_node -> u . is_subtree = 0; node = new_node; node = node -> right; switch ( se_tree -> type )  node -> u . rb_color = 0; rb_insert_case1 ( se_tree , node ); inline static void rb_insert_case1(emem_tree_t *se_tree,emem_tree_node_t *node) parent = emem_tree_parent ( node ); if ( ! parent )  node -> u . rb_color = 1; rb_insert_case2 ( se_tree , node ); g_free ( aligned ); 