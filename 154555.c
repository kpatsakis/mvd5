static struct dentry ffs_fs_mount(struct file_system_type *t, int const char *dev_name, void *opts) struct ffs_sb_fill_data data . perms . mode = S_IFREG | 0600 . uid = GLOBAL_ROOT_UID . gid = GLOBAL_ROOT_GID  . root_mode = S_IFDIR | 0500 . no_disconnect = false , int ret ; void * ffs_dev ; struct ffs_data * ffs ; ret = ffs_fs_parse_opts ( & data , opts ); static int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts) if ( ! opts || ! * opts )  return 0 ; unsigned long value ; char * eq , * comma ; comma = strchr ( opts , ',' ); eq = strchr ( opts , '=' ); if ( unlikely ( ! eq ) )  return - EINVAL ; * eq = 0; if ( kstrtoul ( eq + 1 , 0 , & value ) )  return - EINVAL ; switch ( eq - opts )  if ( ! memcmp ( opts , "no_disconnect" , 13 ) )  data -> no_disconnect = ! ! value; if ( ! memcmp ( opts , "rmode" , 5 ) )  data -> root_mode = ( value & 0555 ) | S_IFDIR; if ( ! memcmp ( opts , "fmode" , 5 ) )  data -> perms . mode = ( value & 0666 ) | S_IFREG; if ( ! memcmp ( opts , "mode" , 4 ) )  data -> root_mode = ( value & 0555 ) | S_IFDIR; data -> perms . mode = ( value & 0666 ) | S_IFREG; if ( ! memcmp ( opts , "uid" , 3 ) )  data -> perms . uid = make_kuid ( current_user_ns ( ) , value ); if ( ! uid_valid ( data -> perms . uid ) )  return - EINVAL ; if ( ! memcmp ( opts , "gid" , 3 ) )  data -> perms . gid = make_kgid ( current_user_ns ( ) , value ); if ( ! gid_valid ( data -> perms . gid ) )  return - EINVAL ; return - EINVAL ; if ( ! comma )  opts = comma + 1; return 0 ; if ( unlikely ( ret < 0 ) )  ffs = ffs_data_new ( ); static struct ffs_data *ffs_data_new(void) struct ffs_data * ffs = kzalloc ( sizeof * ffs , GFP_KERNEL ) ; if ( unlikely ( ! ffs ) )  return NULL ; ffs -> state = FFS_READ_DESCRIPTORS; ffs -> ev . can_stall = 1; return ffs ; if ( unlikely ( ! ffs ) )  ffs -> file_perms = data . perms; ffs -> no_disconnect = data . no_disconnect; ffs -> dev_name = kstrdup ( dev_name , GFP_KERNEL ); if ( unlikely ( ! ffs -> dev_name ) )  ffs_dev = ffs_acquire_dev ( dev_name ); static void *ffs_acquire_dev(const char *dev_name) struct ffs_dev * ffs_dev ; ffs_dev = _ffs_find_dev ( dev_name ); static struct ffs_dev *_ffs_find_dev(const char *name) struct ffs_dev * dev ; dev = _ffs_get_single_dev ( ); static struct ffs_dev *_ffs_get_single_dev(void) struct ffs_dev * dev ; if ( list_is_singular ( & ffs_devices ) )  dev = list_first_entry ( & ffs_devices , struct ffs_dev , entry ) if ( dev -> single )  return dev ; return NULL ; if ( dev )  return _ffs_do_find_dev ( name ) ; static struct ffs_dev *_ffs_do_find_dev(const char *name) struct ffs_dev * dev ; if ( strcmp ( dev -> name , name ) == 0 )  