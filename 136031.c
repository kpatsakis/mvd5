proto_tree ptvcursor_add_text_with_subtree(ptvcursor_t *ptvc, gint gint ett_subtree, const char *format, ...) proto_item * pi ; proto_tree * tree ; tree = ptvcursor_tree ( ptvc ); proto_tree ptvcursor_tree(ptvcursor_t *ptvc) if ( ! ptvc )  return NULL ; return ptvc -> tree ; pi = proto_tree_add_text_node ( tree , ptvcursor_tvbuff ( ptvc ) , ptvcursor_current_offset ( ptvc ) , length );  ptvcursor_current_offset(ptvcursor_t *ptvc) return ptvc -> offset ; tvbuff_t ptvcursor_tvbuff(ptvcursor_t *ptvc) return ptvc -> tvb ; static proto_item proto_tree_add_text_node(proto_tree *tree, tvbuff_t *tvb, gint start, gint length) proto_item * pi ; if ( tree == NULL )  return NULL ; pi = proto_tree_add_pi ( tree , & hfi_text_only , tvb , start , & length ); static proto_item proto_tree_add_pi(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb, gint gint *length) proto_item * pi ; field_info * fi ; gint item_length ; fi = new_field_info ( tree , hfinfo , tvb , start , item_length ); static field_info new_field_info(proto_tree *tree, header_field_info *hfinfo, tvbuff_t const gint start, const gint item_length) field_info * fi ; fi -> hfinfo = hfinfo; fi -> start = start; fi -> start += ( tvb ) ? tvb_raw_offset ( tvb ) : 0; fi -> length = item_length; fi -> tree_type = - 1; fi -> flags = 0; fi -> rep = NULL; fi -> ds_tvb = tvb ? tvb_get_ds_tvb ( tvb ) : NULL; fi -> appendix_start = 0; fi -> appendix_length = 0; return fi ; pi = proto_tree_add_node ( tree , fi ); static proto_item proto_tree_add_node(proto_tree *tree, field_info *fi) proto_node * pnode , * tnode , * sibling ; tnode = tree; pnode = wmem_new ( PNODE_POOL ( tree ) , proto_node ); pnode -> parent = tnode; pnode -> tree_data = PTREE_DATA ( tree ); return ( proto_item * ) pnode ; return pi ; return pi ; return ptvcursor_add_subtree_item ( ptvc , pi , ett_subtree , length ) ; static proto_tree ptvcursor_add_subtree_item(ptvcursor_t *ptvc, proto_item *it, gint ett_subtree, gint length) ptvcursor_push_subtree ( ptvc , it , ett_subtree ); proto_tree ptvcursor_push_subtree(ptvcursor_t *ptvc, proto_item *it, gint ett_subtree) if ( ptvc -> pushed_tree_index >= ptvc -> pushed_tree_max )  ptvcursor_new_subtree_levels ( ptvc ); static ptvcursor_new_subtree_levels(ptvcursor_t *ptvc) subtree_lvl * pushed_tree ; ptvc -> pushed_tree_max += SUBTREE_ONCE_ALLOCATION_NUMBER; pushed_tree = ( subtree_lvl * ) wmem_alloc ( wmem_packet_scope ( ) , sizeof ( subtree_lvl ) * ptvc -> pushed_tree_max ); if ( ptvc -> pushed_tree )  memcpy ( pushed_tree , ptvc -> pushed_tree , ptvc -> pushed_tree_max - SUBTREE_ONCE_ALLOCATION_NUMBER ); ptvc -> pushed_tree = pushed_tree; 