CharDriverState *qemu_chr_open(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) const char * p ; CharDriverState * chr ; if ( ! strcmp ( filename , "vc" ) )  if ( strstart ( filename , "vc:" , & p ) )  if ( ! strcmp ( filename , "null" ) )  if ( strstart ( filename , "tcp:" , & p ) )  chr = qemu_chr_open_tcp ( p , 0 , 0 ); static CharDriverState *qemu_chr_open_tcp(const char int int is_unix) int fd = - 1 , offset = 0 ; int is_listen = 0 ; int is_waitconnect = 1 ; int do_nodelay = 0 ; const char * ptr ; ptr = host_str; while ( ptr = strchr ( ptr , ',' ) )  ptr ++; if ( ! strncmp ( ptr , "server" , 6 ) )  is_listen = 1; if ( ! strncmp ( ptr , "nowait" , 6 ) )  is_waitconnect = 0; if ( ! strncmp ( ptr , "nodelay" , 6 ) )  do_nodelay = 1; if ( ! strncmp ( ptr , "to=" , 3 ) )  if ( ! strncmp ( ptr , "ipv4" , 4 ) )  if ( ! strncmp ( ptr , "ipv6" , 4 ) )  if ( ! is_listen )  is_waitconnect = 0; chr = qemu_mallocz ( sizeof ( CharDriverState ) ); s = qemu_mallocz ( sizeof ( TCPCharDriver ) ); if ( is_listen )  chr -> filename = qemu_malloc ( 256 ); offset = strlen ( chr -> filename ); if ( is_unix )  if ( is_listen )  fd = unix_listen ( host_str , chr -> filename + offset , 256 - offset ); fd = unix_connect ( host_str ); if ( is_listen )  fd = inet_listen ( host_str , chr -> filename + offset , 256 - offset , SOCK_STREAM , 0 ); fd = inet_connect ( host_str , SOCK_STREAM ); if ( fd < 0 )  s -> connected = 0; s -> fd = - 1; s -> listen_fd = - 1; s -> msgfd = - 1; s -> is_unix = is_unix; s -> do_nodelay = do_nodelay && ! is_unix; chr -> opaque = s; chr -> chr_write = tcp_chr_write; chr -> chr_close = tcp_chr_close; chr -> get_msgfd = tcp_get_msgfd; if ( is_listen && is_waitconnect )  tcp_chr_accept ( chr ); static void tcp_chr_accept(void *opaque) CharDriverState * chr = opaque ; TCPCharDriver * s = chr -> opaque ; struct sockaddr * addr ; socklen_t len ; int fd ; if ( s -> is_unix )  len = sizeof ( uaddr ); addr = ( struct sockaddr * ) & uaddr; len = sizeof ( saddr ); addr = ( struct sockaddr * ) & saddr; fd = accept ( s -> listen_fd , addr , & len ); if ( fd < 0 && errno != EINTR )  if ( fd >= 0 )  if ( s -> do_telnetopt )  tcp_chr_telnet_init ( fd ); static void tcp_chr_telnet_init(int fd) char buf [ 3 ] ; send ( fd , ( char * ) buf , 3 , 0 ); 