 WebGLContext::ReadPixels(GLint x, GLint y, GLsizei GLsizei height, GLenum GLenum type, const Nullable<ArrayBufferView> ErrorResult& rv) if ( IsContextLost ( ) )  if ( mCanvasElement -> IsWriteOnly ( ) && ! nsContentUtils :: IsCallerChrome ( ) )  if ( width < 0 || height < 0 )  if ( pixels . IsNull ( ) )  const WebGLRectangleObject * framebufferRect = CurValidFBRectObject ( ) ; GLsizei framebufferWidth = framebufferRect ? framebufferRect -> Width ( ) : 0 ; GLsizei framebufferHeight = framebufferRect ? framebufferRect -> Height ( ) : 0 ; switch ( format )  channels = 1; channels = 3; channels = 4; uint32_t bytesPerPixel = 0 ; int requiredDataType = 0 ; bool isReadTypeValid = false ; bool isReadTypeFloat = false ; switch ( type )  isReadTypeValid = true; bytesPerPixel = 1 * channels; requiredDataType = js :: Scalar :: Uint8; isReadTypeValid = true; bytesPerPixel = 2; requiredDataType = js :: Scalar :: Uint16; if ( IsExtensionEnabled ( WebGLExtensionID :: WEBGL_color_buffer_float ) || IsExtensionEnabled ( WebGLExtensionID :: EXT_color_buffer_half_float ) )  isReadTypeValid = true; isReadTypeFloat = true; bytesPerPixel = 4 * channels; requiredDataType = js :: Scalar :: Float32; if ( ! isReadTypeValid )  const ArrayBufferView & pixbuf = pixels . Value ( ) ; int dataType = JS_GetArrayBufferViewType ( pixbuf . Obj ( ) ) ; if ( dataType != requiredDataType )  CheckedUint32 checked_neededByteLength = GetImageSize ( height , width , bytesPerPixel , mPixelStorePackAlignment ) ; CheckedUint32 checked_plainRowSize = CheckedUint32 ( width ) * bytesPerPixel ; CheckedUint32 checked_alignedRowSize = RoundedToNextMultipleOf ( checked_plainRowSize , mPixelStorePackAlignment ) ; if ( ! checked_neededByteLength . isValid ( ) )  uint32_t dataByteLen = pixbuf . Length ( ) ; if ( checked_neededByteLength . value ( ) > dataByteLen )  void * data = pixbuf . Data ( ) ; if ( ! data )  bool isSourceTypeFloat = false ; if ( mBoundFramebuffer && mBoundFramebuffer -> ColorAttachmentCount ( ) && mBoundFramebuffer -> ColorAttachment ( 0 ) . IsDefined ( ) )  isSourceTypeFloat = mBoundFramebuffer -> ColorAttachment ( 0 ) . IsReadableFloat ( ); if ( isReadTypeFloat != isSourceTypeFloat )  if ( mBoundFramebuffer )  if ( ! mBoundFramebuffer -> CheckAndInitializeAttachments ( ) )  bool isFormatAndTypeValid = false ; if ( gl -> IsSupported ( gl :: GLFeature :: ES2_compatibility ) )  GLenum implType = 0 ; GLenum implFormat = 0 ; if ( type == implType && format == implFormat )  isFormatAndTypeValid = true; switch ( format )  switch ( type )  isFormatAndTypeValid = true; if ( ! isFormatAndTypeValid )  if ( width == 0 || height == 0 )  if ( CanvasUtils :: CheckSaneSubrectSize ( x , y , width , height , framebufferWidth , framebufferHeight ) )  if ( x >= framebufferWidth || x + width <= 0 || y >= framebufferHeight || y + height <= 0 )  GLint subrect_x = std :: max ( x , 0 ) ; GLint subrect_end_x = std :: min ( x + width , framebufferWidth ) ; GLsizei subrect_width = subrect_end_x - subrect_x ; GLint subrect_y = std :: max ( y , 0 ) ; GLint subrect_end_y = std :: min ( y + height , framebufferHeight ) ; GLsizei subrect_height = subrect_end_y - subrect_y ; if ( subrect_width < 0 || subrect_height < 0 || subrect_width > width || subrect_height > height )  if ( ! subrect_data )  if ( format == LOCAL_GL_ALPHA || format == LOCAL_GL_RGBA )  bool needAlphaFixup ; if ( mBoundFramebuffer )  needAlphaFixup = ! mBoundFramebuffer -> ColorAttachment ( 0 ) . HasAlpha ( ); needAlphaFixup = gl -> GetPixelFormat ( ) . alpha == 0; if ( needAlphaFixup )  if ( format == LOCAL_GL_ALPHA && type == LOCAL_GL_UNSIGNED_BYTE )  uint8_t * row = static_cast < uint8_t * > data for (GLint j = 0; j < height; ++j) memset ( row , 0xff , checked_plainRowSize . value ( ) ); row += checked_alignedRowSize . value ( ); uint8_t * rowp = row ; rowp += 3; uint8_t * endrowp = rowp + 4 * width ; while ( rowp != endrowp )  * rowp = 0xff; rowp += 4; row += checked_alignedRowSize . value ( ); float * pAlpha = row + 3 ; float * pAlphaEnd = pAlpha + 4 * width ; while ( pAlpha != pAlphaEnd )  * pAlpha = 1.0f; pAlpha += 4; row += checked_alignedRowSize . value ( ); 