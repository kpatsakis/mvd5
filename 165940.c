static brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device struct cfg80211_ap_settings *settings) s32 ie_offset ; struct brcmf_if * ifp = netdev_priv ( ndev ) ; const struct brcmf_tlv * ssid_ie ; const struct brcmf_tlv * rsn_ie ; const struct brcmf_vs_tlv * wpa_ie ; if ( settings -> ssid == NULL || settings -> ssid_len == 0 )  ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID ); const struct brcmf_tlv brcmf_parse_tlvs(const void *buf, int buflen, uint key) const struct brcmf_tlv * elt = buf ; int totlen = buflen ; while ( totlen >= TLV_HDR_LEN )  int len = elt -> len ; if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )  return elt ; elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) ); totlen -= ( len + TLV_HDR_LEN ); return NULL ; if ( ! ssid_ie )  rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN ); const struct brcmf_tlv brcmf_parse_tlvs(const void *buf, int buflen, uint key) const struct brcmf_tlv * elt = buf ; int totlen = buflen ; while ( totlen >= TLV_HDR_LEN )  int len = elt -> len ; if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )  return elt ; elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) ); totlen -= ( len + TLV_HDR_LEN ); return NULL ; wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len ); static struct brcmf_vs_tlv brcmf_find_wpaie(const u8 *parse, u32 len) const struct brcmf_tlv * ie ; while ( ie = brcmf_parse_tlvs ( parse , len , WLAN_EID_VENDOR_SPECIFIC ) )  const struct brcmf_tlv brcmf_parse_tlvs(const void *buf, int buflen, uint key) const struct brcmf_tlv * elt = buf ; int totlen = buflen ; while ( totlen >= TLV_HDR_LEN )  int len = elt -> len ; if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )  return elt ; elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) ); totlen -= ( len + TLV_HDR_LEN ); return NULL ; if ( brcmf_tlv_has_ie ( ( const u8 * ) ie , & parse , & len , WPA_OUI , TLV_OUI_LEN , WPA_OUI_TYPE ) )  static brcmf_tlv_has_ie(const u8 *ie, const u8 **tlvs, u32 const u8 *oui, u32 oui_len, u8 type) if ( ie [ TLV_LEN_OFF ] >= oui_len + 1 && ! memcmp ( & ie [ TLV_BODY_OFF ] , oui , oui_len ) && type == ie [ TLV_BODY_OFF + oui_len ] )  return true ; if ( tlvs == NULL )  return false ; return false ; return ( struct brcmf_vs_tlv * ) ie ; return NULL ; if ( wpa_ie != NULL || rsn_ie != NULL )  if ( wpa_ie != NULL )  struct brcmf_vs_tlv * tmp_ie ; tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie; err = brcmf_configure_wpaie ( ifp , tmp_ie , true ); static brcmf_configure_wpaie(struct brcmf_if const struct brcmf_vs_tlv bool is_rsn_ie) u16 count ; s32 len ; u32 i ; u32 offset ; u8 * data ; if ( wpa_ie == NULL )  len = wpa_ie -> len + TLV_HDR_LEN; data = ( u8 * ) wpa_ie; offset = TLV_HDR_LEN; if ( ! is_rsn_ie )  offset += VS_IE_FIXED_HDR_LEN; offset += WPA_IE_VERSION_LEN; if ( offset + WPA_IE_MIN_OUI_LEN > len )  if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  offset += TLV_OUI_LEN; switch ( data [ offset ] )  offset ++; count = data [ offset ] + ( data [ offset + 1 ] << 8 ); offset += WPA_IE_SUITE_COUNT_LEN; if ( offset + ( WPA_IE_MIN_OUI_LEN * count ) > len )  for (i = 0; i < count; i++) if ( ! brcmf_valid_wpa_oui ( & data [ offset ] , is_rsn_ie ) )  offset += TLV_OUI_LEN; offset ++; static bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie) if ( is_rsn_ie )  return ( memcmp ( oui , RSN_OUI , TLV_OUI_LEN ) == 0 ) ; 