static void md_common_write(void *opaque, uint32_t at, uint16_t value) struct md_s * s = ( struct md_s * ) opaque ; at -= s -> io_base; switch ( s -> opt & OPT_MODE )  if ( ( at & ~0x3ff ) == 0x400 )  at = 0; at &= 0xf; if ( ( at & ~0xf ) == 0x3f0 )  at -= 0x3e8; if ( ( at & ~0xf ) == 0x1f0 )  at -= 0x1f0; if ( ( at & ~0xf ) == 0x370 )  at -= 0x368; if ( ( at & ~0xf ) == 0x170 )  at -= 0x170; switch ( at )  if ( s -> cycle )  s -> io = value & 0xff; s -> cycle = ! s -> cycle; s -> io = value & 0xff; s -> cycle = ! s -> cycle; ide_ioport_write ( s -> ide , 0x1 , value ); static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val) IDEState * ide_if = opaque ; IDEState * s ; int unit , n ; addr &= 7; if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )  switch ( addr )  ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature; ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature; ide_if [ 0 ] . feature = val; ide_if [ 1 ] . feature = val; ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector; ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector; ide_if [ 0 ] . nsector = val; ide_if [ 1 ] . nsector = val; ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector; ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector; ide_if [ 0 ] . sector = val; ide_if [ 1 ] . sector = val; ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl; ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl; ide_if [ 0 ] . lcyl = val; ide_if [ 1 ] . lcyl = val; ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl; ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl; ide_if [ 0 ] . hcyl = val; ide_if [ 1 ] . hcyl = val; ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0; ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0; unit = ( val >> 4 ) & 1; s = ide_if + unit; ide_if -> cur_drive = s; s = ide_if -> cur_drive; if ( ! s -> bs )  if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )  switch ( val )  if ( s -> bs && ! s -> is_cdrom )  if ( ! s -> is_cf )  ide_identify ( s ); static void ide_identify(IDEState *s) if ( s -> identify_set )  memset ( s -> io_buffer , 0 , 512 ); p = ( uint16_t * ) s -> io_buffer; put_le16 ( p + 0 , 0x0040 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 1 , s -> cylinders ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 3 , s -> heads ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 4 , 512 * s -> sectors ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 5 , 512 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 6 , s -> sectors ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); padstr ( ( char * ) ( p + 10 ) , s -> drive_serial_str , 20 ); static void padstr(char *str, const char *src, int len) for(i = 0; i < len; i++) if ( * src )  v = * src ++; str [ i ^ 1 ] = v; put_le16 ( p + 20 , 3 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 21 , 512 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 22 , 4 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); padstr ( ( char * ) ( p + 23 ) , QEMU_VERSION , 8 ); static void padstr(char *str, const char *src, int len) if ( * src )  v = * src ++; str [ i ^ 1 ] = v; padstr ( ( char * ) ( p + 27 ) , "QEMU HARDDISK" , 40 ); static void padstr(char *str, const char *src, int len) if ( * src )  v = * src ++; str [ i ^ 1 ] = v; put_le16 ( p + 47 , 0x8000 | MAX_MULT_SECTORS ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 48 , 1 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 49 , ( 1 << 11 ) | ( 1 << 9 ) | ( 1 << 8 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 51 , 0x200 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 52 , 0x200 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 53 , 1 | ( 1 << 1 ) | ( 1 << 2 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 54 , s -> cylinders ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 55 , s -> heads ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 56 , s -> sectors ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); oldsize = s -> cylinders * s -> heads * s -> sectors; put_le16 ( p + 57 , oldsize ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 58 , oldsize >> 16 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); if ( s -> mult_sectors )  put_le16 ( p + 59 , 0x100 | s -> mult_sectors ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 60 , s -> nb_sectors ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 61 , s -> nb_sectors >> 16 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 62 , 0x07 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 63 , 0x07 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 65 , 120 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 66 , 120 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 67 , 120 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 68 , 120 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 80 , 0xf0 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 81 , 0x16 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 82 , ( 1 << 14 ) | ( 1 << 5 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 83 , ( 1 << 14 ) | ( 1 << 13 ) | ( 1 << 12 ) | ( 1 << 10 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 84 , ( 1 << 14 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 85 , ( 1 << 14 ) | ( s -> write_cache << 5 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 86 , ( 1 << 14 ) | ( 1 << 13 ) | ( 1 << 12 ) | ( 1 << 10 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 87 , ( 1 << 14 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 88 , 0x3f | ( 1 << 13 ) ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 93 , 1 | ( 1 << 14 ) | 0x2000 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 100 , s -> nb_sectors ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 101 , s -> nb_sectors >> 16 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 102 , s -> nb_sectors >> 32 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 103 , s -> nb_sectors >> 48 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); memcpy ( s -> identify_data , p , sizeof ( s -> identify_data ) ); s -> identify_set = 1; 