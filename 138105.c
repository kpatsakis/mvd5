static void sctp_v4_get_dst(struct sctp_transport *t, union sctp_addr struct flowi *fl, struct sock *sk) struct flowi4 * fl4 = & fl -> u . ip4 ; memset ( fl4 , 0x0 , sizeof ( struct flowi4 ) ); fl4 -> daddr = daddr -> v4 . sin_addr . s_addr; fl4 -> fl4_dport = daddr -> v4 . sin_port; fl4 -> flowi4_proto = IPPROTO_SCTP; fl4 -> flowi4_tos = RT_CONN_FLAGS ( asoc -> base . sk ); fl4 -> flowi4_oif = asoc -> base . sk -> sk_bound_dev_if; fl4 -> fl4_sport = htons ( asoc -> base . bind_addr . port ); fl4 -> saddr = saddr -> v4 . sin_addr . s_addr; fl4 -> fl4_sport = saddr -> v4 . sin_port; pr_debug ( "%s: dst:%pI4, src:%pI4 - " , __func__ , & fl4 -> daddr , & fl4 -> saddr ); rt = ip_route_output_key ( sock_net ( sk ) , fl4 ); if ( ! IS_ERR ( rt ) )  dst = & rt -> dst; if ( dst )  sctp_v4_dst_saddr ( & dst_saddr , fl4 , htons ( bp -> port ) ); static void sctp_v4_dst_saddr(union sctp_addr *saddr, struct flowi4 __be16 port) saddr -> v4 . sin_family = AF_INET; saddr -> v4 . sin_port = port; saddr -> v4 . sin_addr . s_addr = fl4 -> saddr; dst_release ( dst ); fl4 -> fl4_sport = laddr -> a . v4 . sin_port; flowi4_update_output ( fl4 , asoc -> base . sk -> sk_bound_dev_if , RT_CONN_FLAGS ( asoc -> base . sk ) , daddr -> v4 . sin_addr . s_addr , laddr -> a . v4 . sin_addr . s_addr ); rt = ip_route_output_key ( sock_net ( sk ) , fl4 ); if ( ! IS_ERR ( rt ) )  dst = & rt -> dst; t -> dst = dst; if ( dst )  pr_debug ( "rt_dst:%pI4, rt_src:%pI4\n" , & fl4 -> daddr , & fl4 -> saddr ); 