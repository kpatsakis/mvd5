static enum appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool const char *ptr, const char STRING_POOL *pool) DTD * const dtd = _dtd const char * next ; int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ; switch ( tok )  XML_Char buf [ XML_ENCODE_MAX ] ; int i ; int n = XmlCharRefNumber ( enc , ptr ) ; if ( n < 0 )  if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )  n = XmlEncode ( n , ( ICHAR * ) buf ); if ( ! n )  for (i = 0; i < n; i++) if ( ! poolAppendChar ( pool , buf [ i ] ) )  if ( ! poolAppend ( pool , enc , ptr , next ) )  static XML_Char poolAppend(STRING_POOL *pool, const ENCODING const char *ptr, const char *end) if ( ! pool -> ptr && ! poolGrow ( pool ) )  return NULL ; if ( ptr == end )  if ( ! poolGrow ( pool ) )  return NULL ; return pool -> start ; next = ptr + enc -> minBytesPerChar; if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )  if ( ! poolAppendChar ( pool , 0x20 ) )  const XML_Char * name ; ENTITY * entity ; char checkEntityDecl ; XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ; if ( ch )  if ( ! poolAppendChar ( pool , ch ) )  name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ); static XML_Char poolStoreString(STRING_POOL *pool, const ENCODING const char *ptr, const char *end) if ( ! poolAppend ( pool , enc , ptr , end ) )  return NULL ; if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )  return NULL ; * ( pool -> ptr ) ++ = 0; return pool -> start ; if ( ! name )  entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 ); if ( pool == & dtd -> pool )  checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone; if ( checkEntityDecl )  if ( ! entity )  if ( ! entity -> is_internal )  if ( ! entity )  if ( entity -> open )  if ( entity -> notation )  if ( ! entity -> textPtr )  enum XML_Error result ; const XML_Char * textEnd = entity -> textPtr + entity -> textLen ; entity -> open = XML_TRUE; result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool ); entity -> open = XML_FALSE; if ( result )  ptr = next; static enum appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool const char *ptr, const char STRING_POOL *pool) DTD * const dtd = _dtd const char * next ; int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ; switch ( tok )  XML_Char buf [ XML_ENCODE_MAX ] ; int i ; int n = XmlCharRefNumber ( enc , ptr ) ; if ( n < 0 )  if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )  n = XmlEncode ( n , ( ICHAR * ) buf ); if ( ! n )  if ( ! poolAppendChar ( pool , buf [ i ] ) )  if ( ! poolAppend ( pool , enc , ptr , next ) )  next = ptr + enc -> minBytesPerChar; if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )  if ( ! poolAppendChar ( pool , 0x20 ) )  const XML_Char * name ; ENTITY * entity ; char checkEntityDecl ; XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ; if ( ch )  if ( ! poolAppendChar ( pool , ch ) )  name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ); if ( ! name )  entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 ); if ( pool == & dtd -> pool )  checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone; if ( checkEntityDecl )  if ( ! entity )  if ( ! entity -> is_internal )  if ( ! entity )  if ( entity -> open )  if ( entity -> notation )  if ( ! entity -> textPtr )  enum XML_Error result ; const XML_Char * textEnd = entity -> textPtr + entity -> textLen ; entity -> open = XML_TRUE; result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool ); entity -> open = XML_FALSE; if ( result )  ptr = next; static enum appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool const char *ptr, const char STRING_POOL *pool) DTD * const dtd = _dtd const char * next ; int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ; switch ( tok )  XML_Char buf [ XML_ENCODE_MAX ] ; int i ; int n = XmlCharRefNumber ( enc , ptr ) ; if ( n < 0 )  if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )  n = XmlEncode ( n , ( ICHAR * ) buf ); if ( ! n )  if ( ! poolAppendChar ( pool , buf [ i ] ) )  if ( ! poolAppend ( pool , enc , ptr , next ) )  next = ptr + enc -> minBytesPerChar; if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )  if ( ! poolAppendChar ( pool , 0x20 ) )  const XML_Char * name ; ENTITY * entity ; char checkEntityDecl ; XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ; if ( ch )  if ( ! poolAppendChar ( pool , ch ) )  name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ); if ( ! name )  entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 ); if ( pool == & dtd -> pool )  checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone; if ( checkEntityDecl )  if ( ! entity )  if ( ! entity -> is_internal )  if ( ! entity )  if ( entity -> open )  if ( entity -> notation )  if ( ! entity -> textPtr )  enum XML_Error result ; const XML_Char * textEnd = entity -> textPtr + entity -> textLen ; entity -> open = XML_TRUE; result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool ); entity -> open = XML_FALSE; if ( result )  ptr = next; static NAMED lookup(HASH_TABLE *table, KEY name, size_t createSize) size_t i ; if ( table -> size == 0 )  unsigned long h = hash ( name ) ; unsigned long mask = ( unsigned long ) table -> size - 1 ; unsigned char step = 0 ; i = h & mask; while ( table -> v [ i ] )  if ( keyeq ( name , table -> v [ i ] -> name ) )  if ( ! step )  step = PROBE_STEP ( h , mask , table -> power ); i < step ? ( i += table -> size - step ) : ( i -= step ); if ( ! createSize )  if ( table -> used >> ( table -> power - 1 ) )  unsigned char newPower = table -> power + 1 ; size_t newSize = ( size_t ) 1 << newPower ; size_t tsize = newSize * sizeof ( NAMED * ) ; NAMED * * newV = ( NAMED * * ) table -> mem -> malloc_fcn ( tsize ) ; if ( ! newV )  memset ( newV , 0 , tsize ); while ( newV [ j ] )  newV [ j ] = table -> v [ i ]; table -> v = newV; table -> power = newPower; table -> size = newSize; while ( table -> v [ i ] )  table -> v [ i ] = ( NAMED * ) table -> mem -> malloc_fcn ( createSize ); if ( ! table -> v [ i ] )  memset ( table -> v [ i ] , 0 , createSize ); table -> v [ i ] -> name = name; ( table -> used ) ++; return table -> v [ i ] ; 