static void arcmsr_done4abort_postqueue(struct AdapterControlBlock *acb) int i = 0 ; uint32_t flag_ccb , ccb_cdb_phy ; struct ARCMSR_CDB * pARCMSR_CDB ; bool error ; struct CommandControlBlock * pCCB ; switch ( acb -> adapter_type )  struct MessageUnit_A __iomem * reg = acb -> pmuA ; while ( ( ( flag_ccb = readl ( & reg -> outbound_queueport ) ) != 0xFFFFFFFF ) && ( i ++ < ARCMSR_MAX_OUTSTANDING_CMD ) )  pARCMSR_CDB = ( struct ARCMSR_CDB * ) ( acb -> vir2phy_offset + ( flag_ccb << 5 ) ); pCCB = container_of ( pARCMSR_CDB , struct CommandControlBlock , arcmsr_cdb ) error = ( flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0 ) ? true : false; struct MessageUnit_B * reg = acb -> pmuB ; for (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++) flag_ccb = reg -> done_qbuffer [ i ]; if ( flag_ccb != 0 )  reg -> done_qbuffer [ i ] = 0; pARCMSR_CDB = ( struct ARCMSR_CDB * ) ( acb -> vir2phy_offset + ( flag_ccb << 5 ) ); pCCB = container_of ( pARCMSR_CDB , struct CommandControlBlock , arcmsr_cdb ) error = ( flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE0 ) ? true : false; reg -> post_qbuffer [ i ] = 0; reg -> doneq_index = 0; reg -> postq_index = 0; struct MessageUnit_C __iomem * reg = acb -> pmuC ; while ( ( readl ( & reg -> host_int_status ) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR ) && ( i ++ < ARCMSR_MAX_OUTSTANDING_CMD ) )  flag_ccb = readl ( & reg -> outbound_queueport_low ); ccb_cdb_phy = ( flag_ccb & 0xFFFFFFF0 ); pARCMSR_CDB = ( struct ARCMSR_CDB * ) ( acb -> vir2phy_offset + ccb_cdb_phy ); pCCB = container_of ( pARCMSR_CDB , struct CommandControlBlock , arcmsr_cdb ) error = ( flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1 ) ? true : false; struct MessageUnit_D * pmu = acb -> pmuD ; uint32_t outbound_write_pointer ; uint32_t doneq_index , index_stripped , addressLow , residual , toggle ; residual = atomic_read ( & acb -> ccboutstandingcount ); for (i = 0; i < residual; i++) outbound_write_pointer = pmu -> done_qbuffer [ 0 ] . addressLow + 1; doneq_index = pmu -> doneq_index; if ( ( doneq_index & 0xFFF ) != ( outbound_write_pointer & 0xFFF ) )  toggle = doneq_index & 0x4000; index_stripped = ( doneq_index & 0xFFF ) + 1; index_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE; pmu -> doneq_index = index_stripped ? ( index_stripped | toggle ) : ( ( toggle ^ 0x4000 ) + 1 ); doneq_index = pmu -> doneq_index; addressLow = pmu -> done_qbuffer [ doneq_index & 0xFFF ] . addressLow; ccb_cdb_phy = ( addressLow & 0xFFFFFFF0 ); pARCMSR_CDB = ( struct ARCMSR_CDB * ) ( acb -> vir2phy_offset + ccb_cdb_phy ); pCCB = container_of ( pARCMSR_CDB struct CommandControlBlock , arcmsr_cdb ) error = ( addressLow & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1 ) ? true : false; arcmsr_drain_donequeue ( acb , pCCB , error ); static void arcmsr_drain_donequeue(struct AdapterControlBlock *acb, struct CommandControlBlock *pCCB, bool error) if ( ( pCCB -> acb != acb ) || ( pCCB -> startdone != ARCMSR_CCB_START ) )  if ( pCCB -> startdone == ARCMSR_CCB_ABORTED )  printk ( KERN_NOTICE "arcmsr%d: isr get an illegal ccb command \\n\t\t\t\tdone acb = '0x%p'" arcmsr_report_ccb_state ( acb , pCCB , error ); static void arcmsr_report_ccb_state(struct AdapterControlBlock struct CommandControlBlock *ccb, bool error) if ( ! error )  switch ( ccb -> arcmsr_cdb . DeviceStatus )  ccb -> pcmd -> result = DID_BAD_TARGET << 16; arcmsr_report_sense_info ( ccb ); static void arcmsr_report_sense_info(struct CommandControlBlock *ccb) struct scsi_cmnd * pcmd = ccb -> pcmd ; struct SENSE_DATA * sensebuffer = ( struct SENSE_DATA * ) pcmd -> sense_buffer ; if ( sensebuffer )  memset ( sensebuffer , 0 , SCSI_SENSE_BUFFERSIZE ); memcpy ( sensebuffer , ccb -> arcmsr_cdb . SenseData , sense_data_length ); sensebuffer -> ErrorCode = SCSI_SENSE_CURRENT_ERRORS; sensebuffer -> Valid = 1; 