static int usb_xhci_post_load(void *opaque, int version_id) XHCIState * xhci = opaque ; PCIDevice * pci_dev = PCI_DEVICE ( xhci ) ; XHCISlot * slot ; dma_addr_t dcbaap , pctx ; uint32_t slot_ctx [ 4 ] ; int slotid , epid , state , intr ; dcbaap = xhci_addr64 ( xhci -> dcbaap_low , xhci -> dcbaap_high ); static inline dma_addr_t xhci_addr64(uint32_t low, uint32_t high) if ( sizeof ( dma_addr_t ) == 4 )  return low ; return low | ( ( ( dma_addr_t ) high << 16 ) << 16 ) ; for (slotid = 1; slotid <= xhci->numslots; slotid++) slot = & xhci -> slots [ slotid - 1 ]; if ( ! slot -> addressed )  slot -> ctx = xhci_mask64 ( ldq_le_pci_dma ( pci_dev , dcbaap + 8 * slotid ) ); static inline dma_addr_t xhci_mask64(uint64_t addr) if ( sizeof ( dma_addr_t ) == 4 )  return addr & 0xffffffff ; return addr ; slot -> uport = xhci_lookup_uport ( xhci , slot_ctx ); if ( ! slot -> uport )  slot -> enabled = 0; slot -> addressed = 0; static USBPort *xhci_lookup_uport(XHCIState *xhci, uint32_t *slot_ctx) char path [ 32 ] ; int i , pos , port ; port = ( slot_ctx [ 1 ] >> 16 ) & 0xFF; if ( port < 1 || port > xhci -> numports )  port = xhci -> ports [ port - 1 ] . uport -> index + 1; pos = snprintf ( path , sizeof ( path ) , "%d" , port ); for (i = 0; i < 5; i++) port = ( slot_ctx [ 0 ] >> 4 * i ) & 0x0f; if ( ! port )  pos += snprintf ( path + pos , sizeof ( path ) - pos , ".%d" , port ); 