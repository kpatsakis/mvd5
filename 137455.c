void vncws_handshake_read(void *opaque) VncState * vs = opaque ; uint8_t * handshake_end ; long ret ; size_t want = 4096 - vs -> ws_input . offset ; ret = vnc_client_read_buf ( vs , buffer_end ( & vs -> ws_input ) , want ); if ( ! ret )  vs -> ws_input . offset += ret; handshake_end = ( uint8_t * ) g_strstr_len ( ( char * ) vs -> ws_input . buffer , vs -> ws_input . offset , WS_HANDSHAKE_END ); if ( handshake_end )  vncws_process_handshake ( vs , vs -> ws_input . buffer , vs -> ws_input . offset ); void vncws_process_handshake(VncState *vs, uint8_t *line, size_t size) char * protocols = vncws_extract_handshake_entry ( ( const char * ) line , size , "Sec-WebSocket-Protocol" ) ; static char *vncws_extract_handshake_entry(const char size_t handshake_len, const char *name) char * begin , * end , * ret = NULL ; char * line = g_strdup_printf ( "%s%s: " , WS_HANDSHAKE_DELIM , name ) ; begin = g_strstr_len ( handshake , handshake_len , line ); if ( begin != NULL )  begin += strlen ( line ); end = g_strstr_len ( begin , handshake_len - ( begin - handshake ) , WS_HANDSHAKE_DELIM ); if ( end != NULL )  ret = g_strndup ( begin , end - begin ); return ret ; char * version = vncws_extract_handshake_entry ( ( const char * ) line , size , "Sec-WebSocket-Version" ) ; static char *vncws_extract_handshake_entry(const char size_t handshake_len, const char *name) char * begin , * end , * ret = NULL ; char * line = g_strdup_printf ( "%s%s: " , WS_HANDSHAKE_DELIM , name ) ; begin = g_strstr_len ( handshake , handshake_len , line ); if ( begin != NULL )  begin += strlen ( line ); end = g_strstr_len ( begin , handshake_len - ( begin - handshake ) , WS_HANDSHAKE_DELIM ); if ( end != NULL )  ret = g_strndup ( begin , end - begin ); return ret ; char * key = vncws_extract_handshake_entry ( ( const char * ) line , size , "Sec-WebSocket-Key" ) ; static char *vncws_extract_handshake_entry(const char size_t handshake_len, const char *name) char * begin , * end , * ret = NULL ; char * line = g_strdup_printf ( "%s%s: " , WS_HANDSHAKE_DELIM , name ) ; begin = g_strstr_len ( handshake , handshake_len , line ); if ( begin != NULL )  begin += strlen ( line ); end = g_strstr_len ( begin , handshake_len - ( begin - handshake ) , WS_HANDSHAKE_DELIM ); if ( end != NULL )  ret = g_strndup ( begin , end - begin ); return ret ; if ( protocols && version && key && g_strrstr ( protocols , "binary" ) && ! strcmp ( version , WS_SUPPORTED_VERSION ) && strlen ( key ) == WS_CLIENT_KEY_LEN )  vncws_send_handshake_response ( vs , key ); static void vncws_send_handshake_response(VncState *vs, const char* key) char combined_key [ WS_CLIENT_KEY_LEN + WS_GUID_LEN + 1 ] ; unsigned char hash [ SHA1_DIGEST_LEN ] ; size_t hash_size = sizeof ( hash ) ; char * accept = NULL , * response = NULL ; gnutls_datum_t in ; int ret ; in . data = ( void * ) combined_key; in . size = WS_CLIENT_KEY_LEN + WS_GUID_LEN; ret = gnutls_fingerprint ( GNUTLS_DIG_SHA1 , & in , hash , & hash_size ); if ( ret == GNUTLS_E_SUCCESS && hash_size <= SHA1_DIGEST_LEN )  accept = g_base64_encode ( hash , hash_size ); if ( accept == NULL )  response = g_strdup_printf ( WS_HANDSHAKE , accept ); vnc_client_write_buf ( vs , ( const uint8_t * ) response , strlen ( response ) ); 