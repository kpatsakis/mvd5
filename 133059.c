static void backend_read_statsfile() TimestampTz cur_ts ; TimestampTz min_ts ; int count ; if ( pgStatDBHash )  cur_ts = GetCurrentTimestamp ( ); if ( IsAutoVacuumWorkerProcess ( ) )  min_ts = cur_ts + ( - 10 ) * ( ( int64 ) 1000 ); min_ts = cur_ts + ( - 500 ) * ( ( int64 ) 1000 ); for (count = 0; count < 10000 / 10; count++) TimestampTz file_ts = 0 ; if ( pgstat_read_statsfile_timestamp ( ( ( bool ) 0 ) , & file_ts ) && file_ts >= min_ts )  static bool pgstat_read_statsfile_timestamp(bool permanent,TimestampTz *ts) PgStat_GlobalStats myGlobalStats ; FILE * fpin ; int32 format_id ; const char * statfile = ( permanent ? "global/pgstat.stat" : pgstat_stat_filename ) ; if ( ( fpin = AllocateFile ( statfile , "r" ) ) == ( ( void * ) 0 ) )  return ( bool ) 0 ; if ( fread ( ( & format_id ) , 1 , sizeof ( format_id ) , fpin ) != sizeof ( format_id ) || format_id != 0x01A5BC9A )  return ( bool ) 0 ; if ( fread ( ( & myGlobalStats ) , 1 , sizeof ( myGlobalStats ) , fpin ) != sizeof ( myGlobalStats ) )  return ( bool ) 0 ; return ( bool ) 1 ; if ( count % ( 640 / 10 ) == 0 )  pgstat_send_inquiry ( min_ts ); static void pgstat_send_inquiry(TimestampTz ts) PgStat_MsgInquiry msg ; msg . inquiry_time = ts; pgstat_send ( ( & msg ) , ( sizeof ( msg ) ) ); static void pgstat_send(void *msg,int len) int rc ; if ( pgStatSock == - 1 )  ( ( PgStat_MsgHdr * ) msg ) -> m_size = len; rc = ( send ( pgStatSock , msg , len , 0 ) ); while ( rc < 0 && * __errno_location ( ) == 4 )  