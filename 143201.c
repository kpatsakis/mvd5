static guint32 dissect_minivideopacket(tvbuff_t *tvb, guint32 guint16 scallno, packet_info proto_tree *iax2_tree, proto_tree *main_tree) iax_packet_data * iax_packet ; iax_packet = iax2_get_packet_data_for_minipacket ( pinfo , scallno , TRUE ); static iax_packet_data *iax2_get_packet_data_for_minipacket(packet_info guint16 gboolean video) iax_packet_data * p = ( iax_packet_data * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 ) ; if ( ! p )  iax_call_data * iax_call ; iax_call = iax_lookup_call ( pinfo , scallno , 0 , & reversed ); static iax_call_data *iax_lookup_call( packet_info guint32 guint32 gboolean *reversed_p) if ( dcallno != 0 )  guint dst_circuit_id ; dst_circuit_id = iax_circuit_lookup ( & pinfo -> dst , pinfo -> ptype , pinfo -> destport , dcallno ); static guint iax_circuit_lookup(const address port_type guint32 guint32 callno) iax_circuit_key key ; guint32 * circuit_id_p ; key . addr = * address_p; key . ptype = ptype; key . port = port; key . callno = callno; circuit_id_p = ( guint32 * ) g_hash_table_lookup ( iax_circuit_hashtab , & key ); if ( ! circuit_id_p )  iax_circuit_key * new_key ; new_key = wmem_new ( wmem_file_scope ( ) , iax_circuit_key ); new_key -> addr . type = address_p -> type; new_key -> addr . len = MIN ( address_p -> len , MAX_ADDRESS ); new_key -> addr . data = new_key -> address_data; memcpy ( new_key -> address_data , address_p -> data , new_key -> addr . len ); new_key -> ptype = ptype; new_key -> port = port; new_key -> callno = callno; g_hash_table_insert ( iax_circuit_hashtab , new_key , circuit_id_p ); g_debug ( "Created new circuit id %u for node %s" , * circuit_id_p , key_to_str ( new_key ) ); 