static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer) XHCITRB * trb_setup , * trb_status ; uint8_t bmRequestType ; trb_setup = & xfer -> trbs [ 0 ]; trb_status = & xfer -> trbs [ xfer -> trb_count - 1 ]; if ( TRB_TYPE ( * trb_status ) == TR_EVDATA && xfer -> trb_count > 2 )  trb_status --; if ( TRB_TYPE ( * trb_setup ) != TR_SETUP )  if ( TRB_TYPE ( * trb_status ) != TR_STATUS )  if ( ! ( trb_setup -> control & TRB_TR_IDT ) )  if ( ( trb_setup -> status & 0x1ffff ) != 8 )  bmRequestType = trb_setup -> parameter; xfer -> in_xfer = bmRequestType & USB_DIR_IN; xfer -> iso_xfer = false; xfer -> timed_xfer = false; if ( xhci_setup_packet ( xfer ) < 0 )  xfer -> packet . parameter = trb_setup -> parameter; xhci_complete_packet ( xfer ); static int xhci_complete_packet(XHCITransfer *xfer) if ( xfer -> packet . status == USB_RET_ASYNC )  if ( xfer -> packet . status == USB_RET_NAK )  xfer -> running_async = 0; xfer -> running_retry = 0; xfer -> complete = 1; if ( xfer -> packet . status == USB_RET_SUCCESS )  xfer -> status = CC_SUCCESS; switch ( xfer -> packet . status )  xfer -> status = CC_USB_TRANSACTION_ERROR; xhci_stall_ep ( xfer ); static void xhci_stall_ep(XHCITransfer *xfer) XHCIState * xhci = xfer -> xhci ; XHCISlot * slot = & xhci -> slots [ xfer -> slotid - 1 ] ; XHCIEPContext * epctx = slot -> eps [ xfer -> epid - 1 ] ; XHCIStreamContext * sctx ; if ( epctx -> nr_pstreams )  sctx = xhci_find_stream ( epctx , xfer -> streamid , & err ); static XHCIStreamContext *xhci_find_stream(XHCIEPContext unsigned int uint32_t *cc_error) assert ( streamid != 0 ); 