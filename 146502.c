static int decode_frame(AVCodecContext void *data, int *got_frame, AVPacket *avpkt) TiffContext * const s = avctx -> AVFrame * const p = ThreadFrame frame = . f = data unsigned off ; int le , ret , plane , planes ; int i , j , entries , stride ; unsigned soff , ssize ; uint8_t * dst ; if ( ret = ff_tdecode_header ( & s -> gb , & le , & off ) )  if ( off >= UINT_MAX - 14 || avpkt -> size < off + 14 )  s -> le = le; s -> bppcount = s -> bpp = 1; s -> photometric = TIFF_PHOTOMETRIC_NONE; s -> compr = TIFF_RAW; s -> fill_order = 0; s -> stripsizesoff = s -> strippos = 0; entries = ff_tget_short ( & s -> gb , le ); if ( bytestream2_get_bytes_left ( & s -> gb ) < entries * 12 )  for (i = 0; i < entries; i++) if ( ( ret = tiff_decode_tag ( s , p ) ) < 0 )  for (i = 0; i<s->geotag_count; i++) const char * keyname = get_geokey_name ( s -> geotags [ i ] . key ) ; if ( ! keyname )  if ( get_geokey_type ( s -> geotags [ i ] . key ) != s -> geotags [ i ] . type )  ret = av_dict_set ( avpriv_frame_get_metadatap ( p ) , keyname , s -> geotags [ i ] . val , 0 ); if ( ret < 0 )  if ( ! s -> strippos && ! s -> stripoff )  if ( ( ret = init_image ( s , & frame ) ) < 0 )  if ( s -> strips == 1 && ! s -> stripsize )  s -> stripsize = avpkt -> size - s -> stripoff; if ( s -> stripsizesoff )  if ( s -> stripsizesoff >= ( unsigned ) avpkt -> size )  if ( s -> strippos )  if ( s -> strippos >= ( unsigned ) avpkt -> size )  if ( s -> rps <= 0 )  planes = s -> planar ? s -> bppcount : 1; for (plane = 0; plane < planes; plane++) stride = p -> linesize [ plane ]; dst = p -> data [ plane ]; for (i = 0; i < s->height; i += s->rps) if ( s -> stripsizesoff )  ssize = ff_tget ( & stripsizes , s -> sstype , le ); ssize = s -> stripsize; if ( s -> strippos )  soff = ff_tget ( & stripdata , s -> sot , le ); soff = s -> stripoff; if ( soff > avpkt -> size || ssize > avpkt -> size - soff )  if ( ( ret = tiff_unpack_strip ( s , p , dst , stride , avpkt -> data + soff , ssize , i , FFMIN ( s -> rps , s -> height - i ) ) ) < 0 )  if ( avctx -> err_recognition & AV_EF_EXPLODE )  dst += s -> rps * stride; if ( s -> predictor == 2 )  if ( s -> photometric == TIFF_PHOTOMETRIC_YCBCR )  static int tiff_unpack_strip(TiffContext *s, AVFrame *p, uint8_t *dst, int const uint8_t *src, int size, int strip_start, int lines) PutByteContext pb ; int c , line , pixels , code , ret ; const uint8_t * ssrc = src ; int width = ( ( s -> width * s -> bpp ) + 7 ) >> 3 ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( p -> format ) ; int is_yuv = ! ( desc -> flags & AV_PIX_FMT_FLAG_RGB ) && ( desc -> flags & AV_PIX_FMT_FLAG_PLANAR ) && desc -> nb_components >= 3 ; if ( s -> planar )  width /= s -> bppcount; if ( size <= 0 )  if ( is_yuv )  if ( s -> yuv_line == NULL )  dst = s -> yuv_line; stride = 0; width = ( s -> width - 1 ) / s -> subsampling [ 0 ] + 1; width = width * s -> subsampling [ 0 ] * s -> subsampling [ 1 ] + 2 * width; if ( s -> compr == TIFF_DEFLATE || s -> compr == TIFF_ADOBE_DEFLATE )  if ( s -> compr == TIFF_LZMA )  if ( s -> compr == TIFF_LZW )  if ( s -> fill_order )  if ( ( ret = deinvert_buffer ( s , src , size ) ) < 0 )  ssrc = src = s -> deinvert_buf; if ( ( ret = ff_lzw_decode_init ( s -> lzw , 8 , src , size , FF_LZW_TIFF ) ) < 0 )  for (line = 0; line < lines; line++) pixels = ff_lzw_decode ( s -> lzw , dst , width ); if ( pixels < width )  if ( is_yuv )  line += s -> subsampling [ 1 ] - 1; dst += stride; if ( s -> compr == TIFF_CCITT_RLE || s -> compr == TIFF_G3 || s -> compr == TIFF_G4 )  for (line = 0; line < lines; line++) if ( src - ssrc > size )  if ( bytestream2_get_bytes_left ( & s -> gb ) == 0 || bytestream2_get_eof ( & pb ) )  switch ( s -> compr )  if ( ssrc + size - src < width )  if ( ! s -> fill_order )  int i ; for (i = 0; i < width; i++) dst [ i ] = ff_reverse [ src [ i ] ]; src += width; for (pixels = 0; pixels < width;) if ( ssrc + size - src < 2 )  code = s -> fill_order ? ( int8_t ) ff_reverse [ * src ++ ] : ( int8_t ) * src ++; if ( code >= 0 )  code ++; if ( pixels + code > width || ssrc + size - src < code )  src += code; pixels += code; if ( code != - 128 )  code = ( - code ) + 1; if ( pixels + code > width )  c = * src ++; horizontal_fill ( s -> bpp * ( s -> avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) , dst , 0 , NULL , c , code , pixels ); pixels += code; if ( s -> fill_order )  int i ; for (i = 0; i < width; i++) dst [ i ] = ff_reverse [ dst [ i ] ]; if ( is_yuv )  line += s -> subsampling [ 1 ] - 1; dst += stride; static void av_always_inline horizontal_fill(unsigned int bpp, uint8_t* int usePtr, const uint8_t uint8_t c, int width, int offset) switch ( bpp )  while ( -- width >= 0 )  dst [ ( width + offset ) * 8 + 7 ] = ( usePtr ? src [ width ] : c ) & 0x1; dst [ ( width + offset ) * 8 + 6 ] = ( usePtr ? src [ width ] : c ) >> 1 & 0x1; dst [ ( width + offset ) * 8 + 5 ] = ( usePtr ? src [ width ] : c ) >> 2 & 0x1; dst [ ( width + offset ) * 8 + 4 ] = ( usePtr ? src [ width ] : c ) >> 3 & 0x1; dst [ ( width + offset ) * 8 + 3 ] = ( usePtr ? src [ width ] : c ) >> 4 & 0x1; dst [ ( width + offset ) * 8 + 2 ] = ( usePtr ? src [ width ] : c ) >> 5 & 0x1; dst [ ( width + offset ) * 8 + 1 ] = ( usePtr ? src [ width ] : c ) >> 6 & 0x1; dst [ ( width + offset ) * 8 + 0 ] = ( usePtr ? src [ width ] : c ) >> 7; while ( -- width >= 0 )  dst [ ( width + offset ) * 4 + 3 ] = ( usePtr ? src [ width ] : c ) & 0x3; dst [ ( width + offset ) * 4 + 2 ] = ( usePtr ? src [ width ] : c ) >> 2 & 0x3; dst [ ( width + offset ) * 4 + 1 ] = ( usePtr ? src [ width ] : c ) >> 4 & 0x3; dst [ ( width + offset ) * 4 + 0 ] = ( usePtr ? src [ width ] : c ) >> 6; while ( -- width >= 0 )  dst [ ( width + offset ) * 2 + 1 ] = ( usePtr ? src [ width ] : c ) & 0xF; dst [ ( width + offset ) * 2 + 0 ] = ( usePtr ? src [ width ] : c ) >> 4; if ( usePtr )  memcpy ( dst + offset , src , width ); memset ( dst + offset , c , width ); 