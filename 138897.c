status_t MediaBuffer **out, const ReadOptions *options) if ( mFirstMoofOffset > 0 )  int64_t seekTimeUs ; ReadOptions :: SeekMode mode ; if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) )  uint32_t findFlags = 0 ; switch ( mode )  findFlags = SampleTable :: kFlagBefore; findFlags = SampleTable :: kFlagAfter; findFlags = SampleTable :: kFlagClosest; uint32_t sampleIndex ; status_t err = mSampleTable -> findSampleAtTime ( seekTimeUs * mTimescale / 1000000 , & sampleIndex , findFlags ) ; if ( mode == ReadOptions :: SEEK_CLOSEST )  findFlags = SampleTable :: kFlagBefore; uint32_t syncSampleIndex ; if ( err == OK )  err = mSampleTable -> findSyncSampleNear ( sampleIndex , & syncSampleIndex , findFlags ); if ( err == OK )  err = mSampleTable -> getMetaDataForSample ( sampleIndex , NULL , NULL , & sampleTime ); if ( err != OK )  if ( mode == ReadOptions :: SEEK_CLOSEST )  if ( ! mTimescale )  mCurrentSampleIndex = syncSampleIndex; if ( mBuffer != NULL )  mBuffer = NULL; off64_t offset = 0 ; size_t size = 0 ; bool newBuffer = false ; if ( mBuffer == NULL )  newBuffer = true; status_t err = mSampleTable -> getMetaDataForSample ( mCurrentSampleIndex , & offset , & size , & cts , & duration , & isSyncSample , & dts ) ; if ( err != OK )  int32_t max_size ; mBuffer = new MediaBuffer ( std :: min ( max_size , 1024 * 1024 ) ); if ( ! mIsAVC || mWantsNALFragments )  if ( newBuffer )  if ( ! ensureMediaBufferAllocated ( size ) )  ssize_t num_bytes_read = mDataSource -> readAt ( offset , ( uint8_t * ) mBuffer -> data ( ) , size ) ; if ( num_bytes_read < ( ssize_t ) size )  if ( ! mTimescale )  if ( mSampleTable -> hasCencInfo ( ) )  nsTArray < uint16_t > clearSizes ; nsTArray < uint32_t > cipherSizes ; uint8_t iv [ 16 ] ; status_t err = mSampleTable -> getSampleCencInfo ( mCurrentSampleIndex , clearSizes , cipherSizes , iv ) ; if ( err != OK )  if ( ! mIsAVC )  mBuffer = NULL; if ( mBuffer -> range_length ( ) < mNALLengthSize )  mBuffer = NULL; const uint8_t * src = ( const uint8_t * ) mBuffer -> data ( ) + mBuffer -> range_offset ( ) ; size_t nal_size = parseNALSize ( src ) ; if ( mBuffer -> range_length ( ) < mNALLengthSize + nal_size )  mBuffer = NULL; if ( mBuffer -> range_length ( ) == 0 )  mBuffer = NULL; int32_t drm = 0 ; bool usesDRM = ( mFormat -> findInt32 ( kKeyIsDRM , & drm ) && drm != 0 ) ; if ( usesDRM )  if ( ! ensureMediaBufferAllocated ( size ) )  num_bytes_read = mDataSource -> readAt ( offset , ( uint8_t * ) mBuffer -> data ( ) , size ); if ( ! ensureSrcBufferAllocated ( size ) )  num_bytes_read = mDataSource -> readAt ( offset , mSrcBuffer , size ); if ( num_bytes_read < ( ssize_t ) size )  if ( usesDRM )  size_t srcOffset = 0 ; size_t dstOffset = 0 ; while ( srcOffset < size )  bool isMalFormed = ( srcOffset + mNALLengthSize > size ) ; size_t nalLength = 0 ; if ( ! isMalFormed )  nalLength = parseNALSize ( & mSrcBuffer [ srcOffset ] ); srcOffset += mNALLengthSize; isMalFormed = srcOffset + nalLength > size; if ( isMalFormed )  if ( nalLength == 0 )  if ( ! ensureMediaBufferAllocated ( dstOffset + 4 + nalLength ) )  uint8_t * dstData = ( uint8_t * ) mBuffer -> data ( ) ; dstData [ dstOffset ++ ] = ( uint8_t ) ( nalLength >> 24 ); dstData [ dstOffset ++ ] = ( uint8_t ) ( nalLength >> 16 ); dstData [ dstOffset ++ ] = ( uint8_t ) ( nalLength >> 8 ); dstData [ dstOffset ++ ] = ( uint8_t ) nalLength; memcpy ( & dstData [ dstOffset ] , & mSrcBuffer [ srcOffset ] , nalLength ); srcOffset += nalLength; dstOffset += nalLength; 