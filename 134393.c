bool funcPtrCall(const ModuleCompiler::FuncPtrTable& table, MDefinition* const Call& call, MDefinition** def) if ( inDeadCode ( ) )  inline bool inDeadCode() const return curBlock_ == nullptr ; MConstant * mask = MConstant :: New ( alloc ( ) , Int32Value ( table . mask ( ) ) ) ; return * alloc_ ; TempAllocator &     alloc() const MBitAnd * maskedIndex = MBitAnd :: NewAsmJS ( alloc ( ) , index , mask ) ; return * alloc_ ; TempAllocator &     alloc() const MAsmJSLoadFuncPtr * ptrFun = MAsmJSLoadFuncPtr :: New ( alloc ( ) , table . globalDataOffset ( ) , maskedIndex ) ; return * alloc_ ; TempAllocator &     alloc() const curBlock_ -> add ( ptrFun ); return callPrivate ( MAsmJSCall :: Callee ( ptrFun ) , call , returnType , def ) ; bool callPrivate(MAsmJSCall::Callee callee, const Call& call, MIRType returnType, MDefinition** def) * def = nullptr; m_ . tokenStream ( ) . srcCoords . lineNumAndColumnIndex ( call . node_ -> pn_pos . begin , & line , & column ); switch ( callee . which ( ) )  MAsmJSCall * ins = MAsmJSCall :: New ( alloc ( ) , CallSiteDesc ( line , column , kind ) , callee , call . regArgs_ , returnType , call . spIncrement_ ) ; TempAllocator &     alloc() const return * alloc_ ; TempAllocator &     alloc() const if ( ! ins )  curBlock_ -> add ( ins ); * def = ins; 