static void fdctrl_write_mem (void *opaque, hwaddr uint64_t value, unsigned size) fdctrl_write ( opaque , ( uint32_t ) reg , value ); static void fdctrl_write (void *opaque, uint32_t reg, uint32_t value) FDCtrl * fdctrl = opaque ; reg &= 7; switch ( reg )  fdctrl_write_data ( fdctrl , value ); static void fdctrl_write_data(FDCtrl *fdctrl, uint32_t value) int pos ; if ( ! ( fdctrl -> dor & FD_DOR_nRESET ) )  if ( ! ( fdctrl -> msr & FD_MSR_RQM ) || ( fdctrl -> msr & FD_MSR_DIO ) )  fdctrl -> dsr &= ~FD_DSR_PWRDOWN; if ( fdctrl -> msr & FD_MSR_NONDMA )  if ( fdctrl -> data_pos == 0 )  pos = command_to_handler [ value & 0xff ]; fdctrl -> data_len = handlers [ pos ] . parameters + 1; fdctrl -> msr |= FD_MSR_CMDBUSY; fdctrl -> fifo [ fdctrl -> data_pos ++ ] = value; if ( fdctrl -> data_pos == fdctrl -> data_len )  if ( fdctrl -> data_state & FD_STATE_FORMAT )  fdctrl_format_sector ( fdctrl ); static void fdctrl_format_sector(FDCtrl *fdctrl) FDrive * cur_drv ; uint8_t kh , kt , ks ; cur_drv = get_cur_drv ( fdctrl ); static FDrive *get_cur_drv(FDCtrl *fdctrl) switch ( fdctrl -> cur_drv )  return drv0 ( fdctrl ) ; static inline FDrive *drv0(FDCtrl *fdctrl) return & fdctrl -> drives [ ( fdctrl -> tdr & FD_TDR_BOOTSEL ) >> 2 ] ; return drv1 ( fdctrl ) ; static inline FDrive *drv1(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 1 << 2 ) )  return & fdctrl -> drives [ 1 ] ; return & fdctrl -> drives [ 0 ] ; return drv2 ( fdctrl ) ; static inline FDrive *drv2(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 2 << 2 ) )  return & fdctrl -> drives [ 2 ] ; return & fdctrl -> drives [ 1 ] ; return drv3 ( fdctrl ) ; static inline FDrive *drv3(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 3 << 2 ) )  return & fdctrl -> drives [ 3 ] ; return & fdctrl -> drives [ 2 ] ; return NULL ; kt = fdctrl -> fifo [ 6 ]; kh = fdctrl -> fifo [ 7 ]; ks = fdctrl -> fifo [ 8 ]; switch ( fd_seek ( cur_drv , kh , kt , ks , fdctrl -> config & FD_CONFIG_EIS ) )  static int fd_seek(FDrive *drv, uint8_t head, uint8_t track, uint8_t int enable_seek) uint32_t sector ; int ret ; if ( track > drv -> max_track || ( head != 0 && ( drv -> flags & FDISK_DBL_SIDES ) == 0 ) )  return 2 ; if ( sect > drv -> last_sect )  return 3 ; sector = fd_sector_calc ( head , track , sect , drv -> last_sect , NUM_SIDES ( drv ) ); static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t uint8_t last_sect, uint8_t num_sides) return ( ( ( track * num_sides ) + head ) * last_sect ) + sect - 1 ; ret = 0; if ( sector != fd_sector ( drv ) )  static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t uint8_t last_sect, uint8_t num_sides) return ( ( ( track * num_sides ) + head ) * last_sect ) + sect - 1 ; if ( ! enable_seek )  return 4 ; drv -> head = head; if ( drv -> track != track )  if ( drv -> blk != NULL && blk_is_inserted ( drv -> blk ) )  drv -> media_changed = 0; ret = 1; drv -> track = track; drv -> sect = sect; if ( drv -> blk == NULL || ! blk_is_inserted ( drv -> blk ) )  ret = 2; return ret ; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> status0 |= FD_SR0_SEEK; memset ( fdctrl -> fifo , 0 , FD_SECTOR_LEN ); if ( cur_drv -> blk == NULL || blk_write ( cur_drv -> blk , fd_sector ( cur_drv ) , fdctrl -> fifo , 1 ) < 0 )  static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; fdctrl_stop_transfer ( fdctrl , FD_SR0_ABNTERM | FD_SR0_SEEK , 0x00 , 0x00 ); static void fdctrl_stop_transfer(FDCtrl *fdctrl, uint8_t uint8_t status1, uint8_t status2) cur_drv = get_cur_drv ( fdctrl ); static FDrive *get_cur_drv(FDCtrl *fdctrl) switch ( fdctrl -> cur_drv )  return drv0 ( fdctrl ) ; return drv1 ( fdctrl ) ; return drv2 ( fdctrl ) ; return drv3 ( fdctrl ) ; fdctrl -> status0 &= ~ ( FD_SR0_DS0 | FD_SR0_DS1 | FD_SR0_HEAD ); fdctrl -> status0 |= GET_CUR_DRV ( fdctrl ); if ( cur_drv -> head )  fdctrl -> status0 |= FD_SR0_HEAD; fdctrl -> status0 |= status0; FLOPPY_DPRINTF ( "transfer status: %02x %02x %02x (%02x)\n" , status0 , status1 , status2 , fdctrl -> status0 ); fdctrl -> fifo [ 0 ] = fdctrl -> status0; fdctrl -> fifo [ 1 ] = status1; fdctrl -> fifo [ 2 ] = status2; fdctrl -> fifo [ 3 ] = cur_drv -> track; fdctrl -> fifo [ 4 ] = cur_drv -> head; fdctrl -> fifo [ 5 ] = cur_drv -> sect; fdctrl -> fifo [ 6 ] = FD_SECTOR_SC; fdctrl -> data_dir = FD_DIR_READ; if ( ! ( fdctrl -> msr & FD_MSR_NONDMA ) )  DMA_release_DREQ ( fdctrl -> dma_chann ); fdctrl -> msr |= FD_MSR_RQM | FD_MSR_DIO; fdctrl -> msr &= ~FD_MSR_NONDMA; fdctrl_set_fifo ( fdctrl , 7 ); static void fdctrl_set_fifo(FDCtrl *fdctrl, int fifo_len) fdctrl -> data_dir = FD_DIR_READ; fdctrl -> data_len = fifo_len; fdctrl -> data_pos = 0; fdctrl -> msr |= FD_MSR_CMDBUSY | FD_MSR_RQM | FD_MSR_DIO; fdctrl_raise_irq ( fdctrl ); static void fdctrl_raise_irq(FDCtrl *fdctrl) if ( fdctrl -> sun4m && ( fdctrl -> msr & FD_MSR_CMDBUSY ) )  fdctrl -> msr &= ~FD_MSR_CMDBUSY; fdctrl -> msr |= FD_MSR_RQM | FD_MSR_DIO; if ( ! ( fdctrl -> sra & FD_SRA_INTPEND ) )  qemu_set_irq ( fdctrl -> irq , 1 ); fdctrl -> sra |= FD_SRA_INTPEND; fdctrl -> reset_sensei = 0; FLOPPY_DPRINTF ( "Set interrupt status to 0x%02x\n" , fdctrl -> status0 ); fdctrl -> data_state &= ~FD_STATE_FORMAT; fdctrl_stop_transfer ( fdctrl , 0x00 , 0x00 , 0x00 ); static void fdctrl_stop_transfer(FDCtrl *fdctrl, uint8_t uint8_t status1, uint8_t status2) cur_drv = get_cur_drv ( fdctrl ); fdctrl -> status0 &= ~ ( FD_SR0_DS0 | FD_SR0_DS1 | FD_SR0_HEAD ); fdctrl -> status0 |= GET_CUR_DRV ( fdctrl ); if ( cur_drv -> head )  fdctrl -> status0 |= FD_SR0_HEAD; fdctrl -> status0 |= status0; FLOPPY_DPRINTF ( "transfer status: %02x %02x %02x (%02x)\n" , status0 , status1 , status2 , fdctrl -> status0 ); fdctrl -> fifo [ 0 ] = fdctrl -> status0; fdctrl -> fifo [ 1 ] = status1; fdctrl -> fifo [ 2 ] = status2; fdctrl -> fifo [ 3 ] = cur_drv -> track; fdctrl -> fifo [ 4 ] = cur_drv -> head; fdctrl -> fifo [ 5 ] = cur_drv -> sect; fdctrl -> fifo [ 6 ] = FD_SECTOR_SC; fdctrl -> data_dir = FD_DIR_READ; if ( ! ( fdctrl -> msr & FD_MSR_NONDMA ) )  DMA_release_DREQ ( fdctrl -> dma_chann ); fdctrl -> msr |= FD_MSR_RQM | FD_MSR_DIO; fdctrl -> msr &= ~FD_MSR_NONDMA; fdctrl_set_fifo ( fdctrl , 7 ); fdctrl_raise_irq ( fdctrl ); fdctrl -> data_pos = 0; fdctrl -> data_len = 4; 