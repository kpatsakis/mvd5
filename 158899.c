static int CVE_2013_5642_VULN_process_sdp(struct sip_pvt *p, struct sip_request *req, int t38action) int start = req -> sdp_start ; int next = start ; const char * value = NULL ; struct ast_sockaddr sessionsa ; struct ast_sockaddr audiosa ; struct ast_sockaddr videosa ; struct ast_sockaddr textsa ; struct ast_sockaddr imagesa ; struct ast_sockaddr * sa = NULL ; struct ast_sockaddr * vsa = NULL ; struct ast_sockaddr * tsa = NULL ; struct ast_sockaddr * isa = NULL ; int portno = - 1 ; int vportno = - 1 ; int tportno = - 1 ; int udptlportno = - 1 ; struct ast_format_cap * peercapability = ast_format_cap_alloc_nolock ( ) ; struct ast_format_cap * vpeercapability = ast_format_cap_alloc_nolock ( ) ; struct ast_format_cap * tpeercapability = ast_format_cap_alloc_nolock ( ) ; int peernoncodeccapability = 0 , vpeernoncodeccapability = 0 , tpeernoncodeccapability = 0 ; struct ast_rtp_codecs newaudiortp , newvideortp , newtextrtp ; struct ast_format_cap * newjointcapability = ast_format_cap_alloc_nolock ( ) ; struct ast_format_cap * newpeercapability = ast_format_cap_alloc_nolock ( ) ; int newnoncodeccapability ; const char * codecs ; int codec ; int secure_audio = FALSE ; int secure_video = FALSE ; int numberofports ; int numberofmediastreams = 0 ; int red_data_pt [ 10 ] ; char red_fmtp [ 100 ] = "empty" ; struct ast_format tmp_fmt ; if ( ! p -> rtp )  if ( ! peercapability || ! vpeercapability || ! tpeercapability || ! newpeercapability || ! newjointcapability )  nextm = get_sdp_iterate ( & next , req , "m" ); if ( ast_strlen_zero ( nextm ) )  while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  switch ( type )  if ( ! process_sdp_o ( value , p ) )  if ( process_sdp_c ( value , & sessionsa ) )  sa = & sessionsa; vsa = sa; tsa = sa; isa = sa; p -> novideo = TRUE; p -> notext = TRUE; while ( ! ast_strlen_zero ( nextm ) )  int audio = FALSE ; int video = FALSE ; int image = FALSE ; int text = FALSE ; int processed_crypto = FALSE ; char protocol [ 5 ] = 0 , int x ; numberofports = 0; len = - 1; m = nextm; nextm = get_sdp_iterate ( & next , req , "m" ); if ( strncmp ( m , "audio " , 6 ) == 0 )  if ( ( sscanf ( m , "audio %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "audio %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  if ( x == 0 )  if ( ! strcmp ( protocol , "SAVP" ) )  secure_audio = 1; if ( strcmp ( protocol , "AVP" ) )  if ( p -> offered_media [ SDP_AUDIO ] . order_offered )  audio = TRUE; p -> offered_media [ SDP_AUDIO ] . order_offered = ++ numberofmediastreams; portno = x; codecs = m + len; for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  if ( strncmp ( m , "video " , 6 ) == 0 )  if ( ( sscanf ( m , "video %30u/%30u RTP/%4s %n" , & x , & numberofports , protocol , & len ) == 3 && len > 0 ) || ( sscanf ( m , "video %30u RTP/%4s %n" , & x , protocol , & len ) == 2 && len > 0 ) )  if ( x == 0 )  if ( ! strcmp ( protocol , "SAVP" ) )  secure_video = 1; if ( strcmp ( protocol , "AVP" ) )  if ( p -> offered_media [ SDP_VIDEO ] . order_offered )  video = TRUE; p -> novideo = FALSE; p -> offered_media [ SDP_VIDEO ] . order_offered = ++ numberofmediastreams; vportno = x; codecs = m + len; for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  if ( strncmp ( m , "text " , 5 ) == 0 )  if ( ( sscanf ( m , "text %30u/%30u RTP/AVP %n" , & x , & numberofports , & len ) == 2 && len > 0 ) || ( sscanf ( m , "text %30u RTP/AVP %n" , & x , & len ) == 1 && len > 0 ) )  if ( x == 0 )  if ( p -> offered_media [ SDP_TEXT ] . order_offered )  text = TRUE; p -> notext = FALSE; p -> offered_media [ SDP_TEXT ] . order_offered = ++ numberofmediastreams; tportno = x; codecs = m + len; for (; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) if ( sscanf ( codecs , "%30u%n" , & codec , & len ) != 1 )  if ( strncmp ( m , "image " , 6 ) == 0 )  if ( ( sscanf ( m , "image %30u udptl t38%n" , & x , & len ) == 1 && len > 0 ) || ( sscanf ( m , "image %30u UDPTL t38%n" , & x , & len ) == 1 && len > 0 ) )  if ( x == 0 )  if ( initialize_udptl ( p ) )  if ( p -> offered_media [ SDP_IMAGE ] . order_offered )  image = TRUE; p -> offered_media [ SDP_IMAGE ] . order_offered = ++ numberofmediastreams; udptlportno = x; if ( p -> t38 . state != T38_ENABLED )  memset ( & p -> t38 . their_parms , 0 , sizeof ( p -> t38 . their_parms ) ); while ( ( type = get_sdp_line ( & iterator , next - 1 , req , & value ) ) != '\0' )  switch ( type )  if ( audio )  if ( process_sdp_c ( value , & audiosa ) )  sa = & audiosa; if ( video )  if ( process_sdp_c ( value , & videosa ) )  vsa = & videosa; if ( text )  if ( process_sdp_c ( value , & textsa ) )  tsa = & textsa; if ( image )  if ( process_sdp_c ( value , & imagesa ) )  isa = & imagesa; if ( audio )  if ( process_sdp_a_sendonly ( value , & sendonly ) )  if ( ! processed_crypto && process_crypto ( p , p -> rtp , & p -> srtp , value ) )  processed_crypto = TRUE; if ( video )  if ( ! processed_crypto && process_crypto ( p , p -> vrtp , & p -> vsrtp , value ) )  processed_crypto = TRUE; if ( text )  if ( process_sdp_a_text ( value , p , & newtextrtp , red_fmtp , & red_num_gen , red_data_pt , & last_rtpmap_codec ) )  if ( ! processed_crypto && process_crypto ( p , p -> trtp , & p -> tsrtp , value ) )  processed_crypto = TRUE; if ( audio && secure_audio && ! processed_crypto )  if ( video && secure_video && ! processed_crypto )  if ( ! sa && ! vsa && ! tsa && ! isa )  if ( ( portno == - 1 ) && ( vportno == - 1 ) && ( tportno == - 1 ) && ( udptlportno == - 1 ) )  if ( secure_audio && ! ( p -> srtp && ( ast_test_flag ( p -> srtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  if ( ! secure_audio && p -> srtp )  if ( secure_video && ! ( p -> vsrtp && ( ast_test_flag ( p -> vsrtp , SRTP_CRYPTO_OFFER_OK ) ) ) )  if ( ! p -> novideo && ! secure_video && p -> vsrtp )  if ( ! ( secure_audio || secure_video ) && ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_USE_SRTP ) )  if ( ast_format_cap_is_empty ( newjointcapability ) && udptlportno == - 1 )  newnoncodeccapability = p -> noncodeccapability & peernoncodeccapability; if ( portno != - 1 || vportno != - 1 || tportno != - 1 )  p -> jointnoncodeccapability = newnoncodeccapability; if ( p -> trtp )  if ( tportno > 0 )  if ( ast_format_cap_iscompatible ( p -> jointcaps , ast_format_set ( & tmp_fmt , AST_FORMAT_T140RED , 0 ) ) )  p -> red = 1; p -> red = 0; if ( p -> udptl )  if ( udptlportno > 0 )  if ( ( t38action == SDP_T38_ACCEPT ) && ( p -> t38 . state == T38_LOCAL_REINVITE ) )  if ( ( t38action == SDP_T38_INITIATE ) && p -> owner && p -> lastinvite )  if ( ast_test_flag ( & p -> flags [ 1 ] , SIP_PAGE2_FAX_DETECT_T38 ) )  if ( strcmp ( p -> owner -> exten , "fax" ) )  