static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom) AVStream * st ; MOVStreamContext * sc ; int ret ; st = avformat_new_stream ( c -> fc , NULL ); if ( ! st )  st -> id = c -> fc -> nb_streams; sc = av_mallocz ( sizeof ( MOVStreamContext ) ); if ( ! sc )  st -> priv_data = sc; st -> codec -> codec_type = AVMEDIA_TYPE_DATA; sc -> ffindex = st -> index; if ( ( ret = mov_read_default ( c , pb , atom ) ) < 0 )  static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom) int64_t total_size = 0 ; MOVAtom a ; int i ; if ( atom . size < 0 )  atom . size = INT64_MAX; while ( total_size + 8 <= atom . size && ! url_feof ( pb ) )  a . size = atom . size; a . type = 0; if ( atom . size >= 8 )  a . size = avio_rb32 ( pb ); a . type = avio_rl32 ( pb ); if ( atom . type != MKTAG ( 'r' , 'o' , 'o' , 't' ) && atom . type != MKTAG ( 'm' , 'o' , 'o' , 'v' ) )  if ( a . type == MKTAG ( 't' , 'r' , 'a' , 'k' ) || a . type == MKTAG ( 'm' , 'd' , 'a' , 't' ) )  return 0 ; total_size += 8; if ( a . size == 1 )  a . size = avio_rb64 ( pb ) - 8; total_size += 8; if ( a . size == 0 )  a . size = atom . size - total_size + 8; a . size -= 8; if ( a . size < 0 )  a . size = FFMIN ( a . size , atom . size - total_size ); for (i = 0; mov_default_parse_table[i].type; i++) if ( mov_default_parse_table [ i ] . type == a . type )  parse = mov_default_parse_table [ i ] . parse; if ( ! parse && ( atom . type == MKTAG ( 'u' , 'd' , 't' , 'a' ) || atom . type == MKTAG ( 'i' , 'l' , 's' , 't' ) ) )  parse = mov_read_udta_string; if ( ! parse )  int64_t start_pos = avio_tell ( pb ) ; int err = parse ( c , pb , a ) ; if ( err < 0 )  return err ; if ( c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size == avio_size ( pb ) ) )  return 0 ; total_size += a . size; return 0 ; if ( sc -> chunk_count && ( ! sc -> stts_count || ! sc -> stsc_count || ( ! sc -> sample_size && ! sc -> sample_count ) ) )  if ( sc -> time_scale <= 0 )  sc -> time_scale = c -> time_scale; if ( sc -> time_scale <= 0 )  sc -> time_scale = 1; if ( sc -> dref_id - 1 < sc -> drefs_count && sc -> drefs [ sc -> dref_id - 1 ] . path )  MOVDref * dref = & sc -> drefs [ sc -> dref_id - 1 ] ; if ( mov_open_dref ( & sc -> pb , c -> fc -> filename , dref , & c -> fc -> interrupt_callback , c -> use_absolute_path , c -> fc ) < 0 )  static int mov_open_dref(AVIOContext **pb, const char *src, MOVDref AVIOInterruptCB *int_cb, int use_absolute_path, AVFormatContext *fc) if ( ref -> nlvl_to > 0 && ref -> nlvl_from > 0 )  int i , l ; for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--) if ( ref -> path [ l ] == '/' )  if ( i == ref -> nlvl_to - 1 )  i ++; if ( i == ref -> nlvl_to - 1 && src_path - src < sizeof ( filename ) )  for (i = 1; i < ref->nlvl_from; i++) av_strlcat ( filename , ref -> path + l + 1 , 1024 ); 