int sock_getsockopt(struct socket *sock, int level, int char __user *optval, int __user *optlen) union { int val ; struct linger ling ; struct timeval tm ; } v ; int len ; if ( get_user ( len , optlen ) )  if ( len < 0 )  memset ( & v , 0 , sizeof ( v ) ); v . val = sock_flag ( sk , SOCK_DBG ); v . val = sock_flag ( sk , SOCK_LOCALROUTE ); v . val = sock_flag ( sk , SOCK_BROADCAST ); v . val = sk -> sk_sndbuf; v . val = sk -> sk_rcvbuf; v . val = sk -> sk_reuse; v . val = sk -> sk_reuseport; v . val = sock_flag ( sk , SOCK_KEEPOPEN ); v . val = sk -> sk_type; v . val = sk -> sk_protocol; v . val = sk -> sk_family; v . val = - sock_error ( sk ); if ( v . val == 0 )  v . val = xchg ( & sk -> sk_err_soft , 0 ); v . val = sock_flag ( sk , SOCK_URGINLINE ); v . val = sk -> sk_no_check_tx; v . val = sk -> sk_priority; lv = sizeof ( v . ling ); v . ling . l_onoff = sock_flag ( sk , SOCK_LINGER ); v . ling . l_linger = sk -> sk_lingertime / HZ; v . val = sock_flag ( sk , SOCK_RCVTSTAMP ) && ! sock_flag ( sk , SOCK_RCVTSTAMPNS ); v . val = sock_flag ( sk , SOCK_RCVTSTAMPNS ); v . val = sk -> sk_tsflags; v . tm . tv_sec = 0; v . tm . tv_usec = 0; if ( sock -> ops -> getname ( sock , ( struct sockaddr * ) address , & lv , 2 ) )  if ( lv < len )  if ( len > lv )  len = lv; if ( copy_to_user ( optval , & v , len ) )  if ( put_user ( len , optlen ) )  