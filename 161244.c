int sctp_asconf_mgmt(struct sctp_sock *sp, struct sctp_sockaddr_entry *addrw) struct sock * sk = sctp_opt2sk ( sp ) ; union sctp_addr * addr ; struct sctp_af * af ; addr = & addrw -> a; addr -> v4 . sin_port = htons ( sp -> ep -> base . bind_addr . port ); af = sctp_get_af_specific ( addr -> sa . sa_family ); if ( ! af )  if ( sctp_verify_addr ( sk , addr , af -> sockaddr_len ) )  static inline int sctp_verify_addr(struct sock *sk, union sctp_addr int len) struct sctp_af * af ; af = sctp_sockaddr_af ( sctp_sk ( sk ) , addr , len ); static struct sctp_af *sctp_sockaddr_af(struct sctp_sock union sctp_addr *addr, int len) struct sctp_af * af ; if ( len < sizeof ( struct sockaddr ) )  return NULL ; if ( addr -> sa . sa_family == AF_INET6 && ipv6_addr_v4mapped ( & addr -> v6 . sin6_addr ) )  if ( ! opt -> pf -> af_supported ( AF_INET , opt ) )  return NULL ; if ( ! opt -> pf -> af_supported ( addr -> sa . sa_family , opt ) )  return NULL ; af = sctp_get_af_specific ( addr -> sa . sa_family ); if ( len < af -> sockaddr_len )  return NULL ; return af ; if ( ! af )  return - EINVAL ; if ( ! af -> addr_valid ( addr , sctp_sk ( sk ) , NULL ) )  return - EINVAL ; if ( ! sctp_sk ( sk ) -> pf -> send_verify ( sctp_sk ( sk ) , ( addr ) ) )  return - EINVAL ; return 0 ; if ( addrw -> state == SCTP_ADDR_NEW )  return sctp_send_asconf_add_ip ( sk , ( struct sockaddr * ) addr , 1 ) ; static int sctp_send_asconf_add_ip(struct struct int 			addrcnt) struct net * net = sock_net ( sk ) ; struct sctp_association * asoc ; struct sctp_bind_addr * bp ; struct sctp_chunk * chunk ; struct sctp_sockaddr_entry * laddr ; union sctp_addr * addr ; union sctp_addr saveaddr ; void * addr_buf ; struct sctp_af * af ; struct list_head * p ; int i ; if ( ! net -> sctp . addip_enable )  addr_buf = addrs; for (i = 0; i < addrcnt; i++) addr = addr_buf; af = sctp_get_af_specific ( addr -> v4 . sin_family ); if ( ! af )  if ( sctp_assoc_lookup_laddr ( asoc , addr ) )  addr_buf += af -> sockaddr_len; bp = & asoc -> base . bind_addr; p = bp -> address_list . next; laddr = list_entry ( p , struct sctp_sockaddr_entry , list ) chunk = sctp_make_asconf_update_ip ( asoc , & laddr -> a , addrs , addrcnt , SCTP_PARAM_ADD_IP ); if ( ! chunk )  addr_buf = addrs; for (i = 0; i < addrcnt; i++) addr = addr_buf; af = sctp_get_af_specific ( addr -> v4 . sin_family ); memcpy ( & saveaddr , addr , af -> sockaddr_len ); retval = sctp_add_bind_addr ( bp , & saveaddr , sizeof ( saveaddr ) , SCTP_ADDR_NEW , GFP_ATOMIC ); addr_buf += af -> sockaddr_len; return retval ; 