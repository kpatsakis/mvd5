static proto_item _proto_tree_add_bits_ret_val(proto_tree *tree, const int hfindex, tvbuff_t const guint bit_offset, const gint guint64 *return_value, const guint encoding) gint offset ; guint length ; guint8 tot_no_bits ; char lbl_str [ ITEM_LABEL_LENGTH ] ; proto_item * pi ; header_field_info * hf_field ; offset = bit_offset >> 3; tot_no_bits = ( ( bit_offset & 0x7 ) + no_of_bits ); length = ( tot_no_bits + 7 ) >> 3; if ( no_of_bits < 65 )  value = tvb_get_bits64 ( tvb , bit_offset , no_of_bits , encoding ); switch ( hf_field -> type )  value = ws_sign_ext64 ( value , no_of_bits ); switch ( hf_field -> type )  pi = proto_tree_add_uint ( tree , hfindex , tvb , offset , length , ( guint32 ) value ); proto_item proto_tree_add_uint(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint gint length, guint32 value) proto_item * pi = NULL ; header_field_info * hfinfo ; switch ( hfinfo -> type )  pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ); static proto_item proto_tree_add_pi(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb, gint gint *length) proto_item * pi ; field_info * fi ; gint item_length ; fi = new_field_info ( tree , hfinfo , tvb , start , item_length ); static field_info new_field_info(proto_tree *tree, header_field_info *hfinfo, tvbuff_t const gint start, const gint item_length) field_info * fi ; fi -> hfinfo = hfinfo; fi -> start = start; fi -> start += ( tvb ) ? tvb_raw_offset ( tvb ) : 0; fi -> length = item_length; fi -> tree_type = - 1; fi -> flags = 0; fi -> rep = NULL; fi -> ds_tvb = tvb ? tvb_get_ds_tvb ( tvb ) : NULL; fi -> appendix_start = 0; fi -> appendix_length = 0; return fi ; pi = proto_tree_add_node ( tree , fi ); static proto_item proto_tree_add_node(proto_tree *tree, field_info *fi) proto_node * pnode , * tnode , * sibling ; tnode = tree; pnode = wmem_new ( PNODE_POOL ( tree ) , proto_node ); pnode -> parent = tnode; pnode -> tree_data = PTREE_DATA ( tree ); return ( proto_item * ) pnode ; return pi ; return pi ; pi = proto_tree_add_int ( tree , hfindex , tvb , offset , length , ( gint32 ) value ); proto_item proto_tree_add_int(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint gint length, gint32 value) proto_item * pi = NULL ; header_field_info * hfinfo ; switch ( hfinfo -> type )  pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ); static proto_item proto_tree_add_pi(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb, gint gint *length) proto_item * pi ; field_info * fi ; gint item_length ; fi = new_field_info ( tree , hfinfo , tvb , start , item_length ); pi = proto_tree_add_node ( tree , fi ); return pi ; return pi ; pi = proto_tree_add_uint64 ( tree , hfindex , tvb , offset , length , value ); proto_item proto_tree_add_uint64(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint gint length, guint64 value) proto_item * pi = NULL ; header_field_info * hfinfo ; switch ( hfinfo -> type )  pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ); static proto_item proto_tree_add_pi(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb, gint gint *length) proto_item * pi ; field_info * fi ; gint item_length ; fi = new_field_info ( tree , hfinfo , tvb , start , item_length ); pi = proto_tree_add_node ( tree , fi ); return pi ; return pi ; pi = proto_tree_add_int64 ( tree , hfindex , tvb , offset , length , ( gint64 ) value ); proto_item proto_tree_add_int64(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint gint length, gint64 value) proto_item * pi = NULL ; header_field_info * hfinfo ; switch ( hfinfo -> type )  pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ); static proto_item proto_tree_add_pi(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb, gint gint *length) proto_item * pi ; field_info * fi ; gint item_length ; fi = new_field_info ( tree , hfinfo , tvb , start , item_length ); pi = proto_tree_add_node ( tree , fi ); return pi ; return pi ; fill_label_number64 ( PITEM_FINFO ( pi ) , lbl_str , TRUE ); static fill_label_number64(field_info *fi, gchar *label_str, gboolean is_signed) header_field_info * hfinfo = fi -> hfinfo ; if ( hfinfo -> display == BASE_CUSTOM )  gchar tmp [ ITEM_LABEL_LENGTH ] ; label_fill ( label_str , 0 , hfinfo , tmp ); static label_fill(char *label_str, gsize pos, const header_field_info *hfinfo, const char *text) gsize name_pos ; name_pos = pos = label_concat ( label_str , pos , hfinfo -> name ); pos = label_concat ( label_str , pos , ": " ); pos = label_concat ( label_str , pos , text ? text : "(null)" ); if ( pos >= ITEM_LABEL_LENGTH )  label_mark_truncated ( label_str , name_pos ); static label_mark_truncated(char *label_str, gsize name_pos) static const char trunc_str [ ] = " [truncated]" ; const size_t trunc_len = sizeof ( trunc_str ) - 1 ; if ( name_pos < ITEM_LABEL_LENGTH - trunc_len )  memmove ( label_str + name_pos + trunc_len , label_str + name_pos , ITEM_LABEL_LENGTH - name_pos - trunc_len ); memcpy ( label_str + name_pos , trunc_str , trunc_len ); last_char = g_utf8_prev_char ( & label_str [ ITEM_LABEL_LENGTH ] ); * last_char = '\0'; g_strlcpy ( label_str + name_pos , trunc_str , ITEM_LABEL_LENGTH - name_pos ); 