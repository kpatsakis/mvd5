static CharDriverState *qemu_chr_open_pty(void) CharDriverState * chr ; PtyCharDriver * s ; int slave_fd , len ; char pty_name [ PATH_MAX ] ; chr = qemu_mallocz ( sizeof ( CharDriverState ) ); s = qemu_mallocz ( sizeof ( PtyCharDriver ) ); if ( openpty ( & s -> fd , & slave_fd , pty_name , NULL , NULL ) < 0 )  static int openpty(int *amaster, int *aslave, char struct termios *termp, struct winsize *winp) const char * slave ; mfd = open ( "/dev/ptmx" , O_RDWR | O_NOCTTY ); if ( mfd < 0 )  if ( grantpt ( mfd ) == - 1 || unlockpt ( mfd ) == - 1 )  if ( ( slave = ptsname ( mfd ) ) == NULL )  if ( ( sfd = open ( slave , O_RDONLY | O_NOCTTY ) ) == - 1 )  if ( ioctl ( sfd , I_PUSH , "ptem" ) == - 1 || ( termp != NULL && tcgetattr ( sfd , termp ) < 0 ) )  return 0 ; return - 1 ; len = strlen ( q_ptsname ( s -> fd ) ) + 5; chr -> filename = qemu_malloc ( len ); snprintf ( chr -> filename , len , "pty:%s" , q_ptsname ( s -> fd ) ); chr -> opaque = s; chr -> chr_write = pty_chr_write; chr -> chr_update_read_handler = pty_chr_update_read_handler; chr -> chr_close = pty_chr_close; s -> timer = qemu_new_timer ( rt_clock , pty_chr_timer , chr ); return chr ; 