static sg_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos) Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; int req_pack_id = - 1 ; if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) )  if ( ! access_ok ( VERIFY_WRITE , buf , count ) )  if ( sfp -> force_packid && ( count >= SZ_SG_HEADER ) )  old_hdr = kmalloc ( SZ_SG_HEADER , GFP_KERNEL ); if ( ! old_hdr )  if ( __copy_from_user ( old_hdr , buf , SZ_SG_HEADER ) )  if ( old_hdr -> reply_len < 0 )  if ( count >= SZ_SG_IO_HDR )  sg_io_hdr_t * new_hdr ; new_hdr = kmalloc ( SZ_SG_IO_HDR , GFP_KERNEL ); if ( ! new_hdr )  retval = __copy_from_user ( new_hdr , buf , SZ_SG_IO_HDR ); req_pack_id = new_hdr -> pack_id; if ( retval )  req_pack_id = old_hdr -> pack_id; srp = sg_get_rq_mark ( sfp , req_pack_id ); if ( ! srp )  if ( atomic_read ( & sdp -> detaching ) )  if ( filp -> f_flags & O_NONBLOCK )  retval = wait_event_interruptible ( sfp -> read_wait , ( atomic_read ( & sdp -> detaching ) || ( srp = sg_get_rq_mark ( sfp , req_pack_id ) ) ) ); if ( atomic_read ( & sdp -> detaching ) )  if ( retval )  if ( srp -> header . interface_id != '\0' )  retval = sg_new_read ( sfp , buf , count , srp ); static sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp) err2 = sg_finish_rem_req ( srp ); static sg_finish_rem_req(Sg_request *srp) Sg_fd * sfp = srp -> parentfp ; Sg_scatter_hold * req_schp = & srp -> data ; if ( srp -> res_used )  sg_remove_scat ( sfp , req_schp ); static sg_remove_scat(Sg_fd * sfp, Sg_scatter_hold * schp) memset ( schp , 0 , sizeof ( * schp ) ); 