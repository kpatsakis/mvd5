void *emem_tree_lookup32_array_le(emem_tree_t *se_tree,emem_tree_key_t *key) emem_tree_t * lookup_tree = ( ( void * ) 0 ) ; emem_tree_key_t * cur_key ; guint32 i ; guint32 lookup_key32 = 0 ; if ( ! se_tree || ! key )  for (cur_key = key; cur_key -> length > 0; cur_key++) if ( cur_key -> length > 100 )  getenv ( "WIRESHARK_ABORT_ON_DISSECTOR_BUG" ) != ( ( void * ) 0 ) ? abort ( ) : except_throw ( 1 , 4 , ( ep_strdup_printf ( "%s:%u: failed assertion \"DISSECTOR_ASSERT_NOT_REACHED\"" , "emem.c" , 1926 ) ) ); gchar *ep_strdup_printf(const gchar *fmt,... ) va_list ap ; gchar * dst ; dst = ep_strdup_vprintf ( fmt , ap ); gchar *ep_strdup_vprintf(const gchar *fmt,va_list ap) return emem_strdup_vprintf ( fmt , ap , ep_alloc ) ; static gchar *emem_strdup_vprintf(const gchar *fmt,va_list ap,void *allocator(size_t )) gsize len ; gchar * dst ; len = g_printf_string_upper_bound ( fmt , ap ); dst = ( allocator ( len + 1 ) ); return dst ; return dst ; for (i = 0; i < cur_key -> length; i++) if ( ! lookup_tree )  lookup_tree = se_tree; lookup_tree = ( emem_tree_lookup32_le ( lookup_tree , lookup_key32 ) ); void *emem_tree_lookup32_le(emem_tree_t *se_tree,guint32 key) node = se_tree -> tree; if ( ! node )  while ( node )  if ( key == node -> key32 )  return node -> data ; if ( key < node -> key32 )  if ( node -> left )  node = node -> left; if ( key > node -> key32 )  if ( node -> right )  node = node -> right; if ( ! node )  if ( ! node -> parent )  if ( key > node -> key32 )  return node -> data ; if ( node -> parent -> left == node )  if ( key > node -> key32 )  return node -> data ; while ( node )  if ( key > node -> key32 )  return node -> data ; node = node -> parent; if ( node -> key32 < key )  return node -> data ; return node -> parent -> data ; if ( ! lookup_tree )  lookup_key32 = cur_key -> key [ i ]; 