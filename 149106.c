static void *emem_alloc_chunk(size_t size,emem_header_t *mem) void * buf ; size_t asize = size ; gboolean use_canary = mem -> debug_use_canary ; guint8 pad ; emem_chunk_t * free_list ; if ( use_canary )  asize += sizeof ( void * ); pad = emem_canary_pad ( asize ); static guint8 emem_canary_pad(size_t allocation) guint8 pad ; pad = ( 8 - allocation % 8 ); if ( pad < 8 )  pad += 8; return pad ; pad = ( 8 - ( asize & ( 8 - 1 ) ) & ( 8 - 1 ) ); asize += pad; if ( ! mem -> free_list )  mem -> free_list = emem_create_chunk_gp ( ( 10 * 1024 * 1024 ) ); static emem_chunk_t *emem_create_chunk_gp(size_t size) emem_chunk_t * npc ; npc = emem_create_chunk ( size ); static emem_chunk_t *emem_create_chunk(size_t size) emem_chunk_t * npc ; npc = ( ( emem_chunk_t * ) ( g_malloc_n ( 1 , sizeof ( emem_chunk_t ) ) ) ); npc -> next = ( ( void * ) 0 ); npc -> canary_last = ( ( void * ) 0 ); npc -> amount_free = npc -> amount_free_init = ( ( unsigned int ) size ); npc -> free_offset = npc -> free_offset_init = 0; return npc ; npc -> amount_free = npc -> amount_free_init; npc -> free_offset = npc -> free_offset_init; return npc ; if ( asize > ( mem -> free_list -> amount_free ) )  emem_chunk_t * npc ; npc = mem -> free_list; mem -> free_list = mem -> free_list -> next; npc -> next = mem -> used_list; mem -> used_list = npc; if ( ! mem -> free_list )  mem -> free_list = emem_create_chunk_gp ( ( 10 * 1024 * 1024 ) ); static emem_chunk_t *emem_create_chunk_gp(size_t size) emem_chunk_t * npc ; npc = emem_create_chunk ( size ); npc -> amount_free = npc -> amount_free_init; npc -> free_offset = npc -> free_offset_init; return npc ; free_list = mem -> free_list; buf = ( free_list -> buf + free_list -> free_offset ); if ( use_canary )  char * cptr = ( ( char * ) buf ) + size ; memcpy ( cptr , ( mem -> canary ) , ( pad - 1 ) ); cptr [ pad - 1 ] = '\0'; memcpy ( ( cptr + pad ) , ( & free_list -> canary_last ) , sizeof ( void * ) ); free_list -> canary_last = cptr; 