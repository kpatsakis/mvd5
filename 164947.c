static ssize_t unix_stream_splice_read(struct socket *sock,  loff_t struct pipe_inode_info size_t size, unsigned int flags) struct unix_stream_read_state state . recv_actor = unix_stream_splice_actor . socket = sock . pipe = pipe . size = size . splice_flags = flags , if ( unlikely ( * ppos ) )  if ( sock -> file -> f_flags & O_NONBLOCK || flags & SPLICE_F_NONBLOCK )  state . flags = MSG_DONTWAIT; return unix_stream_read_generic ( & state ) ; static int unix_stream_read_generic(struct unix_stream_read_state *state) struct scm_cookie scm ; struct socket * sock = state -> socket ; struct sock * sk = sock -> sk ; int copied = 0 ; int flags = state -> flags ; int noblock = flags & MSG_DONTWAIT ; bool check_creds = false ; int target ; long timeo ; int skip ; size_t size = state -> size ; unsigned int last_len ; err = - EINVAL; if ( sk -> sk_state != TCP_ESTABLISHED )  if ( flags & MSG_OOB )  target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ); timeo = sock_rcvtimeo ( sk , noblock ); memset ( & scm , 0 , sizeof ( scm ) ); if ( flags & MSG_PEEK )  skip = sk_peek_offset ( sk , flags ); skip = 0; int chunk ; bool drop_skb ; struct sk_buff * skb , * last ; if ( sock_flag ( sk , SOCK_DEAD ) )  last = skb = skb_peek ( & sk -> sk_receive_queue ); last_len = last ? last -> len : 0; if ( skb == NULL )  if ( copied >= target )  err = sock_error ( sk ); if ( err )  if ( sk -> sk_shutdown & RCV_SHUTDOWN )  if ( ! timeo )  timeo = unix_stream_data_wait ( sk , timeo , last , last_len ); if ( signal_pending ( current ) )  while ( skip >= unix_skb_len ( skb ) )  skip -= unix_skb_len ( skb ); last = skb; last_len = skb -> len; skb = skb_peek_next ( skb , & sk -> sk_receive_queue ); if ( ! skb )  if ( check_creds )  if ( ! unix_skb_scm_eq ( skb , & scm ) )  if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) )  check_creds = true; if ( state -> msg && state -> msg -> msg_name )  unix_copy_addr ( state -> msg , skb -> sk ); chunk = min_t ( unsigned int , unix_skb_len ( skb ) - skip , size ) chunk = state -> recv_actor ( skb , skip , chunk , state ); drop_skb = ! unix_skb_len ( skb ); if ( chunk < 0 )  copied += chunk; size -= chunk; if ( drop_skb )  if ( ! ( flags & MSG_PEEK ) )  UNIXCB ( skb ) . consumed += chunk; if ( unix_skb_len ( skb ) )  if ( scm . fp )  if ( UNIXCB ( skb ) . fp )  scm . fp = scm_fp_dup ( UNIXCB ( skb ) . fp ); if ( UNIXCB ( skb ) . fp )  skip = 0; last = skb; last_len = skb -> len; skb = skb_peek_next ( skb , & sk -> sk_receive_queue ); if ( skb )  while ( size )  static void unix_copy_addr(struct msghdr *msg, struct sock *sk) struct unix_sock * u = unix_sk ( sk ) ; if ( u -> addr )  msg -> msg_namelen = u -> addr -> len; memcpy ( msg -> msg_name , u -> addr -> name , u -> addr -> len ); 