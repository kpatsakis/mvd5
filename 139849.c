static int CVE_2013_7270_PATCHED_packet_recvmsg(struct kiocb *iocb, struct socket struct msghdr *msg, size_t len, int flags) struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; err = - EINVAL; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) )  if ( pkt_sk ( sk ) -> ifindex < 0 )  if ( flags & MSG_ERRQUEUE )  skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ); if ( skb == NULL )  if ( pkt_sk ( sk ) -> has_vnet_hdr )  struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL; vnet_hdr_len = sizeof ( vnet_hdr ); if ( len < vnet_hdr_len )  len -= vnet_hdr_len; if ( skb_is_gso ( skb ) )  struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ); vnet_hdr . gso_size = sinfo -> gso_size; if ( sinfo -> gso_type & SKB_GSO_TCPV4 )  vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4; if ( sinfo -> gso_type & SKB_GSO_TCPV6 )  vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6; if ( sinfo -> gso_type & SKB_GSO_UDP )  vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_UDP; if ( sinfo -> gso_type & SKB_GSO_FCOE )  if ( sinfo -> gso_type & SKB_GSO_TCP_ECN )  vnet_hdr . gso_type |= VIRTIO_NET_HDR_GSO_ECN; vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_NONE; if ( skb -> ip_summed == CHECKSUM_PARTIAL )  if ( skb -> ip_summed == CHECKSUM_UNNECESSARY )  vnet_hdr . flags = VIRTIO_NET_HDR_F_DATA_VALID; err = memcpy_toiovec ( msg -> msg_iov , ( void * ) & vnet_hdr , vnet_hdr_len ); if ( err < 0 )  copied = skb -> len; if ( copied > len )  copied = len; msg -> msg_flags |= MSG_TRUNC; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ); if ( err )  if ( msg -> msg_name )  if ( sock -> type == SOCK_PACKET )  msg -> msg_namelen = sizeof ( struct sockaddr_pkt ); msg -> msg_namelen = sll -> sll_halen offsetof ( struct sockaddr_ll , sll_addr ) memcpy ( msg -> msg_name , & PACKET_SKB_CB ( skb ) -> sa , msg -> msg_namelen ); put_cmsg ( msg , SOL_PACKET , PACKET_AUXDATA , sizeof ( aux ) , & aux ); 