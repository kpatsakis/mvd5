static CVE_2011_1076_PATCHED_dns_resolver_instantiate(struct key *key, const void *_data, size_t datalen) struct user_key_payload * upayload ; unsigned long derrno ; int ret ; const char * data = _data , * end , * opt ; if ( datalen <= 1 || ! data || data [ datalen - 1 ] != '\0' )  datalen --; end = data + datalen; opt = memchr ( data , '#' , datalen ); if ( ! opt )  result_len = datalen; const char * next_opt ; result_len = opt - data; opt ++; const char * eq ; int opt_len , opt_nlen , opt_vlen , tmp ; next_opt = memchr ( opt , '#' , end - opt ) ? : end opt_len = next_opt - opt; if ( ! opt_len )  eq = memchr ( opt , '=' , opt_len ) ? : end opt_nlen = eq - opt; eq ++; opt_vlen = next_opt - eq; if ( opt_nlen == sizeof ( DNS_ERRORNO_OPTION ) - 1 && memcmp ( opt , DNS_ERRORNO_OPTION , opt_nlen ) == 0 )  if ( opt_vlen <= 0 )  ret = strict_strtoul ( eq , 10 , & derrno ); if ( ret < 0 )  if ( derrno < 1 || derrno > 511 )  key -> type_data . x [ 0 ] = - derrno; while ( opt = next_opt + 1 , opt < end )  if ( key -> type_data . x [ 0 ] )  ret = key_payload_reserve ( key , result_len ); if ( ret < 0 )  upayload = kmalloc ( sizeof ( * upayload ) + result_len + 1 , GFP_KERNEL ); if ( ! upayload )  upayload -> datalen = result_len; memcpy ( upayload -> data , data , result_len ); upayload -> data [ result_len ] = '\0'; rcu_assign_pointer ( key -> payload . data , upayload ); 