struct xt_table *arpt_register_table(struct net const struct xt_table const struct arpt_replace *repl) struct xt_table_info * newinfo ; void * loc_cpu_entry ; newinfo = xt_alloc_table_info ( repl -> size ); if ( ! newinfo )  loc_cpu_entry = newinfo -> entries; memcpy ( loc_cpu_entry , repl -> entries , repl -> size ); ret = translate_table ( newinfo , loc_cpu_entry , repl ); static int translate_table(struct xt_table_info *newinfo, void const struct arpt_replace *repl) newinfo -> size = repl -> size; newinfo -> number = repl -> num_entries; newinfo -> hook_entry [ i ] = 0xFFFFFFFF; newinfo -> underflow [ i ] = 0xFFFFFFFF; duprintf ( "translate_table: size %u\n" , newinfo -> size ); xt_entry_foreach ( iter , entry0 , newinfo -> size ) ret = check_entry_size_and_hooks ( iter , newinfo , entry0 , entry0 + repl -> size , repl -> hook_entry , repl -> underflow , repl -> valid_hooks ); static inline int check_entry_size_and_hooks(struct arpt_entry struct xt_table_info const unsigned char const unsigned char const unsigned int const unsigned int unsigned int valid_hooks) if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) duprintf ( "Bad offset %p\n" , e ); if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) )  duprintf ( "checking: element %p size %u\n" , e , e -> next_offset ); if ( ! ( valid_hooks & ( 1 << h ) ) )  if ( ( unsigned char * ) e - base == hook_entries [ h ] )  newinfo -> hook_entry [ h ] = hook_entries [ h ]; if ( ( unsigned char * ) e - base == underflows [ h ] )  if ( ! check_underflow ( e ) )  static bool check_underflow(const struct arpt_entry *e) if ( ! unconditional ( & e -> arp ) )  static inline bool unconditional(const struct arpt_arp *arp) return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; t = arpt_get_target_c ( e ); static inline const struct xt_entry_target arpt_get_target_c(const struct arpt_entry *e) return arpt_get_target ( ( struct arpt_entry * ) e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 )  verdict = ( ( struct xt_standard_target * ) t ) -> verdict; verdict = - verdict - 1; return verdict == NF_DROP || verdict == NF_ACCEPT ; newinfo -> underflow [ h ] = underflows [ h ]; e -> counters = ( ( struct xt_counters ) 0 , 0 ) e -> comefrom = 0; if ( ret != 0 )  ++ newinfo -> stacksize; duprintf ( "translate_table: ARPT_ENTRY_ITERATE gives %d\n" , ret ); if ( ret != 0 )  return ret ; if ( i != repl -> num_entries )  duprintf ( "translate_table: %u not %u entries\n" , i , repl -> num_entries ); for (i = 0; i < NF_ARP_NUMHOOKS; i++) if ( ! ( repl -> valid_hooks & ( 1 << i ) ) )  if ( newinfo -> hook_entry [ i ] == 0xFFFFFFFF )  duprintf ( "Invalid hook entry %u %u\n" , i , repl -> hook_entry [ i ] ); if ( newinfo -> underflow [ i ] == 0xFFFFFFFF )  duprintf ( "Invalid underflow %u %u\n" , i , repl -> underflow [ i ] ); if ( ! mark_source_chains ( newinfo , repl -> valid_hooks , entry0 ) )  static int mark_source_chains(const struct xt_table_info unsigned int valid_hooks, void *entry0) unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) )  e -> counters . pcnt = pos; const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; static inline const struct xt_entry_target arpt_get_target_c(const struct arpt_entry *e) return arpt_get_target ( ( struct arpt_entry * ) e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) )  pr_notice ( "arptables: loop hook %u pos %u %08X.\n" , hook , pos , e -> comefrom ); e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ); if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 && unconditional ( & e -> arp ) ) || visited )  static inline bool unconditional(const struct arpt_arp *arp) return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 )  e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ); oldpos = pos; pos = e -> counters . pcnt; e -> counters . pcnt = 0; if ( pos == oldpos )  e = ( struct arpt_entry * ) ( entry0 + pos ); while ( oldpos == pos + e -> next_offset )  size = e -> next_offset; e = ( struct arpt_entry * ) ( entry0 + pos + size ); e -> counters . pcnt = pos; pos += size; int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 )  if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) )  duprintf ( "Jump rule %u -> %u\n" , pos , newpos ); newpos = pos + e -> next_offset; e = ( struct arpt_entry * ) ( entry0 + newpos ); e -> counters . pcnt = pos; pos = newpos; xt_entry_foreach ( iter , entry0 , newinfo -> size ) ret = find_check_entry ( iter , repl -> name , repl -> size ); static inline find_check_entry(struct arpt_entry *e, const char *name, unsigned int size) ret = check_entry ( e , name ); static inline int check_entry(const struct arpt_entry *e, const char *name) if ( ! arp_checkentry ( & e -> arp ) )  static inline int arp_checkentry(const struct arpt_arp *arp) if ( arp -> flags & ~ARPT_F_MASK )  duprintf ( "Unknown flag bits set: %08X\n" , arp -> flags & ~ARPT_F_MASK ); if ( arp -> invflags & ~ARPT_INV_MASK )  duprintf ( "Unknown invflag bits set: %08X\n" , arp -> invflags & ~ARPT_INV_MASK ); duprintf ( "arp_tables: arp check failed %p %s.\n" , e , name ); if ( e -> target_offset + sizeof ( struct xt_entry_target ) > e -> next_offset )  t = arpt_get_target_c ( e ); static inline const struct xt_entry_target arpt_get_target_c(const struct arpt_entry *e) return arpt_get_target ( ( struct arpt_entry * ) e ) ; if ( e -> target_offset + t -> u . target_size > e -> next_offset )  if ( ret )  return ret ; e -> counters . pcnt = xt_percpu_counter_alloc ( ); if ( IS_ERR_VALUE ( e -> counters . pcnt ) )  t = arpt_get_target ( e ); target = xt_request_find_target ( NFPROTO_ARP , t -> u . user . name , t -> u . user . revision ); if ( IS_ERR ( target ) )  duprintf ( "find_check_entry: `%s' not found\n" , t -> u . user . name ); ret = PTR_ERR ( target ); t -> u . kernel . target = target; ret = check_target ( e , name ); static inline int check_target(struct arpt_entry *e, const char *name) struct xt_entry_target * t = arpt_get_target ( e ) ; ret = xt_check_target ( & par , t -> u . target_size - sizeof ( * t ) , 0 , false ); if ( ret < 0 )  duprintf ( "arp_tables: check failed for `%s'.\n" , t -> u . kernel . target -> name ); return ret ; if ( ret )  module_put ( t -> u . kernel . target -> me ); xt_percpu_counter_free ( e -> counters . pcnt ); return ret ; if ( ret != 0 )  if ( ret != 0 )  xt_entry_foreach ( iter , entry0 , newinfo -> size ) if ( i -- == 0 )  return ret ; return ret ; duprintf ( "arpt_register_table: translate table gives %d\n" , ret ); if ( ret != 0 )  return ERR_PTR ( ret ) ; 