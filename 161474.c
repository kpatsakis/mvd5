static int output_packet(InputStream *ist,const AVPacket *pkt) int got_output ; AVPacket avpkt ; if ( ! ist -> saw_first_ts )  ist -> dts = ( ( ist -> st -> avg_frame_rate . num ? ( - ist -> st -> codec -> has_b_frames * 1000000 ) / av_q2d ( ist -> st -> avg_frame_rate ) : 0 ) ); ist -> pts = 0; if ( pkt != ( ( void * ) 0 ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && ! ist -> decoding_needed )  ist -> pts = ist -> dts; ist -> saw_first_ts = 1; if ( ist -> next_dts == ( ( int64_t ) 0x8000000000000000UL ) )  ist -> next_dts = ist -> dts; if ( ist -> next_pts == ( ( int64_t ) 0x8000000000000000UL ) )  ist -> next_pts = ist -> pts; if ( pkt == ( ( void * ) 0 ) )  avpkt . data = ( ( void * ) 0 ); avpkt . size = 0; avpkt = * pkt; if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) )  ist -> next_dts = ist -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_VIDEO || ! ist -> decoding_needed )  ist -> next_pts = ist -> pts = ist -> dts; while ( ist -> decoding_needed && ( avpkt . size > 0 || ! pkt && got_output ) )  int duration ; ist -> pts = ist -> next_pts; ist -> dts = ist -> next_dts; if ( avpkt . size && avpkt . size != pkt -> size )  ist -> showed_multi_packet_warning = 1; switch ( ist -> st -> codec -> codec_type )  ret = decode_audio ( ist , & avpkt , & got_output ); static int decode_audio(InputStream *ist,AVPacket *pkt,int *got_output) AVFrame * decoded_frame ; AVCodecContext * avctx = ist -> st -> codec ; int ret ; if ( ! ist -> decoded_frame && ! ( ist -> decoded_frame = avcodec_alloc_frame ( ) ) )  return - 12 ; decoded_frame = ist -> decoded_frame; ret = avcodec_decode_audio4 ( avctx , decoded_frame , got_output , pkt ); if ( ret >= 0 && avctx -> sample_rate <= 0 )  ret = - ( ( int ) ( ( 'I' | 'N' << 8 | 'D' << 16 ) | ( ( unsigned int ) 'A' ) << 24 ) ); if ( ! ( * got_output ) || ret < 0 )  return ret ; return ret ; ret = decode_video ( ist , & avpkt , & got_output ); static int decode_video(InputStream *ist,AVPacket *pkt,int *got_output) AVFrame * decoded_frame ; if ( ! ist -> decoded_frame && ! ( ist -> decoded_frame = avcodec_alloc_frame ( ) ) )  return - 12 ; decoded_frame = ist -> decoded_frame; pkt -> dts = av_rescale_q ( ist -> dts , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) , ist -> st -> time_base ) ret = avcodec_decode_video2 ( ist -> st -> codec , decoded_frame , got_output , pkt ); if ( ! ( * got_output ) || ret < 0 )  return ret ; return ret ; if ( avpkt . duration )  duration = ( av_rescale_q ( avpkt . duration , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) ) if ( ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0 )  int ticks = ist -> st -> parser ? ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame ; duration = ( ( ( int64_t ) 1000000 ) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den ); duration = 0; if ( ist -> dts != ( ( int64_t ) 0x8000000000000000UL ) && duration )  ist -> next_dts += duration; ist -> next_dts = ( ( int64_t ) 0x8000000000000000UL ); if ( got_output )  ist -> next_pts += duration; ret = transcode_subtitles ( ist , & avpkt , & got_output ); if ( ret < 0 )  avpkt . dts = avpkt . pts = ( ( int64_t ) 0x8000000000000000UL ); if ( pkt )  if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_AUDIO )  ret = avpkt . size; avpkt . data += ret; avpkt . size -= ret; static int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output) AVSubtitle subtitle ; int i ; int ret = avcodec_decode_subtitle2 ( ist -> st -> codec , & subtitle , got_output , pkt ) ; if ( ret < 0 || ! ( * got_output ) )  if ( ist -> fix_sub_duration )  if ( ist -> prev_sub . got_output )  int end = ( av_rescale ( subtitle . pts - ist -> prev_sub . subtitle . pts , 1000 , 1000000 ) ) ; if ( end < ist -> prev_sub . subtitle . end_display_time )  ist -> prev_sub . subtitle . end_display_time = end; int SWAP_tmp = ist -> prev_sub . got_output ; ist -> prev_sub . got_output = * got_output; * got_output = SWAP_tmp; while ( 0 )  int SWAP_tmp = ist -> prev_sub . ret ; ist -> prev_sub . ret = ret; ret = SWAP_tmp; while ( 0 )  AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle ; ist -> prev_sub . subtitle = subtitle; subtitle = SWAP_tmp; while ( 0 )  if ( ! ( * got_output ) || ! subtitle . num_rects )  for (i = 0; i < nb_output_streams; i++) OutputStream * ost = output_streams [ i ] ; if ( ! check_output_constraints ( ist , ost ) || ! ost -> encoding_needed )  static int check_output_constraints(InputStream *ist,OutputStream *ost) OutputFile * of = output_files [ ost -> file_index ] ; int ist_index = input_files [ ist -> file_index ] -> ist_index + ist -> st -> index ; if ( ost -> source_index != ist_index )  return 0 ; if ( of -> start_time && ist -> pts < of -> start_time )  return 0 ; return 1 ; do_subtitle_out ( output_files [ ost -> file_index ] -> ctx , ost , ist , & subtitle ); static void do_subtitle_out(AVFormatContext *s,OutputStream *ost,InputStream *ist,AVSubtitle *sub) int subtitle_out_max_size = 1024 * 1024 ; int subtitle_out_size ; int nb ; int i ; AVCodecContext * enc ; AVPacket pkt ; int64_t pts ; if ( sub -> pts == ( ( int64_t ) 0x8000000000000000UL ) )  enc = ost -> st -> codec; if ( ! subtitle_out )  subtitle_out = ( av_malloc ( subtitle_out_max_size ) ); if ( ( enc -> codec_id ) == AV_CODEC_ID_DVB_SUBTITLE )  nb = 2; nb = 1; pts = sub -> pts - output_files [ ost -> file_index ] -> start_time; for (i = 0; i < nb; i++) ost -> sync_opts = av_rescale_q ( pts , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) , enc -> time_base ) if ( ! check_recording_time ( ost ) )  static int check_recording_time(OutputStream *ost) return 0 ; sub -> pts = pts; sub -> end_display_time -= sub -> start_display_time; sub -> start_display_time = 0; if ( i == 1 )  sub -> num_rects = 0; subtitle_out_size = avcodec_encode_subtitle ( enc , subtitle_out , subtitle_out_max_size , sub ); pkt . data = subtitle_out; pkt . size = subtitle_out_size; pkt . pts = av_rescale_q ( sub -> pts , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) , ost -> st -> time_base pkt . duration = ( av_rescale_q ( ( sub -> end_display_time ) , ( ( AVRational ) ( 1 ) , ( 1000 ) ) , ost -> st -> time_base ) ) if ( ( enc -> codec_id ) == AV_CODEC_ID_DVB_SUBTITLE )  if ( i == 0 )  pkt . pts += ( 'Z' * sub -> start_display_time ); pkt . pts += ( 'Z' * sub -> end_display_time ); write_frame ( s , & pkt , ost ); static void write_frame(AVFormatContext *s,AVPacket *pkt,OutputStream *ost) AVBitStreamFilterContext * bsfc = ost -> bitstream_filters ; AVCodecContext * avctx = ost -> st -> codec ; if ( ( avctx -> codec_type ) == AVMEDIA_TYPE_VIDEO && video_sync_method == 0xFF || ( avctx -> codec_type ) == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0 )  pkt -> pts = pkt -> dts = ( ( int64_t ) 0x8000000000000000UL ); if ( ( ( avctx -> codec_type ) == AVMEDIA_TYPE_AUDIO || ( avctx -> codec_type ) == AVMEDIA_TYPE_VIDEO ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) )  int64_t max = ost -> st -> cur_dts + ( ! ( s -> oformat -> flags & 0x8020000 ) ) ; if ( ost -> st -> cur_dts && ost -> st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && max > pkt -> dts )  if ( pkt -> pts >= pkt -> dts )  pkt -> pts = ( pkt -> pts > max ? pkt -> pts : max ); pkt -> dts = max; if ( ! ( ( avctx -> codec_type ) == AVMEDIA_TYPE_VIDEO && avctx -> codec ) )  if ( ( ost -> frame_number ) >= ost -> max_frames )  while ( bsfc )  AVPacket new_pkt = * pkt ; int a = av_bitstream_filter_filter ( bsfc , avctx , ( ( void * ) 0 ) , & new_pkt . data , & new_pkt . size , ( pkt -> data ) , pkt -> size , pkt -> flags & 0000001 ) ; if ( a == 0 && new_pkt . data != pkt -> data && new_pkt . destruct )  uint8_t * t = ( av_malloc ( ( new_pkt . size + 16 ) ) ) ; if ( t )  memcpy ( t , new_pkt . data , new_pkt . size ); memset ( ( t + new_pkt . size ) , 0 , 16 ); new_pkt . data = t; a = 1; a = - 12; if ( a > 0 )  new_pkt . destruct = av_destruct_packet; if ( a < 0 )  av_log ( ( ( void * ) 0 ) , 16 , "Failed to open bitstream filter %s for stream %d with codec %s" , bsfc -> filter -> name , pkt -> stream_index , ( avctx -> codec ? avctx -> codec -> name : "copy" ) ); print_error ( "" , a ); * pkt = new_pkt; bsfc = bsfc -> next; pkt -> stream_index = ost -> index; av_log ( ( ( void * ) 0 ) , 32 , "muxer <- type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s size:%d\n" , av_get_media_type_string ( ost -> st -> codec -> codec_type ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts ) , av_ts_make_time_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts , & ost -> st -> time_base ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) , av_ts_make_time_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts , & ost -> st -> time_base ) , pkt -> size ) ret = av_interleaved_write_frame ( s , pkt ); if ( ret < 0 )  print_error ( "av_interleaved_write_frame()" , ret ); 