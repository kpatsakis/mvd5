static int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr) switch ( type )  if ( arg <= 0 || arg > 16 || c -> encrypt )  memcpy ( ( c -> buf ) , ptr , arg ); if ( arg <= 0 || arg > 16 || ! c -> encrypt || gctx -> taglen < 0 )  memcpy ( ptr , ( c -> buf ) , arg ); memcpy ( ( gctx -> iv ) , ptr , ( gctx -> ivlen ) ); gctx -> iv_gen = 1; memcpy ( ( gctx -> iv ) , ptr , arg ); if ( c -> encrypt && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 )  gctx -> iv_gen = 1; if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 )  CRYPTO_gcm128_setiv ( & gctx -> gcm , ( gctx -> iv ) , ( gctx -> ivlen ) ); if ( arg <= 0 || arg > gctx -> ivlen )  arg = gctx -> ivlen; memcpy ( ptr , ( gctx -> iv + gctx -> ivlen - arg ) , arg ); ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ); static void ctr64_inc(unsigned char *counter) c = counter [ n ]; counter [ n ] = c; if ( c )  while ( n )  gctx -> iv_set = 1; if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt )  memcpy ( ( gctx -> iv + gctx -> ivlen - arg ) , ptr , arg ); CRYPTO_gcm128_setiv ( & gctx -> gcm , ( gctx -> iv ) , ( gctx -> ivlen ) ); gctx -> iv_set = 1; if ( arg != 13 )  memcpy ( ( c -> buf ) , ptr , arg ); gctx -> tls_aad_len = arg; unsigned int len = ( c -> buf [ arg - 2 ] << 8 | c -> buf [ arg - 1 ] ) ; len -= 8; if ( ! c -> encrypt )  len -= 16; c -> buf [ arg - 2 ] = ( len >> 8 ); c -> buf [ arg - 1 ] = ( len & 0xff ); 