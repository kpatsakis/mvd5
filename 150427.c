static void pcnet_csr_writew(PCNetState *s, uint32_t rap, uint32_t new_value) uint16_t val = new_value ; switch ( rap )  s -> csr [ 0 ] &= ~ ( val & 0x7f00 ); s -> csr [ 0 ] = ( s -> csr [ 0 ] & ~0x0040 ) | ( val & 0x0048 ); val = ( val & 0x007f ) | ( s -> csr [ 0 ] & 0x7f00 ); if ( ( val & 7 ) == 7 )  val &= ~3; s -> csr [ 4 ] &= ~ ( val & 0x026a ); val &= ~0x026a; val |= s -> csr [ 4 ] & 0x026a; s -> csr [ 5 ] &= ~ ( val & 0x0a90 ); val &= ~0x0a90; val |= s -> csr [ 5 ] & 0x0a90; pcnet_csr_writew ( s , 2 , val ); static void pcnet_csr_writew(PCNetState *s, uint32_t rap, uint32_t new_value) uint16_t val = new_value ; switch ( rap )  s -> csr [ 0 ] &= ~ ( val & 0x7f00 ); s -> csr [ 0 ] = ( s -> csr [ 0 ] & ~0x0040 ) | ( val & 0x0048 ); if ( CSR_TDMD ( s ) )  pcnet_transmit ( s ); static void pcnet_transmit(PCNetState *s) int count = CSR_XMTRL ( s ) - 1 ; int add_crc = 0 ; s -> xmit_pos = - 1; if ( ! CSR_TXON ( s ) )  s -> tx_busy = 1; if ( pcnet_tdte_poll ( s ) )  static int pcnet_tdte_poll(PCNetState *s) s -> csr [ 34 ] = s -> csr [ 35 ] = 0; if ( s -> tdra )  target_phys_addr_t cxda = s -> tdra + ( CSR_XMTRL ( s ) - CSR_XMTRC ( s ) ) * ( BCR_SWSTYLE ( s ) ? 16 : 8 ) ; int bad = 0 ; if ( ! bad )  if ( CSR_CXDA ( s ) != cxda )  s -> csr [ 60 ] = s -> csr [ 34 ]; s -> csr [ 61 ] = s -> csr [ 35 ]; s -> csr [ 62 ] = CSR_CXBC ( s ); s -> csr [ 63 ] = CSR_CXST ( s ); s -> csr [ 34 ] = cxda & 0xffff; s -> csr [ 35 ] = cxda >> 16; if ( CSR_CXDA ( s ) )  struct pcnet_TMD tmd ; CSR_CXST ( s ) = tmd . status; CSR_CXBC ( s ) = CSR_CXST ( s ) = 0; return ! ! ( CSR_CXST ( s ) & 0x8000 ) ; struct pcnet_TMD tmd ; if ( GET_FIELD ( tmd . status , TMDS , STP ) )  s -> xmit_pos = 0; if ( BCR_SWSTYLE ( s ) != 1 )  add_crc = GET_FIELD ( tmd . status , TMDS , ADDFCS ); if ( ! GET_FIELD ( tmd . status , TMDS , ENP ) )  int bcnt = 4096 - GET_FIELD ( tmd . length , TMDL , BCNT ) ; s -> xmit_pos += bcnt; if ( s -> xmit_pos >= 0 )  int bcnt = 4096 - GET_FIELD ( tmd . length , TMDL , BCNT ) ; s -> xmit_pos += bcnt; if ( CSR_LOOP ( s ) )  if ( BCR_SWSTYLE ( s ) == 1 )  add_crc = ! GET_FIELD ( tmd . status , TMDS , NOFCS ); s -> looptest = add_crc ? PCNET_LOOPTEST_CRC : PCNET_LOOPTEST_NOCRC; pcnet_receive ( s , s -> buffer , s -> xmit_pos ); s -> looptest = 0; s -> csr [ 0 ] &= ~0x0008; s -> csr [ 4 ] |= 0x0004; s -> xmit_pos = - 1; if ( ! CSR_TOKINTD ( s ) || ( CSR_LTINTEN ( s ) && GET_FIELD ( tmd . status , TMDS , LTINT ) ) )  s -> csr [ 0 ] |= 0x0200; if ( count -- )  if ( s -> xmit_pos >= 0 )  s -> csr [ 0 ] |= 0x0200; if ( ! CSR_DXSUFLO ( s ) )  if ( count -- )  static void pcnet_receive(void *opaque, const uint8_t *buf, int size) PCNetState * s = opaque ; uint8_t buf1 [ 60 ] ; if ( CSR_DRX ( s ) || CSR_STOP ( s ) || CSR_SPND ( s ) || ! size )  if ( size < MIN_BUF_SIZE )  memcpy ( buf1 , buf , size ); memset ( buf1 + size , 0 , MIN_BUF_SIZE - size ); buf = buf1; if ( CSR_PROM ( s ) || ( is_padr = padr_match ( s , buf , size ) ) || ( is_bcast = padr_bcast ( s , buf , size ) ) || ( is_ladr = ladr_match ( s , buf , size ) ) )  static inline int ladr_match(PCNetState *s, const uint8_t *buf, int size) struct qemu_ether_header * hdr = ( void * ) buf ; if ( ( * ( hdr -> ether_dhost ) & 0x01 ) ( ( uint64_t * ) & s -> csr [ 8 ] ) [ 0 ] != 0L L ) uint8_t ladr [ 8 ] = { s -> csr [ 8 ] & 0xff , s -> csr [ 8 ] >> 8 , s -> csr [ 9 ] & 0xff , s -> csr [ 9 ] >> 8 , s -> csr [ 10 ] & 0xff , s -> csr [ 10 ] >> 8 , s -> csr [ 11 ] & 0xff , s -> csr [ 11 ] >> 8 } ; int index = lnc_mchash ( hdr -> ether_dhost ) >> 26 ; static inline uint32_t lnc_mchash(const uint8_t *ether_addr) for (data = *ether_addr++, bit = 0; bit < MULTICAST_FILTER_LEN; bit++) crc = ( crc >> 1 ) ^ ( ( ( crc ^ data ) & 1 ) ? LNC_POLYNOMIAL : 0 ); data >>= 1; return crc ; return ! ! ( ladr [ index >> 3 ] & ( 1 << ( index & 7 ) ) ) ; static inline int padr_bcast(PCNetState *s, const uint8_t *buf, int size) struct qemu_ether_header * hdr = ( void * ) buf ; int result = ! CSR_DRCVBC ( s ) && ! memcmp ( hdr -> ether_dhost , BCAST , 6 ) ; printf ( "padr_bcast result=%d\n" , result ); return result ; static inline int padr_match(PCNetState *s, const uint8_t *buf, int size) struct qemu_ether_header * hdr = ( void * ) buf ; uint8_t padr [ 6 ] = { s -> csr [ 12 ] & 0xff , s -> csr [ 12 ] >> 8 , s -> csr [ 13 ] & 0xff , s -> csr [ 13 ] >> 8 , s -> csr [ 14 ] & 0xff , s -> csr [ 14 ] >> 8 } ; int result = ( ! CSR_DRCVPA ( s ) ) && ! memcmp ( hdr -> ether_dhost , padr , 6 ) ; printf ( "padr_match result=%d\n" , result ); return result ; memcpy ( src , buf , size ); src [ size ] = 0; src [ size + 1 ] = 0; src [ size + 2 ] = 0; src [ size + 3 ] = 0; size += 4; PRINT_PKTHDR ( buf ); s -> phys_mem_write ( s -> dma_opaque , rbadr , src , count , CSR_BSWP ( s ) ); src += count; SET_FIELD ( & rmd . msg_length , RMDM , MCNT , size ); SET_FIELD ( & rmd . status , RMDS , PAM , ! CSR_PROM ( s ) && is_padr ); SET_FIELD ( & rmd . status , RMDS , LFAM , ! CSR_PROM ( s ) && is_ladr ); SET_FIELD ( & rmd . status , RMDS , BAM , ! CSR_PROM ( s ) && is_bcast ); 