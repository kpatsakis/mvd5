static void arcmsr_hbaC_postqueue_isr(struct AdapterControlBlock *acb) struct MessageUnit_C __iomem * phbcmu ; struct ARCMSR_CDB * arcmsr_cdb ; struct CommandControlBlock * ccb ; int error ; phbcmu = acb -> pmuC; while ( ( flag_ccb = readl ( & phbcmu -> outbound_queueport_low ) ) != 0xFFFFFFFF )  ccb_cdb_phy = ( flag_ccb & 0xFFFFFFF0 ); arcmsr_cdb = ( struct ARCMSR_CDB * ) ( acb -> vir2phy_offset + ccb_cdb_phy ); ccb = container_of ( arcmsr_cdb , struct CommandControlBlock arcmsr_cdb ) error = ( flag_ccb & ARCMSR_CCBREPLY_FLAG_ERROR_MODE1 ) ? true : false; arcmsr_drain_donequeue ( acb , ccb , error ); static void arcmsr_drain_donequeue(struct AdapterControlBlock *acb, struct CommandControlBlock *pCCB, bool error) if ( ( pCCB -> acb != acb ) || ( pCCB -> startdone != ARCMSR_CCB_START ) )  if ( pCCB -> startdone == ARCMSR_CCB_ABORTED )  printk ( KERN_NOTICE "arcmsr%d: isr get an illegal ccb command \\n\t\t\t\tdone acb = '0x%p'" arcmsr_report_ccb_state ( acb , pCCB , error ); static void arcmsr_report_ccb_state(struct AdapterControlBlock struct CommandControlBlock *ccb, bool error) if ( ! error )  switch ( ccb -> arcmsr_cdb . DeviceStatus )  ccb -> pcmd -> result = DID_BAD_TARGET << 16; arcmsr_report_sense_info ( ccb ); static void arcmsr_report_sense_info(struct CommandControlBlock *ccb) struct scsi_cmnd * pcmd = ccb -> pcmd ; struct SENSE_DATA * sensebuffer = ( struct SENSE_DATA * ) pcmd -> sense_buffer ; if ( sensebuffer )  memset ( sensebuffer , 0 , SCSI_SENSE_BUFFERSIZE ); memcpy ( sensebuffer , ccb -> arcmsr_cdb . SenseData , sense_data_length ); sensebuffer -> ErrorCode = SCSI_SENSE_CURRENT_ERRORS; sensebuffer -> Valid = 1; 