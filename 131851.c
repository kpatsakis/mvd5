int CVE_2014_3631_VULN_assoc_array_gc(struct assoc_array const struct assoc_array_ops bool (*iterator)(void *object, void void *iterator_data) struct assoc_array_shortcut * shortcut , * new_s ; struct assoc_array_node * node , * new_n ; struct assoc_array_edit * edit ; struct assoc_array_ptr * cursor , * ptr ; struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; int keylen , slot , nr_free , next_slot , i ; if ( ! array -> root )  edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ); if ( ! edit )  new_root = new_parent = NULL; new_ptr_pp = & new_root; cursor = array -> root; if ( assoc_array_ptr_is_shortcut ( cursor ) )  shortcut = assoc_array_ptr_to_shortcut ( cursor ); keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ); keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ); if ( ! new_s )  pr_devel ( "dup shortcut %p -> %p\n" , shortcut , new_s ); memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ); new_s -> back_pointer = new_parent; new_s -> parent_slot = shortcut -> parent_slot; * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ); new_ptr_pp = & new_s -> next_node; cursor = shortcut -> next_node; node = assoc_array_ptr_to_node ( cursor ); new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ); if ( ! new_n )  pr_devel ( "dup node %p -> %p\n" , node , new_n ); new_n -> back_pointer = new_parent; new_n -> parent_slot = node -> parent_slot; * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ); slot = 0; for (; slot < ASSOC_ARRAY_FAN_OUT; slot++) ptr = node -> slots [ slot ]; if ( ! ptr )  if ( assoc_array_ptr_is_leaf ( ptr ) )  if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) )  new_n -> slots [ slot ] = ptr; new_ptr_pp = & new_n -> slots [ slot ]; cursor = ptr; pr_devel ( "-- compress node %p --\n" , new_n ); new_n -> nr_leaves_on_branch = 0; nr_free = 0; for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) ptr = new_n -> slots [ slot ]; if ( ! ptr )  nr_free ++; if ( assoc_array_ptr_is_leaf ( ptr ) )  new_n -> nr_leaves_on_branch ++; pr_devel ( "free=%d, leaves=%lu\n" , nr_free , new_n -> nr_leaves_on_branch ); next_slot = 0; for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) struct assoc_array_shortcut * s ; struct assoc_array_node * child ; ptr = new_n -> slots [ slot ]; if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) )  s = NULL; if ( assoc_array_ptr_is_shortcut ( ptr ) )  s = assoc_array_ptr_to_shortcut ( ptr ); ptr = s -> next_node; child = assoc_array_ptr_to_node ( ptr ); new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch; if ( child -> nr_leaves_on_branch <= nr_free + 1 )  pr_devel ( "[%d] fold node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); BUG_ON ( s ); new_n -> slots [ slot ] = NULL; nr_free ++; if ( slot < next_slot )  next_slot = slot; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) struct assoc_array_ptr * p = child -> slots [ i ] ; if ( ! p )  BUG_ON ( assoc_array_ptr_is_meta ( p ) ); while ( new_n -> slots [ next_slot ] )  next_slot ++; BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ); new_n -> slots [ next_slot ++ ] = p; nr_free --; kfree ( child ); pr_devel ( "[%d] retain node %lu/%d [nx %d]\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ); pr_devel ( "after: %lu\n" , new_n -> nr_leaves_on_branch ); nr_leaves_on_tree = new_n -> nr_leaves_on_branch; if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 )  for (slot = 0; slot < ASSOC_ARRAY_FAN_OUT; slot++) if ( ptr = new_n -> slots [ slot ] )  if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) )  pr_devel ( "excise node %p with 1 shortcut\n" , new_n ); new_s = assoc_array_ptr_to_shortcut ( ptr ); new_parent = new_n -> back_pointer; slot = new_n -> parent_slot; kfree ( new_n ); if ( ! new_parent )  new_s -> back_pointer = NULL; new_s -> parent_slot = 0; new_root = ptr; if ( assoc_array_ptr_is_shortcut ( new_parent ) )  struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; new_parent = new_s -> back_pointer = s -> back_pointer; slot = new_s -> parent_slot = s -> parent_slot; kfree ( s ); if ( ! new_parent )  new_s -> back_pointer = NULL; new_s -> parent_slot = 0; new_root = ptr; new_s -> back_pointer = new_parent; new_s -> parent_slot = slot; new_n = assoc_array_ptr_to_node ( new_parent ); new_n -> slots [ slot ] = ptr; ptr = new_n -> back_pointer; if ( ! ptr )  if ( assoc_array_ptr_is_shortcut ( ptr ) )  new_s = assoc_array_ptr_to_shortcut ( ptr ); new_parent = new_s -> back_pointer; slot = new_s -> parent_slot; if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT )  struct assoc_array_node * n ; new_n -> back_pointer = new_parent; new_n -> parent_slot = slot; kfree ( new_s ); if ( ! new_parent )  new_root = assoc_array_node_to_ptr ( new_n ); n = assoc_array_ptr_to_node ( new_parent ); n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ); new_parent = ptr; new_n = assoc_array_ptr_to_node ( new_parent ); ptr = node -> back_pointer; if ( assoc_array_ptr_is_shortcut ( ptr ) )  shortcut = assoc_array_ptr_to_shortcut ( ptr ); slot = shortcut -> parent_slot; cursor = shortcut -> back_pointer; slot = node -> parent_slot; cursor = ptr; BUG_ON ( ! ptr ); node = assoc_array_ptr_to_node ( cursor ); slot ++; edit -> set [ 0 ] . to = new_root; assoc_array_apply_edit ( edit ); edit -> array -> nr_leaves_on_tree = nr_leaves_on_tree; 