static enum XML_Error entityValueInitProcessor(XML_Parser const char const char const char **nextPtr) int tok ; const char * start = s ; const char * next = start ; tok = XmlPrologTok ( encoding , start , end , & next ); if ( tok <= 0 )  if ( tok == XML_TOK_XML_DECL )  enum XML_Error result ; result = processXmlDecl ( parser , 0 , start , next ); static enum processXmlDecl(XML_Parser parser, int const char *s, const char *next) const char * encodingName = NULL ; const XML_Char * storedEncName = NULL ; const ENCODING * newEncoding = NULL ; const char * version = NULL ; const char * versionend ; if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )  if ( isGeneralTextEntity )  return XML_ERROR_TEXT_DECL ; return XML_ERROR_XML_DECL ; if ( xmlDeclHandler )  if ( encodingName != NULL )  storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) ); if ( ! storedEncName )  return XML_ERROR_NO_MEMORY ; if ( version )  storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar ); if ( ! storedversion )  return XML_ERROR_NO_MEMORY ; if ( protocolEncodingName == NULL )  if ( newEncoding )  if ( newEncoding -> minBytesPerChar != encoding -> minBytesPerChar )  return XML_ERROR_INCORRECT_ENCODING ; if ( encodingName )  enum XML_Error result ; if ( ! storedEncName )  storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) ); if ( ! storedEncName )  return XML_ERROR_NO_MEMORY ; result = handleUnknownEncoding ( parser , storedEncName ); return result ; return XML_ERROR_NONE ; if ( result != XML_ERROR_NONE )  switch ( ps_parsing )  * nextPtr = next; return entityValueProcessor ( parser , next , end , nextPtr ) ; if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer )  start = next; static enum XML_Error entityValueProcessor(XML_Parser const char const char const char **nextPtr) const char * start = s ; const char * next = s ; const ENCODING * enc = encoding ; int tok ; tok = XmlPrologTok ( enc , start , end , & next ); if ( tok <= 0 )  if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )  switch ( tok )  return storeEntityValue ( parser , enc , s , end ) ; start = next; static enum storeEntityValue(XML_Parser const ENCODING const char const char *entityTextEnd) DTD * const dtd = _dtd STRING_POOL * pool = & ( dtd -> entityValuePool ) ; if ( ! pool -> blocks )  if ( ! poolGrow ( pool ) )  static XML_Bool poolGrow(STRING_POOL *pool) if ( pool -> freeBlocks )  if ( pool -> start == 0 )  return XML_TRUE ; if ( pool -> end - pool -> start < pool -> freeBlocks -> size )  return XML_TRUE ; if ( pool -> blocks && pool -> start == pool -> blocks -> s )  int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ; pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ); if ( pool -> blocks == NULL )  return XML_FALSE ; BLOCK * tem ; int blockSize = ( int ) ( pool -> end - pool -> start ) ; if ( blockSize < INIT_BLOCK_SIZE )  blockSize = INIT_BLOCK_SIZE; blockSize *= 2; tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ); if ( ! tem )  return XML_FALSE ; return XML_TRUE ; const char * next ; int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ; switch ( tok )  if ( isParamEntity || enc != encoding )  const XML_Char * name ; ENTITY * entity ; name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ); static XML_Char poolStoreString(STRING_POOL *pool, const ENCODING const char *ptr, const char *end) if ( ! poolAppend ( pool , enc , ptr , end ) )  return NULL ; if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )  return NULL ; * ( pool -> ptr ) ++ = 0; return pool -> start ; if ( ! name )  entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 ); if ( ! entity )  if ( entity -> open )  if ( entity -> systemId )  if ( externalEntityRefHandler )  entity -> open = XML_TRUE; if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )  entity -> open = XML_FALSE; entity -> open = XML_TRUE; result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) ); entity -> open = XML_FALSE; if ( result )  if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )  static XML_Char poolAppend(STRING_POOL *pool, const ENCODING const char *ptr, const char *end) if ( ! pool -> ptr && ! poolGrow ( pool ) )  return NULL ; if ( ptr == end )  if ( ! poolGrow ( pool ) )  return NULL ; return pool -> start ; next = entityTextPtr + enc -> minBytesPerChar; if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )  static XML_Bool poolGrow(STRING_POOL *pool) if ( pool -> freeBlocks )  if ( pool -> start == 0 )  return XML_TRUE ; if ( pool -> end - pool -> start < pool -> freeBlocks -> size )  return XML_TRUE ; if ( pool -> blocks && pool -> start == pool -> blocks -> s )  int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ; pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ); if ( pool -> blocks == NULL )  return XML_FALSE ; BLOCK * tem ; int blockSize = ( int ) ( pool -> end - pool -> start ) ; if ( blockSize < INIT_BLOCK_SIZE )  blockSize = INIT_BLOCK_SIZE; blockSize *= 2; tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ); if ( ! tem )  return XML_FALSE ; return XML_TRUE ; * ( pool -> ptr ) ++ = 0xA; XML_Char buf [ XML_ENCODE_MAX ] ; int i ; int n = XmlCharRefNumber ( enc , entityTextPtr ) ; if ( n < 0 )  n = XmlEncode ( n , ( ICHAR * ) buf ); if ( ! n )  for (i = 0; i < n; i++) if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )  static XML_Bool poolGrow(STRING_POOL *pool) if ( pool -> freeBlocks )  if ( pool -> start == 0 )  return XML_TRUE ; if ( pool -> end - pool -> start < pool -> freeBlocks -> size )  return XML_TRUE ; if ( pool -> blocks && pool -> start == pool -> blocks -> s )  int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ; pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ); if ( pool -> blocks == NULL )  return XML_FALSE ; BLOCK * tem ; int blockSize = ( int ) ( pool -> end - pool -> start ) ; if ( blockSize < INIT_BLOCK_SIZE )  blockSize = INIT_BLOCK_SIZE; blockSize *= 2; tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ); if ( ! tem )  return XML_FALSE ; return XML_TRUE ; * ( pool -> ptr ) ++ = buf [ i ]; entityTextPtr = next; static NAMED lookup(HASH_TABLE *table, KEY name, size_t createSize) if ( table -> size == 0 )  size_t tsize ; if ( ! createSize )  table -> power = INIT_POWER; table -> size = ( size_t ) 1 << INIT_POWER; tsize = table -> size * sizeof ( NAMED * ); table -> v = ( NAMED * * ) table -> mem -> malloc_fcn ( tsize ); if ( ! table -> v )  memset ( table -> v , 0 , tsize ); i = hash ( name ) & ( ( unsigned long ) table -> size - 1 ); table -> v [ i ] = ( NAMED * ) table -> mem -> malloc_fcn ( createSize ); if ( ! table -> v [ i ] )  memset ( table -> v [ i ] , 0 , createSize ); table -> v [ i ] -> name = name; ( table -> used ) ++; return table -> v [ i ] ; 