long fuse_ioctl_common(struct file *file, unsigned int unsigned long arg, unsigned int flags) struct inode * inode = file_inode ( file ) ; struct fuse_conn * fc = get_fuse_conn ( inode ) ; if ( ! fuse_allow_current_process ( fc ) )  if ( is_bad_inode ( inode ) )  return fuse_do_ioctl ( file , cmd , arg , flags ) ; long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long unsigned int flags) struct fuse_file * ff = file -> private_data ; struct fuse_conn * fc = ff -> fc ; struct fuse_ioctl_in inarg . fh = ff -> fh . cmd = cmd . arg = arg . flags = flags struct fuse_ioctl_out outarg ; struct page * * pages = NULL ; struct iovec * in_iov = NULL , * out_iov = NULL ; unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ; size_t in_size , out_size , transferred ; int err ; inarg . flags |= FUSE_IOCTL_32BIT; err = - ENOMEM; pages = kcalloc ( FUSE_MAX_PAGES_PER_REQ , sizeof ( pages [ 0 ] ) , GFP_KERNEL ); iov_page = ( struct iovec * ) __get_free_page ( GFP_KERNEL ); if ( ! pages || ! iov_page )  if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) )  struct iovec * iov = iov_page ; iov -> iov_base = ( void __user * ) arg; iov -> iov_len = _IOC_SIZE ( cmd ); if ( _IOC_DIR ( cmd ) & _IOC_WRITE )  in_iov = iov; in_iovs = 1; if ( _IOC_DIR ( cmd ) & _IOC_READ )  out_iov = iov; out_iovs = 1; inarg . in_size = in_size = iov_length ( in_iov , in_iovs ); inarg . out_size = out_size = iov_length ( out_iov , out_iovs ); out_size = max_t ( size_t , out_size , PAGE_SIZE ); max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE ); err = - ENOMEM; if ( max_pages > FUSE_MAX_PAGES_PER_REQ )  while ( num_pages < max_pages )  pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM ); if ( ! pages [ num_pages ] )  num_pages ++; req = fuse_get_req ( fc , num_pages ); if ( IS_ERR ( req ) )  memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages ); req -> num_pages = num_pages; req -> in . h . opcode = FUSE_IOCTL; req -> in . h . nodeid = ff -> nodeid; req -> in . numargs = 1; req -> in . args [ 0 ] . size = sizeof ( inarg ); req -> in . args [ 0 ] . value = & inarg; if ( in_size )  req -> in . numargs ++; req -> in . args [ 1 ] . size = in_size; req -> in . argpages = 1; err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false ); static int fuse_ioctl_copy_user(struct page **pages, struct iovec unsigned int nr_segs, size_t bytes, bool to_user) struct iov_iter ii ; int page_idx = 0 ; if ( ! bytes )  return 0 ; while ( iov_iter_count ( & ii ) )  struct page * page = pages [ page_idx ++ ] ; size_t todo = min_t ( size_t , PAGE_SIZE , iov_iter_count ( & ii ) ) ; void * kaddr ; kaddr = kmap ( page ); while ( todo )  char __user * uaddr = ii . iov -> iov_base + ii . iov_offset ; size_t iov_len = ii . iov -> iov_len - ii . iov_offset ; size_t copy = min ( todo , iov_len ) ; size_t left ; if ( ! to_user )  left = copy_from_user ( kaddr , uaddr , copy ); left = copy_to_user ( uaddr , kaddr , copy ); if ( unlikely ( left ) )  return - EFAULT ; todo -= copy; kaddr += copy; return 0 ; if ( err )  req -> out . numargs = 2; req -> out . args [ 0 ] . size = sizeof ( outarg ); req -> out . args [ 0 ] . value = & outarg; req -> out . args [ 1 ] . size = out_size; req -> out . argpages = 1; req -> out . argvar = 1; err = req -> out . h . error; transferred = req -> out . args [ 1 ] . size; if ( err )  if ( outarg . flags & FUSE_IOCTL_RETRY )  void * vaddr ; if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) )  in_iovs = outarg . in_iovs; out_iovs = outarg . out_iovs; if ( in_iovs > FUSE_IOCTL_MAX_IOV || out_iovs > FUSE_IOCTL_MAX_IOV || in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV )  vaddr = kmap_atomic ( pages [ 0 ] ); err = fuse_copy_ioctl_iovec ( fc , iov_page , vaddr , transferred , in_iovs + out_iovs , ( flags & FUSE_IOCTL_COMPAT ) != 0 ); if ( err )  in_iov = iov_page; out_iov = in_iov + in_iovs; err = fuse_verify_ioctl_iov ( in_iov , in_iovs ); static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count) size_t n ; u32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT ; for (n = 0; n < count; n++, iov++) if ( iov -> iov_len > ( size_t ) max )  return - ENOMEM ; max -= iov -> iov_len; return 0 ; if ( err )  err = fuse_verify_ioctl_iov ( out_iov , out_iovs ); static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count) size_t n ; u32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT ; if ( iov -> iov_len > ( size_t ) max )  return - ENOMEM ; max -= iov -> iov_len; return 0 ; if ( err )  static int fuse_copy_ioctl_iovec(struct fuse_conn *fc, struct iovec void *src, size_t transferred, unsigned bool is_compat) if ( fc -> minor < 16 )  return fuse_copy_ioctl_iovec_old ( dst , src , transferred , count , is_compat ) ; static int fuse_copy_ioctl_iovec_old(struct iovec *dst, void size_t transferred, unsigned bool is_compat) if ( count * sizeof ( struct compat_iovec ) == transferred )  if ( count * sizeof ( struct iovec ) != transferred )  memcpy ( dst , src , transferred ); 