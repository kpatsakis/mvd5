svn_stream_t *svn_stream_lazyopen_create(svn_stream_lazyopen_func_t open_func,void *open_baton,svn_boolean_t open_on_close,apr_pool_t *result_pool) lazyopen_baton_t * lob = ( memset ( apr_palloc ( result_pool , sizeof ( ( * lob ) ) ) , 0 , sizeof ( ( * lob ) ) ) ) ; lob -> open_func = open_func; lob -> open_baton = open_baton; lob -> real_stream = ( ( void * ) 0 ); lob -> pool = result_pool; lob -> open_on_close = open_on_close; stream = svn_stream_create ( lob , result_pool ); svn_stream_t *svn_stream_create(void *baton,apr_pool_t *pool) stream = ( apr_palloc ( pool , sizeof ( ( * stream ) ) ) ); stream -> baton = baton; stream -> read_fn = ( ( void * ) 0 ); stream -> skip_fn = ( ( void * ) 0 ); stream -> write_fn = ( ( void * ) 0 ); stream -> close_fn = ( ( void * ) 0 ); stream -> mark_fn = ( ( void * ) 0 ); stream -> seek_fn = ( ( void * ) 0 ); stream -> is_buffered_fn = ( ( void * ) 0 ); stream -> file = ( ( void * ) 0 ); return stream ; svn_stream_set_read ( stream , read_handler_lazyopen ); void svn_stream_set_read(svn_stream_t *stream,svn_read_fn_t read_fn) stream -> read_fn = read_fn; svn_stream_set_skip ( stream , skip_handler_lazyopen ); void svn_stream_set_skip(svn_stream_t *stream,svn_stream_skip_fn_t skip_fn) stream -> skip_fn = skip_fn; svn_stream_set_write ( stream , write_handler_lazyopen ); void svn_stream_set_write(svn_stream_t *stream,svn_write_fn_t write_fn) stream -> write_fn = write_fn; svn_stream_set_close ( stream , close_handler_lazyopen ); void svn_stream_set_close(svn_stream_t *stream,svn_close_fn_t close_fn) stream -> close_fn = close_fn; svn_stream_set_mark ( stream , mark_handler_lazyopen ); void svn_stream_set_mark(svn_stream_t *stream,svn_stream_mark_fn_t mark_fn) stream -> mark_fn = mark_fn; svn_stream_set_seek ( stream , seek_handler_lazyopen ); void svn_stream_set_seek(svn_stream_t *stream,svn_stream_seek_fn_t seek_fn) stream -> seek_fn = seek_fn; svn_stream__set_is_buffered ( stream , is_buffered_lazyopen ); void svn_stream__set_is_buffered(svn_stream_t *stream,svn_stream__is_buffered_fn_t is_buffered_fn) stream -> is_buffered_fn = is_buffered_fn; return stream ; 