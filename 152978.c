static int compat_do_arpt_set_ctl(struct sock *sk, int cmd, void __user unsigned int len) int ret ; if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) )  switch ( cmd )  ret = compat_do_replace ( sock_net ( sk ) , user , len ); static int compat_do_replace(struct net *net, void __user unsigned int len) int ret ; struct compat_arpt_replace tmp ; struct xt_table_info * newinfo ; void * loc_cpu_entry ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 )  if ( tmp . size >= INT_MAX / num_possible_cpus ( ) )  if ( tmp . num_counters >= INT_MAX / sizeof ( struct xt_counters ) )  if ( tmp . num_counters == 0 )  tmp . name [ sizeof ( tmp . name ) - 1 ] = 0; newinfo = xt_alloc_table_info ( tmp . size ); if ( ! newinfo )  loc_cpu_entry = newinfo -> entries; if ( copy_from_user ( loc_cpu_entry , user + sizeof ( tmp ) , tmp . size ) != 0 )  ret = translate_compat_table ( tmp . name , tmp . valid_hooks , & newinfo , & loc_cpu_entry , tmp . size , tmp . num_entries , tmp . hook_entry , tmp . underflow ); static int translate_compat_table(const char unsigned int struct xt_table_info void unsigned int unsigned int unsigned int unsigned int *underflows) unsigned int i , j ; struct xt_table_info * newinfo , * info ; void * pos , * entry0 , * entry1 ; struct compat_arpt_entry * iter0 ; struct arpt_entry * iter1 ; unsigned int size ; info = * pinfo; entry0 = * pentry0; size = total_size; info -> number = number; for (i = 0; i < NF_ARP_NUMHOOKS; i++) info -> hook_entry [ i ] = 0xFFFFFFFF; info -> underflow [ i ] = 0xFFFFFFFF; j = 0; ret = check_compat_entry_size_and_hooks ( iter0 , info , & size , entry0 , entry0 + total_size , hook_entries , underflows , name ); static inline check_compat_entry_size_and_hooks(struct compat_arpt_entry struct xt_table_info unsigned int const unsigned char const unsigned char const unsigned int const unsigned int const char *name) struct xt_entry_target * t ; struct xt_target * target ; unsigned int entry_offset ; int ret , off , h ; return - EINVAL ; if ( e -> next_offset < sizeof ( struct compat_arpt_entry ) + sizeof ( struct compat_xt_entry_target ) )  return - EINVAL ; ret = check_entry ( ( struct arpt_entry * ) e , name ); static inline int check_entry(const struct arpt_entry *e, const char *name) const struct xt_entry_target * t ; if ( ! arp_checkentry ( & e -> arp ) )  static inline int arp_checkentry(const struct arpt_arp *arp) if ( arp -> flags & ~ARPT_F_MASK )  return 0 ; if ( arp -> invflags & ~ARPT_INV_MASK )  return 0 ; return 1 ; return - EINVAL ; if ( e -> target_offset + sizeof ( struct xt_entry_target ) > e -> next_offset )  return - EINVAL ; t = arpt_get_target_c ( e ); static inline const struct xt_entry_target arpt_get_target_c(const struct arpt_entry *e) return arpt_get_target ( ( struct arpt_entry * ) e ) ; if ( e -> target_offset + t -> u . target_size > e -> next_offset )  return - EINVAL ; return 0 ; if ( ret )  return ret ; off = sizeof ( struct arpt_entry ) - sizeof ( struct compat_arpt_entry ); entry_offset = ( void * ) e - ( void * ) base; t = compat_arpt_get_target ( e ); target = xt_request_find_target ( NFPROTO_ARP , t -> u . user . name , t -> u . user . revision ); if ( IS_ERR ( target ) )  ret = PTR_ERR ( target ); off += xt_compat_target_offset ( target ); ret = xt_compat_add_offset ( NFPROTO_ARP , entry_offset , off ); if ( ret )  return 0 ; return ret ; if ( ret != 0 )  ret = - EINVAL; if ( j != number )  for (i = 0; i < NF_ARP_NUMHOOKS; i++) if ( ! ( valid_hooks & ( 1 << i ) ) )  if ( info -> hook_entry [ i ] == 0xFFFFFFFF )  if ( info -> underflow [ i ] == 0xFFFFFFFF )  ret = - ENOMEM; newinfo = xt_alloc_table_info ( size ); if ( ! newinfo )  newinfo -> number = number; for (i = 0; i < NF_ARP_NUMHOOKS; i++) newinfo -> hook_entry [ i ] = info -> hook_entry [ i ]; newinfo -> underflow [ i ] = info -> underflow [ i ]; entry1 = newinfo -> entries; pos = entry1; size = total_size; ret = compat_copy_entry_from_user ( iter0 , & pos , & size , name , newinfo , entry1 ); static compat_copy_entry_from_user(struct compat_arpt_entry *e, void unsigned int *size, const char struct xt_table_info *newinfo, unsigned char *base) int ret , h ; ret = 0; return ret ; if ( ret )  if ( ! mark_source_chains ( newinfo , valid_hooks , entry1 ) )  static int mark_source_chains(const struct xt_table_info unsigned int valid_hooks, void *entry0) unsigned int hook ; for (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) )  e -> counters . pcnt = pos; const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; static inline const struct xt_entry_target arpt_get_target_c(const struct arpt_entry *e) return arpt_get_target ( ( struct arpt_entry * ) e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) )  return 0 ; e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ); if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 && unconditional ( & e -> arp ) ) || visited )  static inline bool unconditional(const struct arpt_arp *arp) static const struct arpt_arp uncond ; return memcmp ( arp , & uncond , sizeof ( uncond ) ) == 0 ; unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 )  return 0 ; e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ); oldpos = pos; pos = e -> counters . pcnt; e -> counters . pcnt = 0; if ( pos == oldpos )  e = ( struct arpt_entry * ) ( entry0 + pos ); while ( oldpos == pos + e -> next_offset )  size = e -> next_offset; e = ( struct arpt_entry * ) ( entry0 + pos + size ); e -> counters . pcnt = pos; pos += size; int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 )  if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) )  return 0 ; newpos = pos + e -> next_offset; e = ( struct arpt_entry * ) ( entry0 + newpos ); e -> counters . pcnt = pos; pos = newpos; return 1 ; iter1 -> counters . pcnt = xt_percpu_counter_alloc ( ); if ( strcmp ( arpt_get_target ( iter1 ) -> u . user . name , XT_ERROR_TARGET ) == 0 )  