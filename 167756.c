 nestegg_read_packet(nestegg * ctx, nestegg_packet ** pkt) uint64_t id , size ; * pkt = NULL; r = ne_peek_element ( ctx , & id , & size ); if ( r != 1 )  if ( ne_is_suspend_element ( id ) )  r = ne_read_element ( ctx , & id , & size ); if ( r != 1 )  r = ne_read_block ( ctx , id , size , pkt ); r = ne_parse ( ctx , NULL , - 1 ); if ( r != 1 )  static ne_read_block(nestegg * ctx, uint64_t block_id, uint64_t block_size, nestegg_packet ** data) int r ; uint64_t track_number , length , frame_sizes [ 256 ] , cluster_tc , flags , frames , tc_scale , total ; unsigned int i , lacing , track ; size_t consumed = 0 ; if ( block_size > LIMIT_BLOCK )  r = ne_read_vint ( ctx -> io , & track_number , & length ); if ( r != 1 )  if ( track_number == 0 )  consumed += length; r = ne_read_int ( ctx -> io , & timecode , 2 ); if ( r != 1 )  consumed += 2; r = ne_read_uint ( ctx -> io , & flags , 1 ); if ( r != 1 )  consumed += 1; frames = 0; lacing = ( flags & BLOCK_FLAGS_LACING ) >> 1; switch ( lacing )  frames = 1; r = ne_read_uint ( ctx -> io , & frames , 1 ); if ( r != 1 )  consumed += 1; frames += 1; if ( frames > 256 )  switch ( lacing )  frame_sizes [ 0 ] = block_size - consumed; if ( frames == 1 )  r = ne_read_xiph_lacing ( ctx -> io , block_size , & consumed , frames , frame_sizes ); if ( r != 1 )  if ( ( block_size - consumed ) % frames )  for (i = 0; i < frames; ++i) frame_sizes [ i ] = ( block_size - consumed ) / frames; if ( frames == 1 )  r = ne_read_ebml_lacing ( ctx -> io , block_size , & consumed , frames , frame_sizes ); if ( r != 1 )  total = consumed; for (i = 0; i < frames; ++i) total += frame_sizes [ i ]; if ( total > block_size )  if ( ne_map_track_number_to_index ( ctx , track_number , & track ) != 0 )  static ne_map_track_number_to_index(nestegg * unsigned int unsigned int * track_index) struct ebml_list_node * node ; struct track_entry * t_entry ; uint64_t t_number = 0 ; if ( ! track_index )  if ( track_number == 0 )  node = ctx -> segment . tracks . track_entry . head; while ( node )  t_entry = node -> data; if ( ne_get_uint ( t_entry -> number , & t_number ) != 0 )  if ( t_number == track_number )  node = node -> next; static ne_get_uint(struct ebml_type type, uint64_t * value) if ( ! type . read )  assert ( type . type == TYPE_UINT ); 