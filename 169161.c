static int vhost_scsi_release(struct inode *inode, struct file *f) struct vhost_scsi * vs = f -> private_data ; struct vhost_scsi_target t ; memcpy ( t . vhost_wwpn , vs -> vs_vhost_wwpn , sizeof ( t . vhost_wwpn ) ); vhost_scsi_clear_endpoint ( vs , & t ); static vhost_scsi_clear_endpoint(struct vhost_scsi struct vhost_scsi_target *t) mutex_lock ( & vs -> dev . mutex ); for (index = 0; index < vs->dev.nvqs; ++index) if ( ! vhost_vq_access_ok ( & vs -> vqs [ index ] . vq ) )  if ( ! vs -> vs_tpg )  tpg = vs -> vs_tpg [ target ]; if ( ! tpg )  mutex_lock ( & tpg -> tv_tpg_mutex ); tv_tport = tpg -> tport; if ( ! tv_tport )  if ( strcmp ( tv_tport -> tport_name , t -> vhost_wwpn ) )  pr_warn ( "tv_tport->tport_name: %s, tpg->tport_tpgt: " does not match t->vhost_wwpn: %s, t->vhost_tpgt: %hu\n" tv_tport -> tport_name , tpg -> tport_tpgt t -> vhost_wwpn , t -> vhost_tpgt ) tpg -> tv_tpg_vhost_count --; tpg -> vhost_scsi = NULL; vs -> vs_tpg [ target ] = NULL; mutex_unlock ( & tpg -> tv_tpg_mutex ); se_tpg = & tpg -> se_tpg; configfs_undepend_item ( se_tpg -> se_tpg_tfo -> tf_subsys , & se_tpg -> tpg_group . cg_item ); vq = & vs -> vqs [ i ] . vq; mutex_lock ( & vq -> mutex ); vq -> private_data = NULL; mutex_unlock ( & vq -> mutex ); vhost_scsi_flush ( vs ); static void vhost_scsi_flush(struct vhost_scsi *vs) tcm_vhost_init_inflight ( vs , old_inflight ); static void tcm_vhost_init_inflight(struct vhost_scsi struct vhost_scsi_inflight *old_inflight[]) vq = & vs -> vqs [ i ] . vq; mutex_lock ( & vq -> mutex ); idx = vs -> vqs [ i ] . inflight_idx; if ( old_inflight )  old_inflight [ i ] = & vs -> vqs [ i ] . inflights [ idx ]; vs -> vqs [ i ] . inflight_idx = idx ^ 1; new_inflight = & vs -> vqs [ i ] . inflights [ idx ^ 1 ]; kref_init ( & new_inflight -> kref ); init_completion ( & new_inflight -> comp ); mutex_unlock ( & vq -> mutex ); vhost_scsi_flush_vq ( vs , i ); static void vhost_scsi_flush_vq(struct vhost_scsi *vs, int index) vhost_poll_flush ( & vs -> vqs [ index ] . vq . poll ); vhost_work_flush ( & vs -> dev , & vs -> vs_completion_work ); vhost_work_flush ( & vs -> dev , & vs -> vs_event_work ); kfree ( vs -> vs_tpg ); vs -> vs_tpg = NULL; WARN_ON ( vs -> vs_events_nr ); mutex_unlock ( & vs -> dev . mutex ); mutex_unlock ( & tpg -> tv_tpg_mutex ); mutex_unlock ( & vs -> dev . mutex ); 